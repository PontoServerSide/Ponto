!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABORT_NOW	include/common/debug.h	42;"	d
ACCEPT4_USE_SOCKETCALL	include/common/syscall.h	138;"	d
ACCEPT_FIELD	contrib/halog/halog.c	29;"	d	file:
ACCESS_LVL_ADMIN	include/types/global.h	66;"	d
ACCESS_LVL_NONE	include/types/global.h	63;"	d
ACCESS_LVL_OPER	include/types/global.h	65;"	d
ACCESS_LVL_USER	include/types/global.h	64;"	d
ACL_COND_IF	include/types/acl.h	/^	ACL_COND_IF,		\/* positive condition (after 'if') *\/$/;"	e	enum:acl_cond_pol
ACL_COND_NONE	include/types/acl.h	/^	ACL_COND_NONE,		\/* no polarity set yet *\/$/;"	e	enum:acl_cond_pol
ACL_COND_UNLESS	include/types/acl.h	/^	ACL_COND_UNLESS,	\/* negative condition (after 'unless') *\/$/;"	e	enum:acl_cond_pol
ACL_TEST_FAIL	include/types/acl.h	/^	ACL_TEST_FAIL = 0,           \/* test failed *\/$/;"	e	enum:acl_test_res
ACL_TEST_MISS	include/types/acl.h	/^	ACL_TEST_MISS = 1,           \/* test may pass with more info *\/$/;"	e	enum:acl_test_res
ACL_TEST_PASS	include/types/acl.h	/^	ACL_TEST_PASS = 3,           \/* test passed *\/$/;"	e	enum:acl_test_res
ACT_ALLOW	include/common/regex.h	51;"	d
ACT_DENY	include/common/regex.h	54;"	d
ACT_PASS	include/common/regex.h	55;"	d
ACT_REMOVE	include/common/regex.h	53;"	d
ACT_REPLACE	include/common/regex.h	52;"	d
ACT_SETBE	include/common/regex.h	57;"	d
ACT_TARPIT	include/common/regex.h	56;"	d
ADDINC	Makefile	/^ADDINC =$/;"	m
ADDLIB	Makefile	/^ADDLIB =$/;"	m
AN_REQ_HTTP_BODY	include/types/channel.h	147;"	d
AN_REQ_HTTP_INNER	include/types/channel.h	145;"	d
AN_REQ_HTTP_PROCESS_BE	include/types/channel.h	143;"	d
AN_REQ_HTTP_PROCESS_FE	include/types/channel.h	140;"	d
AN_REQ_HTTP_TARPIT	include/types/channel.h	146;"	d
AN_REQ_HTTP_XFER_BODY	include/types/channel.h	150;"	d
AN_REQ_INSPECT_BE	include/types/channel.h	142;"	d
AN_REQ_INSPECT_FE	include/types/channel.h	138;"	d
AN_REQ_PRST_RDP_COOKIE	include/types/channel.h	149;"	d
AN_REQ_SRV_RULES	include/types/channel.h	144;"	d
AN_REQ_STICKING_RULES	include/types/channel.h	148;"	d
AN_REQ_SWITCHING_RULES	include/types/channel.h	141;"	d
AN_REQ_WAIT_HTTP	include/types/channel.h	139;"	d
AN_RES_HTTP_PROCESS_BE	include/types/channel.h	155;"	d
AN_RES_HTTP_PROCESS_FE	include/types/channel.h	156;"	d
AN_RES_HTTP_XFER_BODY	include/types/channel.h	158;"	d
AN_RES_INSPECT	include/types/channel.h	153;"	d
AN_RES_STORE_RULES	include/types/channel.h	157;"	d
AN_RES_WAIT_HTTP	include/types/channel.h	154;"	d
ARCH	Makefile	/^ARCH =$/;"	m
ARCH_FLAGS	Makefile	/^ARCH_FLAGS        = $(ARCH_FLAGS.$(ARCH))$/;"	m
ARCH_FLAGS.32	Makefile	/^ARCH_FLAGS.32     = -m32$/;"	m
ARCH_FLAGS.64	Makefile	/^ARCH_FLAGS.64     = -m64$/;"	m
ARCH_FLAGS.i386	Makefile	/^ARCH_FLAGS.i386   = -m32 -march=i386$/;"	m
ARCH_FLAGS.i486	Makefile	/^ARCH_FLAGS.i486   = -m32 -march=i486$/;"	m
ARCH_FLAGS.i586	Makefile	/^ARCH_FLAGS.i586   = -m32 -march=i586$/;"	m
ARCH_FLAGS.i686	Makefile	/^ARCH_FLAGS.i686   = -m32 -march=i686$/;"	m
ARCH_FLAGS.x86_64	Makefile	/^ARCH_FLAGS.x86_64 = -m64 -march=x86-64$/;"	m
ARG1	include/proto/arg.h	36;"	d
ARG2	include/proto/arg.h	39;"	d
ARG3	include/proto/arg.h	42;"	d
ARG4	include/proto/arg.h	45;"	d
ARG5	include/proto/arg.h	48;"	d
ARG6	include/proto/arg.h	51;"	d
ARG7	include/proto/arg.h	54;"	d
ARGC_ACL	include/types/arg.h	/^	ARGC_ACL = 0,  \/* ACL *\/$/;"	e	enum:__anon33
ARGC_CAP	include/types/arg.h	/^	ARGC_CAP,      \/* capture rule *\/$/;"	e	enum:__anon33
ARGC_HRQ	include/types/arg.h	/^	ARGC_HRQ,      \/* http-request *\/$/;"	e	enum:__anon33
ARGC_HRS	include/types/arg.h	/^	ARGC_HRS,      \/* http-response *\/$/;"	e	enum:__anon33
ARGC_LOG	include/types/arg.h	/^	ARGC_LOG,      \/* log-format *\/$/;"	e	enum:__anon33
ARGC_RDR	include/types/arg.h	/^	ARGC_RDR,      \/* redirect *\/$/;"	e	enum:__anon33
ARGC_STK	include/types/arg.h	/^	ARGC_STK,      \/* sticking rule *\/$/;"	e	enum:__anon33
ARGC_TRK	include/types/arg.h	/^	ARGC_TRK,      \/* tracking rule *\/$/;"	e	enum:__anon33
ARGC_UIF	include/types/arg.h	/^	ARGC_UIF,      \/* unique-id-format *\/$/;"	e	enum:__anon33
ARGM	include/proto/arg.h	33;"	d
ARGT_BE	include/types/arg.h	/^	ARGT_BE,       \/* a pointer to a backend only *\/$/;"	e	enum:__anon32
ARGT_FE	include/types/arg.h	/^	ARGT_FE,       \/* a pointer to a frontend only *\/$/;"	e	enum:__anon32
ARGT_IPV4	include/types/arg.h	/^	ARGT_IPV4,     \/* an IPv4 address *\/$/;"	e	enum:__anon32
ARGT_IPV6	include/types/arg.h	/^	ARGT_IPV6,     \/* an IPv6 address *\/$/;"	e	enum:__anon32
ARGT_MAP	include/types/arg.h	/^	ARGT_MAP,      \/* a pointer to a map descriptor *\/$/;"	e	enum:__anon32
ARGT_MSK4	include/types/arg.h	/^	ARGT_MSK4,     \/* an IPv4 address mask (integer or dotted), stored as ARGT_IPV4 *\/$/;"	e	enum:__anon32
ARGT_MSK6	include/types/arg.h	/^	ARGT_MSK6,     \/* an IPv6 address mask (integer or dotted), stored as ARGT_IPV4 *\/$/;"	e	enum:__anon32
ARGT_NBTYPES	include/types/arg.h	/^	ARGT_NBTYPES   \/* no more values past 15 *\/$/;"	e	enum:__anon32
ARGT_SINT	include/types/arg.h	/^	ARGT_SINT,     \/* signed integer, the sign (+\/-) was explicit. Falls back to UINT if no sign. *\/$/;"	e	enum:__anon32
ARGT_SIZE	include/types/arg.h	/^	ARGT_SIZE,     \/* a size in bytes by default, stored as ARGT_UINT *\/$/;"	e	enum:__anon32
ARGT_SRV	include/types/arg.h	/^	ARGT_SRV,      \/* a pointer to a server *\/$/;"	e	enum:__anon32
ARGT_STOP	include/types/arg.h	/^	ARGT_STOP = 0, \/* end of the arg list *\/$/;"	e	enum:__anon32
ARGT_STR	include/types/arg.h	/^	ARGT_STR,      \/* string *\/$/;"	e	enum:__anon32
ARGT_TAB	include/types/arg.h	/^	ARGT_TAB,      \/* a pointer to a stick table *\/$/;"	e	enum:__anon32
ARGT_TIME	include/types/arg.h	/^	ARGT_TIME,     \/* a delay in ms by default, stored as ARGT_UINT *\/$/;"	e	enum:__anon32
ARGT_UINT	include/types/arg.h	/^	ARGT_UINT,     \/* unsigned integer, which is a positive integer without any sign *\/$/;"	e	enum:__anon32
ARGT_USR	include/types/arg.h	/^	ARGT_USR,      \/* a pointer to a user list *\/$/;"	e	enum:__anon32
ARG_T_DELAY	include/types/stick_table.h	/^	ARG_T_DELAY,              \/* a delay which supports time units *\/$/;"	e	enum:__anon28
ARG_T_INT	include/types/stick_table.h	/^	ARG_T_INT,                \/* signed integer *\/$/;"	e	enum:__anon28
ARG_T_NONE	include/types/stick_table.h	/^	ARG_T_NONE = 0,           \/* data type takes no argument (default) *\/$/;"	e	enum:__anon28
ASSUME_SPLICE_WORKS	Makefile	/^  ASSUME_SPLICE_WORKS= implicit$/;"	m
AU_O_INSECURE	include/types/auth.h	21;"	d
Alert	src/log.c	/^void Alert(const char *fmt, ...)$/;"	f
B64BASE	src/base64.c	20;"	d	file:
B64CMAX	src/base64.c	22;"	d	file:
B64CMIN	src/base64.c	21;"	d	file:
B64MAX	contrib/base64/base64rev-gen.c	19;"	d	file:
B64PADV	contrib/base64/base64rev-gen.c	20;"	d	file:
B64PADV	src/base64.c	23;"	d	file:
BC_SSL_O_NONE	include/types/listener.h	102;"	d
BC_SSL_O_NO_SSLV3	include/types/listener.h	103;"	d
BC_SSL_O_NO_TLSV10	include/types/listener.h	104;"	d
BC_SSL_O_NO_TLSV11	include/types/listener.h	105;"	d
BC_SSL_O_NO_TLSV12	include/types/listener.h	106;"	d
BC_SSL_O_NO_TLS_TICKETS	include/types/listener.h	113;"	d
BC_SSL_O_USE_SSLV3	include/types/listener.h	108;"	d
BC_SSL_O_USE_TLSV10	include/types/listener.h	109;"	d
BC_SSL_O_USE_TLSV11	include/types/listener.h	110;"	d
BC_SSL_O_USE_TLSV12	include/types/listener.h	111;"	d
BE_LB_ALGO	include/types/backend.h	88;"	d
BE_LB_ALGO_FAS	include/types/backend.h	81;"	d
BE_LB_ALGO_HH	include/types/backend.h	86;"	d
BE_LB_ALGO_LC	include/types/backend.h	80;"	d
BE_LB_ALGO_NONE	include/types/backend.h	78;"	d
BE_LB_ALGO_PH	include/types/backend.h	85;"	d
BE_LB_ALGO_RCH	include/types/backend.h	87;"	d
BE_LB_ALGO_RR	include/types/backend.h	79;"	d
BE_LB_ALGO_SH	include/types/backend.h	83;"	d
BE_LB_ALGO_SRR	include/types/backend.h	82;"	d
BE_LB_ALGO_UH	include/types/backend.h	84;"	d
BE_LB_CB_FAS	include/types/backend.h	56;"	d
BE_LB_CB_LC	include/types/backend.h	55;"	d
BE_LB_HASH_CONS	include/types/backend.h	107;"	d
BE_LB_HASH_FUNC	include/types/backend.h	118;"	d
BE_LB_HASH_HDR	include/types/backend.h	47;"	d
BE_LB_HASH_MAP	include/types/backend.h	106;"	d
BE_LB_HASH_MOD	include/types/backend.h	112;"	d
BE_LB_HASH_PRM	include/types/backend.h	46;"	d
BE_LB_HASH_RDP	include/types/backend.h	48;"	d
BE_LB_HASH_SRC	include/types/backend.h	44;"	d
BE_LB_HASH_TYPE	include/types/backend.h	108;"	d
BE_LB_HASH_URI	include/types/backend.h	45;"	d
BE_LB_HFCN_DJB2	include/types/backend.h	116;"	d
BE_LB_HFCN_SDBM	include/types/backend.h	115;"	d
BE_LB_HFCN_WT6	include/types/backend.h	117;"	d
BE_LB_HMOD_AVAL	include/types/backend.h	111;"	d
BE_LB_KIND	include/types/backend.h	73;"	d
BE_LB_KIND_CB	include/types/backend.h	71;"	d
BE_LB_KIND_HI	include/types/backend.h	72;"	d
BE_LB_KIND_NONE	include/types/backend.h	69;"	d
BE_LB_KIND_RR	include/types/backend.h	70;"	d
BE_LB_LKUP	include/types/backend.h	100;"	d
BE_LB_LKUP_CHTREE	include/types/backend.h	98;"	d
BE_LB_LKUP_FSTREE	include/types/backend.h	99;"	d
BE_LB_LKUP_LCTREE	include/types/backend.h	97;"	d
BE_LB_LKUP_MAP	include/types/backend.h	95;"	d
BE_LB_LKUP_NONE	include/types/backend.h	94;"	d
BE_LB_LKUP_RRTREE	include/types/backend.h	96;"	d
BE_LB_NEED	include/types/backend.h	66;"	d
BE_LB_NEED_ADDR	include/types/backend.h	62;"	d
BE_LB_NEED_DATA	include/types/backend.h	63;"	d
BE_LB_NEED_HTTP	include/types/backend.h	64;"	d
BE_LB_NEED_NONE	include/types/backend.h	61;"	d
BE_LB_PARM	include/types/backend.h	58;"	d
BE_LB_PROP_DYN	include/types/backend.h	103;"	d
BE_LB_RR_DYN	include/types/backend.h	51;"	d
BE_LB_RR_STATIC	include/types/backend.h	52;"	d
BE_WEIGHT_SCALE	include/types/backend.h	131;"	d
BITS_PER_INT	include/common/compat.h	34;"	d
BUFSIZE	include/common/defaults.h	35;"	d
BUILD_OPTIONS	Makefile	/^BUILD_OPTIONS =$/;"	m
BYTES_SENT_FIELD	contrib/halog/halog.c	33;"	d	file:
CALLOC	include/common/config.h	53;"	d
CALLOC	include/common/config.h	55;"	d
CAPTURE_LEN	include/common/defaults.h	48;"	d
CC	Makefile	/^CC = gcc$/;"	m
CC	contrib/halog/Makefile	/^CC       = gcc$/;"	m
CC	contrib/ip6range/Makefile	/^CC       = gcc$/;"	m
CC	contrib/iprange/Makefile	/^CC       = gcc$/;"	m
CFG_GLOBAL	include/common/cfgparse.h	34;"	d
CFG_LISTEN	include/common/cfgparse.h	35;"	d
CFG_NONE	include/common/cfgparse.h	33;"	d
CFG_PEERS	include/common/cfgparse.h	37;"	d
CFG_USERLIST	include/common/cfgparse.h	36;"	d
CFLAGS	Makefile	/^CFLAGS = $(ARCH_FLAGS) $(CPU_CFLAGS) $(DEBUG_CFLAGS) $(SPEC_CFLAGS)$/;"	m
CF_ANA_TIMEOUT	include/types/channel.h	109;"	d
CF_AUTO_CLOSE	include/types/channel.h	76;"	d
CF_AUTO_CONNECT	include/types/channel.h	113;"	d
CF_DONT_READ	include/types/channel.h	115;"	d
CF_EXPECT_MORE	include/types/channel.h	116;"	d
CF_KERN_SPLICING	include/types/channel.h	111;"	d
CF_MASK_ANALYSER	include/types/channel.h	124;"	d
CF_MASK_STATIC	include/types/channel.h	127;"	d
CF_NEVER_WAIT	include/types/channel.h	118;"	d
CF_READ_ACTIVITY	include/types/channel.h	60;"	d
CF_READ_ATTACHED	include/types/channel.h	110;"	d
CF_READ_DONTWAIT	include/types/channel.h	112;"	d
CF_READ_ERROR	include/types/channel.h	59;"	d
CF_READ_NOEXP	include/types/channel.h	65;"	d
CF_READ_NULL	include/types/channel.h	56;"	d
CF_READ_PARTIAL	include/types/channel.h	57;"	d
CF_READ_TIMEOUT	include/types/channel.h	58;"	d
CF_SEND_DONTWAIT	include/types/channel.h	117;"	d
CF_SHUTR	include/types/channel.h	63;"	d
CF_SHUTR_NOW	include/types/channel.h	64;"	d
CF_SHUTW	include/types/channel.h	74;"	d
CF_SHUTW_NOW	include/types/channel.h	75;"	d
CF_STREAMER	include/types/channel.h	105;"	d
CF_STREAMER_FAST	include/types/channel.h	106;"	d
CF_WAKE_CONNECT	include/types/channel.h	62;"	d
CF_WAKE_ONCE	include/types/channel.h	120;"	d
CF_WAKE_WRITE	include/types/channel.h	73;"	d
CF_WRITE_ACTIVITY	include/types/channel.h	71;"	d
CF_WRITE_ERROR	include/types/channel.h	70;"	d
CF_WRITE_NULL	include/types/channel.h	67;"	d
CF_WRITE_PARTIAL	include/types/channel.h	68;"	d
CF_WRITE_TIMEOUT	include/types/channel.h	69;"	d
CHECK_HTTP_MESSAGE_FIRST	src/proto_http.c	9839;"	d	file:
CHECK_HTTP_MESSAGE_FIRST_PERM	src/proto_http.c	9842;"	d	file:
CHK_CONNTIME	include/common/defaults.h	124;"	d
CHK_RES_CONDPASS	include/types/checks.h	/^	CHK_RES_CONDPASS,               \/* check reports the server doesn't want new sessions *\/$/;"	e	enum:chk_result
CHK_RES_FAILED	include/types/checks.h	/^	CHK_RES_FAILED,                 \/* check failed *\/$/;"	e	enum:chk_result
CHK_RES_NEUTRAL	include/types/checks.h	/^	CHK_RES_NEUTRAL,                \/* valid check but no status information *\/$/;"	e	enum:chk_result
CHK_RES_PASSED	include/types/checks.h	/^	CHK_RES_PASSED,                 \/* check succeeded and server is fully up again *\/$/;"	e	enum:chk_result
CHK_RES_UNKNOWN	include/types/checks.h	/^	CHK_RES_UNKNOWN = 0,            \/* initialized to this by default *\/$/;"	e	enum:chk_result
CHK_ST_AGENT	include/types/checks.h	43;"	d
CHK_ST_CONFIGURED	include/types/checks.h	40;"	d
CHK_ST_ENABLED	include/types/checks.h	41;"	d
CHK_ST_INPROGRESS	include/types/checks.h	39;"	d
CHK_ST_PAUSED	include/types/checks.h	42;"	d
CHN_INFINITE_FORWARD	include/types/channel.h	162;"	d
CONFIG_HAP_MEM_OPTIM	include/common/config.h	40;"	d
CONFIG_HAP_TRANSPARENT	include/common/compat.h	109;"	d
CONNECT_DEFAULT_CIPHERS	include/common/defaults.h	199;"	d
CONN_FIELD	contrib/halog/halog.c	35;"	d	file:
CONN_RETRIES	include/common/defaults.h	122;"	d
COOKIE_DELIM	include/common/defaults.h	113;"	d
COOKIE_DELIM_DATE	include/common/defaults.h	119;"	d
COPTS	Makefile	/^COPTS  = -Iinclude -I$(EBTREE_DIR) -Wall$/;"	m
CO_ER_ADDR_INUSE	include/types/connection.h	/^	CO_ER_ADDR_INUSE,       \/* local address already in use *\/$/;"	e	enum:__anon75
CO_ER_CANT_BIND	include/types/connection.h	/^	CO_ER_CANT_BIND,        \/* can't bind to source address *\/$/;"	e	enum:__anon75
CO_ER_CONF_FDLIM	include/types/connection.h	/^	CO_ER_CONF_FDLIM,       \/* reached process' configured FD limitation *\/$/;"	e	enum:__anon75
CO_ER_FREE_PORTS	include/types/connection.h	/^	CO_ER_FREE_PORTS,       \/* no more free ports on the system *\/$/;"	e	enum:__anon75
CO_ER_NONE	include/types/connection.h	/^	CO_ER_NONE,             \/* no error *\/$/;"	e	enum:__anon75
CO_ER_NOPROTO	include/types/connection.h	/^	CO_ER_NOPROTO,          \/* protocol not supported *\/$/;"	e	enum:__anon75
CO_ER_PORT_RANGE	include/types/connection.h	/^	CO_ER_PORT_RANGE,       \/* source port range exhausted *\/$/;"	e	enum:__anon75
CO_ER_PROC_FDLIM	include/types/connection.h	/^	CO_ER_PROC_FDLIM,       \/* reached process' FD limitation *\/$/;"	e	enum:__anon75
CO_ER_PRX_ABORT	include/types/connection.h	/^	CO_ER_PRX_ABORT,        \/* client abort during PROXY protocol header *\/$/;"	e	enum:__anon75
CO_ER_PRX_BAD_HDR	include/types/connection.h	/^	CO_ER_PRX_BAD_HDR,      \/* bad PROXY protocol header *\/$/;"	e	enum:__anon75
CO_ER_PRX_BAD_PROTO	include/types/connection.h	/^	CO_ER_PRX_BAD_PROTO,    \/* unsupported protocol in PROXY header *\/$/;"	e	enum:__anon75
CO_ER_PRX_EMPTY	include/types/connection.h	/^	CO_ER_PRX_EMPTY,        \/* nothing received in PROXY protocol header *\/$/;"	e	enum:__anon75
CO_ER_PRX_NOT_HDR	include/types/connection.h	/^	CO_ER_PRX_NOT_HDR,      \/* not a PROXY protocol header *\/$/;"	e	enum:__anon75
CO_ER_PRX_TIMEOUT	include/types/connection.h	/^	CO_ER_PRX_TIMEOUT,      \/* timeout while waiting for a PROXY header *\/$/;"	e	enum:__anon75
CO_ER_PRX_TRUNCATED	include/types/connection.h	/^	CO_ER_PRX_TRUNCATED,    \/* truncated PROXY protocol header *\/$/;"	e	enum:__anon75
CO_ER_SOCK_ERR	include/types/connection.h	/^	CO_ER_SOCK_ERR,         \/* other socket error *\/$/;"	e	enum:__anon75
CO_ER_SSL_ABORT	include/types/connection.h	/^	CO_ER_SSL_ABORT,        \/* client abort during SSL handshake *\/$/;"	e	enum:__anon75
CO_ER_SSL_CA_FAIL	include/types/connection.h	/^	CO_ER_SSL_CA_FAIL,      \/* client cert verification failed in the CA chain *\/$/;"	e	enum:__anon75
CO_ER_SSL_CRT_FAIL	include/types/connection.h	/^	CO_ER_SSL_CRT_FAIL,     \/* client cert verification failed on the certificate *\/$/;"	e	enum:__anon75
CO_ER_SSL_EMPTY	include/types/connection.h	/^	CO_ER_SSL_EMPTY,        \/* client closed during SSL handshake *\/$/;"	e	enum:__anon75
CO_ER_SSL_HANDSHAKE	include/types/connection.h	/^	CO_ER_SSL_HANDSHAKE,    \/* SSL error during handshake *\/$/;"	e	enum:__anon75
CO_ER_SSL_HANDSHAKE_HB	include/types/connection.h	/^	CO_ER_SSL_HANDSHAKE_HB, \/* SSL error during handshake with heartbeat present *\/$/;"	e	enum:__anon75
CO_ER_SSL_KILLED_HB	include/types/connection.h	/^	CO_ER_SSL_KILLED_HB,    \/* Stopped a TLSv1 heartbeat attack (CVE-2014-0160) *\/$/;"	e	enum:__anon75
CO_ER_SSL_NO_MEM	include/types/connection.h	/^	CO_ER_SSL_NO_MEM,       \/* no more memory to allocate an SSL connection *\/$/;"	e	enum:__anon75
CO_ER_SSL_NO_TARGET	include/types/connection.h	/^	CO_ER_SSL_NO_TARGET,    \/* unknown target (not client nor server) *\/$/;"	e	enum:__anon75
CO_ER_SSL_RENEG	include/types/connection.h	/^	CO_ER_SSL_RENEG,        \/* forbidden client renegociation *\/$/;"	e	enum:__anon75
CO_ER_SSL_TIMEOUT	include/types/connection.h	/^	CO_ER_SSL_TIMEOUT,      \/* timeout during SSL handshake *\/$/;"	e	enum:__anon75
CO_ER_SSL_TOO_MANY	include/types/connection.h	/^	CO_ER_SSL_TOO_MANY,     \/* too many SSL connections *\/$/;"	e	enum:__anon75
CO_ER_SYS_FDLIM	include/types/connection.h	/^	CO_ER_SYS_FDLIM,        \/* reached system's FD limitation *\/$/;"	e	enum:__anon75
CO_ER_SYS_MEMLIM	include/types/connection.h	/^	CO_ER_SYS_MEMLIM,       \/* reached system buffers limitation *\/$/;"	e	enum:__anon75
CO_FL_ACCEPT_PROXY	include/types/connection.h	/^	CO_FL_ACCEPT_PROXY  = 0x04000000,  \/* receive a valid PROXY protocol header *\/$/;"	e	enum:__anon74
CO_FL_ADDR_FROM_SET	include/types/connection.h	/^	CO_FL_ADDR_FROM_SET = 0x00001000,  \/* addr.from is set *\/$/;"	e	enum:__anon74
CO_FL_ADDR_TO_SET	include/types/connection.h	/^	CO_FL_ADDR_TO_SET   = 0x00002000,  \/* addr.to is set *\/$/;"	e	enum:__anon74
CO_FL_CONNECTED	include/types/connection.h	/^	CO_FL_CONNECTED     = 0x00200000,  \/* the connection is now established *\/$/;"	e	enum:__anon74
CO_FL_CONN_STATE	include/types/connection.h	/^	CO_FL_CONN_STATE    = 0x00FF0000,  \/* all shut\/connected flags *\/$/;"	e	enum:__anon74
CO_FL_CTRL_READY	include/types/connection.h	/^	CO_FL_CTRL_READY    = 0x00000100, \/* FD was registered, fd_delete() needed *\/$/;"	e	enum:__anon74
CO_FL_CURR_RD_ENA	include/types/connection.h	/^	CO_FL_CURR_RD_ENA   = 0x00000004,  \/* receiving is currently allowed *\/$/;"	e	enum:__anon74
CO_FL_CURR_WR_ENA	include/types/connection.h	/^	CO_FL_CURR_WR_ENA   = 0x00000040,  \/* sending is currently desired *\/$/;"	e	enum:__anon74
CO_FL_DATA_RD_ENA	include/types/connection.h	/^	CO_FL_DATA_RD_ENA   = 0x00000002,  \/* receiving data is allowed *\/$/;"	e	enum:__anon74
CO_FL_DATA_RD_SH	include/types/connection.h	/^	CO_FL_DATA_RD_SH    = 0x00010000,  \/* DATA layer was notified about shutr\/read0 *\/$/;"	e	enum:__anon74
CO_FL_DATA_WR_ENA	include/types/connection.h	/^	CO_FL_DATA_WR_ENA   = 0x00000020,  \/* sending data is desired *\/$/;"	e	enum:__anon74
CO_FL_DATA_WR_SH	include/types/connection.h	/^	CO_FL_DATA_WR_SH    = 0x00020000,  \/* DATA layer asked for shutw *\/$/;"	e	enum:__anon74
CO_FL_ERROR	include/types/connection.h	/^	CO_FL_ERROR         = 0x00100000,  \/* a fatal error was reported     *\/$/;"	e	enum:__anon74
CO_FL_HANDSHAKE	include/types/connection.h	/^	CO_FL_HANDSHAKE     = CO_FL_SEND_PROXY | CO_FL_SSL_WAIT_HS | CO_FL_ACCEPT_PROXY,$/;"	e	enum:__anon74
CO_FL_INIT_DATA	include/types/connection.h	/^	CO_FL_INIT_DATA     = 0x00004000,  \/* initialize the data layer before using it *\/$/;"	e	enum:__anon74
CO_FL_NONE	include/types/connection.h	/^	CO_FL_NONE          = 0x00000000,  \/* Just for initialization purposes *\/$/;"	e	enum:__anon74
CO_FL_POLL_SOCK	include/types/connection.h	/^	CO_FL_POLL_SOCK     = CO_FL_HANDSHAKE | CO_FL_WAIT_L4_CONN | CO_FL_WAIT_L6_CONN,$/;"	e	enum:__anon74
CO_FL_SEND_PROXY	include/types/connection.h	/^	CO_FL_SEND_PROXY    = 0x01000000,  \/* send a valid PROXY protocol header *\/$/;"	e	enum:__anon74
CO_FL_SOCK_RD_ENA	include/types/connection.h	/^	CO_FL_SOCK_RD_ENA   = 0x00000001,  \/* receiving handshakes is allowed *\/$/;"	e	enum:__anon74
CO_FL_SOCK_RD_SH	include/types/connection.h	/^	CO_FL_SOCK_RD_SH    = 0x00040000,  \/* SOCK layer was notified about shutr\/read0 *\/$/;"	e	enum:__anon74
CO_FL_SOCK_WR_ENA	include/types/connection.h	/^	CO_FL_SOCK_WR_ENA   = 0x00000010,  \/* sending handshakes is desired *\/$/;"	e	enum:__anon74
CO_FL_SOCK_WR_SH	include/types/connection.h	/^	CO_FL_SOCK_WR_SH    = 0x00080000,  \/* SOCK layer asked for shutw *\/$/;"	e	enum:__anon74
CO_FL_SSL_WAIT_HS	include/types/connection.h	/^	CO_FL_SSL_WAIT_HS   = 0x02000000,  \/* wait for an SSL handshake to complete *\/$/;"	e	enum:__anon74
CO_FL_WAIT_DATA	include/types/connection.h	/^	CO_FL_WAIT_DATA     = 0x00000400,  \/* data source is empty *\/$/;"	e	enum:__anon74
CO_FL_WAIT_L4_CONN	include/types/connection.h	/^	CO_FL_WAIT_L4_CONN  = 0x00400000,  \/* waiting for L4 to be connected *\/$/;"	e	enum:__anon74
CO_FL_WAIT_L6_CONN	include/types/connection.h	/^	CO_FL_WAIT_L6_CONN  = 0x00800000,  \/* waiting for L6 to be connected (eg: SSL) *\/$/;"	e	enum:__anon74
CO_FL_WAIT_ROOM	include/types/connection.h	/^	CO_FL_WAIT_ROOM     = 0x00000800,  \/* data sink is full *\/$/;"	e	enum:__anon74
CO_FL_WAKE_DATA	include/types/connection.h	/^	CO_FL_WAKE_DATA     = 0x00008000,  \/* wake-up data layer upon activity at the transport layer *\/$/;"	e	enum:__anon74
CO_FL_XPRT_READY	include/types/connection.h	/^	CO_FL_XPRT_READY    = 0x00000200, \/* xprt_init() done, xprt_close() needed *\/$/;"	e	enum:__anon74
CO_FL_XPRT_TRACKED	include/types/connection.h	/^	CO_FL_XPRT_TRACKED  = 0x80000000,$/;"	e	enum:__anon74
CO_SFL_MSG_MORE	include/types/connection.h	/^	CO_SFL_MSG_MORE    = 0x0001,    \/* More data to come afterwards *\/$/;"	e	enum:__anon77
CO_SFL_STREAMER	include/types/connection.h	/^	CO_SFL_STREAMER    = 0x0002,    \/* Producer is continuously streaming data *\/$/;"	e	enum:__anon77
CO_SRC_BIND	include/types/connection.h	/^	CO_SRC_BIND        = 0x0008,    \/* bind to a specific source address when connecting *\/$/;"	e	enum:__anon76
CO_SRC_TPROXY_ADDR	include/types/connection.h	/^	CO_SRC_TPROXY_ADDR = 0x0001,    \/* bind to this non-local address when connecting *\/$/;"	e	enum:__anon76
CO_SRC_TPROXY_CIP	include/types/connection.h	/^	CO_SRC_TPROXY_CIP  = 0x0002,    \/* bind to the client's IP address when connecting *\/$/;"	e	enum:__anon76
CO_SRC_TPROXY_CLI	include/types/connection.h	/^	CO_SRC_TPROXY_CLI  = 0x0003,    \/* bind to the client's IP+port when connecting *\/$/;"	e	enum:__anon76
CO_SRC_TPROXY_DYN	include/types/connection.h	/^	CO_SRC_TPROXY_DYN  = 0x0004,    \/* bind to a dynamically computed non-local address *\/$/;"	e	enum:__anon76
CO_SRC_TPROXY_MASK	include/types/connection.h	/^	CO_SRC_TPROXY_MASK = 0x0007,    \/* bind to a non-local address when connecting *\/$/;"	e	enum:__anon76
CPU	Makefile	/^CPU = generic$/;"	m
CPU_CFLAGS	Makefile	/^CPU_CFLAGS            = $(CPU_CFLAGS.$(CPU))$/;"	m
CPU_CFLAGS.generic	Makefile	/^CPU_CFLAGS.generic    = -O2$/;"	m
CPU_CFLAGS.i586	Makefile	/^CPU_CFLAGS.i586       = -O2 -march=i586$/;"	m
CPU_CFLAGS.i686	Makefile	/^CPU_CFLAGS.i686       = -O2 -march=i686$/;"	m
CPU_CFLAGS.native	Makefile	/^CPU_CFLAGS.native     = -O2 -march=native$/;"	m
CPU_CFLAGS.ultrasparc	Makefile	/^CPU_CFLAGS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc$/;"	m
DAY	include/common/standard.h	540;"	d
DEBUG	Makefile	/^DEBUG =$/;"	m
DEBUG_CFLAGS	Makefile	/^  DEBUG_CFLAGS    =$/;"	m
DEBUG_CFLAGS	Makefile	/^DEBUG_CFLAGS = -g$/;"	m
DEFAULT_MAXCONN	include/common/defaults.h	155;"	d
DEFAULT_MAXCONN	include/common/defaults.h	158;"	d
DEFAULT_MAXCONN	include/common/defaults.h	159;"	d
DEFINE	Makefile	/^DEFINE =$/;"	m
DEFINE	contrib/halog/Makefile	/^DEFINE   =$/;"	m
DEF_AGENT_FALLTIME	include/common/defaults.h	128;"	d
DEF_AGENT_RISETIME	include/common/defaults.h	129;"	d
DEF_CHECK_REQ	include/common/defaults.h	130;"	d
DEF_CHKINTR	include/common/defaults.h	125;"	d
DEF_FALLTIME	include/common/defaults.h	126;"	d
DEF_HANA_ERRLIMIT	include/common/defaults.h	136;"	d
DEF_HANA_ONERR	include/common/defaults.h	135;"	d
DEF_LDAP_CHECK_REQ	include/common/defaults.h	132;"	d
DEF_REDIS_CHECK_REQ	include/common/defaults.h	133;"	d
DEF_RISETIME	include/common/defaults.h	127;"	d
DEF_SMTP_CHECK_REQ	include/common/defaults.h	131;"	d
DEF_XFORWARDFOR_HDR	include/common/defaults.h	139;"	d
DEF_XORIGINALTO_HDR	include/common/defaults.h	142;"	d
DESTDIR	Makefile	/^DESTDIR =$/;"	m
DIR_RD	include/types/fd.h	/^	DIR_RD=0,$/;"	e	enum:__anon53
DIR_WR	include/types/fd.h	/^	DIR_WR=1,$/;"	e	enum:__anon53
DLIST_ADD	include/common/mini-clist.h	77;"	d
DLIST_DEL	include/common/mini-clist.h	80;"	d
DLMALLOC_SRC	Makefile	/^DLMALLOC_SRC=src\/dlmalloc.c$/;"	m
DLMALLOC_THRES	Makefile	/^DLMALLOC_THRES = 4096$/;"	m
DOCDIR	Makefile	/^DOCDIR = $(PREFIX)\/doc\/haproxy$/;"	m
DPRINTF	include/common/debug.h	28;"	d
DPRINTF	include/common/debug.h	30;"	d
EAT_AND_JUMP_OR_RETURN	src/proto_http.c	1089;"	d	file:
EB32_ROOT	ebtree/eb32tree.h	30;"	d
EB32_TREE_HEAD	ebtree/eb32tree.h	31;"	d
EB64_ROOT	ebtree/eb64tree.h	30;"	d
EB64_TREE_HEAD	ebtree/eb64tree.h	31;"	d
EBMB_ROOT	ebtree/ebmbtree.h	30;"	d
EBMB_TREE_HEAD	ebtree/ebmbtree.h	31;"	d
EBPT_ROOT	ebtree/ebpttree.h	32;"	d
EBPT_TREE_HEAD	ebtree/ebpttree.h	33;"	d
EBTREE_DIR	Makefile	/^EBTREE_DIR := ebtree$/;"	m
EBTREE_DIR	contrib/halog/Makefile	/^EBTREE_DIR = ..\/..\/ebtree$/;"	m
EBTREE_OBJS	Makefile	/^EBTREE_OBJS = $(EBTREE_DIR)\/ebtree.o \\$/;"	m
EB_LEAF	ebtree/ebtree.h	344;"	d
EB_LEFT	ebtree/ebtree.h	342;"	d
EB_NODE	ebtree/ebtree.h	345;"	d
EB_NODE_BITS	ebtree/ebtree.h	335;"	d
EB_NODE_BRANCHES	ebtree/ebtree.h	336;"	d
EB_NODE_BRANCH_MASK	ebtree/ebtree.h	337;"	d
EB_NORMAL	ebtree/ebtree.h	351;"	d
EB_RGHT	ebtree/ebtree.h	343;"	d
EB_ROOT	ebtree/ebtree.h	389;"	d
EB_ROOT_UNIQUE	ebtree/ebtree.h	394;"	d
EB_TREE_HEAD	ebtree/ebtree.h	399;"	d
EB_UNIQUE	ebtree/ebtree.h	352;"	d
ECDHE_DEFAULT_CURVE	include/common/defaults.h	209;"	d
EPOLLERR	include/common/epoll.h	57;"	d
EPOLLET	include/common/epoll.h	60;"	d
EPOLLHUP	include/common/epoll.h	58;"	d
EPOLLIN	include/common/epoll.h	54;"	d
EPOLLONESHOT	include/common/epoll.h	59;"	d
EPOLLOUT	include/common/epoll.h	56;"	d
EPOLLPRI	include/common/epoll.h	55;"	d
EPOLLRDHUP	src/ev_epoll.c	45;"	d	file:
EPOLL_CTL_ADD	include/common/epoll.h	47;"	d
EPOLL_CTL_DEL	include/common/epoll.h	48;"	d
EPOLL_CTL_MOD	include/common/epoll.h	49;"	d
ERR_ABORT	include/common/errors.h	34;"	d
ERR_ALERT	include/common/errors.h	36;"	d
ERR_CODE	include/common/errors.h	38;"	d
ERR_FATAL	include/common/errors.h	33;"	d
ERR_NONE	include/common/errors.h	31;"	d
ERR_RETRYABLE	include/common/errors.h	32;"	d
ERR_WARN	include/common/errors.h	35;"	d
EXPECT_LF_HERE	src/proto_http.c	1084;"	d	file:
EXTRA	Makefile	/^EXTRA =$/;"	m
FD_EV_ACTIVE	include/types/fd.h	48;"	d
FD_EV_ACTIVE_R	include/types/fd.h	60;"	d
FD_EV_ACTIVE_RW	include/types/fd.h	62;"	d
FD_EV_ACTIVE_W	include/types/fd.h	61;"	d
FD_EV_POLLED	include/types/fd.h	50;"	d
FD_EV_POLLED_R	include/types/fd.h	56;"	d
FD_EV_POLLED_RW	include/types/fd.h	58;"	d
FD_EV_POLLED_W	include/types/fd.h	57;"	d
FD_EV_READY	include/types/fd.h	49;"	d
FD_EV_READY_R	include/types/fd.h	64;"	d
FD_EV_READY_RW	include/types/fd.h	66;"	d
FD_EV_READY_W	include/types/fd.h	65;"	d
FD_EV_STATUS	include/types/fd.h	52;"	d
FD_EV_STATUS_R	include/types/fd.h	53;"	d
FD_EV_STATUS_W	include/types/fd.h	54;"	d
FD_POLL_DATA	include/types/fd.h	45;"	d
FD_POLL_ERR	include/types/fd.h	42;"	d
FD_POLL_HUP	include/types/fd.h	43;"	d
FD_POLL_IN	include/types/fd.h	39;"	d
FD_POLL_OUT	include/types/fd.h	41;"	d
FD_POLL_PRI	include/types/fd.h	40;"	d
FD_POLL_STICKY	include/types/fd.h	46;"	d
FD_SETS_ARE_BITFIELDS	src/proto_http.c	238;"	d	file:
FD_ST_ABORT	include/types/fd.h	/^	FD_ST_ABORT,$/;"	e	enum:fd_states
FD_ST_ACTIVE	include/types/fd.h	/^	FD_ST_ACTIVE,$/;"	e	enum:fd_states
FD_ST_DISABLED	include/types/fd.h	/^	FD_ST_DISABLED = 0,$/;"	e	enum:fd_states
FD_ST_MUSTPOLL	include/types/fd.h	/^	FD_ST_MUSTPOLL,$/;"	e	enum:fd_states
FD_ST_PAUSED	include/types/fd.h	/^	FD_ST_PAUSED,$/;"	e	enum:fd_states
FD_ST_POLLED	include/types/fd.h	/^	FD_ST_POLLED,$/;"	e	enum:fd_states
FD_ST_READY	include/types/fd.h	/^	FD_ST_READY$/;"	e	enum:fd_states
FD_ST_STOPPED	include/types/fd.h	/^	FD_ST_STOPPED,$/;"	e	enum:fd_states
FGETS2_BUFSIZE	contrib/halog/fgets2.c	34;"	d	file:
FIELD_INDEX	contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_INDEX => 10001;$/;"	c
FIELD_NAME	contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_NAME => 10002;$/;"	c
FILT2_TIMESTAMP	contrib/halog/halog.c	120;"	d	file:
FILT_ACC_COUNT	contrib/halog/halog.c	81;"	d	file:
FILT_ACC_DELAY	contrib/halog/halog.c	80;"	d	file:
FILT_COUNT_COOK_CODES	contrib/halog/halog.c	117;"	d	file:
FILT_COUNT_IP_COUNT	contrib/halog/halog.c	118;"	d	file:
FILT_COUNT_ONLY	contrib/halog/halog.c	76;"	d	file:
FILT_COUNT_SRV_STATUS	contrib/halog/halog.c	90;"	d	file:
FILT_COUNT_STATUS	contrib/halog/halog.c	89;"	d	file:
FILT_COUNT_TERM_CODES	contrib/halog/halog.c	91;"	d	file:
FILT_COUNT_URL_ANY	contrib/halog/halog.c	113;"	d	file:
FILT_COUNT_URL_BAVG	contrib/halog/halog.c	110;"	d	file:
FILT_COUNT_URL_BTOT	contrib/halog/halog.c	111;"	d	file:
FILT_COUNT_URL_COUNT	contrib/halog/halog.c	94;"	d	file:
FILT_COUNT_URL_ERR	contrib/halog/halog.c	95;"	d	file:
FILT_COUNT_URL_ONLY	contrib/halog/halog.c	93;"	d	file:
FILT_COUNT_URL_TAVG	contrib/halog/halog.c	97;"	d	file:
FILT_COUNT_URL_TAVGO	contrib/halog/halog.c	99;"	d	file:
FILT_COUNT_URL_TTOT	contrib/halog/halog.c	96;"	d	file:
FILT_COUNT_URL_TTOTO	contrib/halog/halog.c	98;"	d	file:
FILT_ERRORS_ONLY	contrib/halog/halog.c	79;"	d	file:
FILT_GRAPH_TIMERS	contrib/halog/halog.c	82;"	d	file:
FILT_HTTP_ONLY	contrib/halog/halog.c	101;"	d	file:
FILT_HTTP_STATUS	contrib/halog/halog.c	105;"	d	file:
FILT_INVERT	contrib/halog/halog.c	77;"	d	file:
FILT_INVERT_ERRORS	contrib/halog/halog.c	86;"	d	file:
FILT_INVERT_HTTP_STATUS	contrib/halog/halog.c	106;"	d	file:
FILT_INVERT_TERM_CODE_NAME	contrib/halog/halog.c	103;"	d	file:
FILT_INVERT_TIME_RESP	contrib/halog/halog.c	87;"	d	file:
FILT_PERCENTILE	contrib/halog/halog.c	83;"	d	file:
FILT_QUEUE_ONLY	contrib/halog/halog.c	107;"	d	file:
FILT_QUEUE_SRV_ONLY	contrib/halog/halog.c	108;"	d	file:
FILT_QUIET	contrib/halog/halog.c	78;"	d	file:
FILT_TERM_CODE_NAME	contrib/halog/halog.c	102;"	d	file:
FILT_TIME_RESP	contrib/halog/halog.c	84;"	d	file:
FNV_32_PRIME	tests/test_hashes.c	293;"	d	file:
FOREACH_ITEM	include/common/mini-clist.h	160;"	d
FOREACH_ITEM_SAFE	include/common/mini-clist.h	172;"	d
FREE	include/common/config.h	59;"	d
FREE	include/common/config.h	61;"	d
FSM_PRINTF	include/common/debug.h	34;"	d
FSM_PRINTF	include/common/debug.h	36;"	d
F_SETPIPE_SZ	include/common/compat.h	81;"	d
Fnv32_t	tests/test_hashes.c	/^typedef unsigned long Fnv32_t;$/;"	t	file:
GTUNE_USE_EPOLL	include/types/global.h	56;"	d
GTUNE_USE_GAI	include/types/global.h	60;"	d
GTUNE_USE_KQUEUE	include/types/global.h	57;"	d
GTUNE_USE_POLL	include/types/global.h	55;"	d
GTUNE_USE_SELECT	include/types/global.h	54;"	d
GTUNE_USE_SPLICE	include/types/global.h	59;"	d
HANA_OBS_LAYER4	include/types/checks.h	/^	HANA_OBS_LAYER4,		\/* Observe L4 - for example tcp *\/$/;"	e	enum:__anon39
HANA_OBS_LAYER7	include/types/checks.h	/^	HANA_OBS_LAYER7,		\/* Observe L7 - for example http *\/$/;"	e	enum:__anon39
HANA_OBS_NONE	include/types/checks.h	/^	HANA_OBS_NONE		= 0,$/;"	e	enum:__anon39
HANA_OBS_SIZE	include/types/checks.h	/^	HANA_OBS_SIZE$/;"	e	enum:__anon39
HANA_ONERR_FAILCHK	include/types/checks.h	/^	HANA_ONERR_FAILCHK,		\/* Simulate a failed check *\/$/;"	e	enum:__anon36
HANA_ONERR_FASTINTER	include/types/checks.h	/^	HANA_ONERR_FASTINTER,		\/* Force fastinter*\/$/;"	e	enum:__anon36
HANA_ONERR_MARKDWN	include/types/checks.h	/^	HANA_ONERR_MARKDWN,		\/* Mark this server down, now! *\/$/;"	e	enum:__anon36
HANA_ONERR_SUDDTH	include/types/checks.h	/^	HANA_ONERR_SUDDTH,		\/* Enters sudden death - one more failed check will mark this server down *\/$/;"	e	enum:__anon36
HANA_ONERR_UNKNOWN	include/types/checks.h	/^	HANA_ONERR_UNKNOWN	= 0,$/;"	e	enum:__anon36
HANA_ONMARKEDDOWN_NONE	include/types/checks.h	/^	HANA_ONMARKEDDOWN_NONE	= 0,$/;"	e	enum:__anon37
HANA_ONMARKEDDOWN_SHUTDOWNSESSIONS	include/types/checks.h	/^	HANA_ONMARKEDDOWN_SHUTDOWNSESSIONS,	\/* Shutdown peer sessions *\/$/;"	e	enum:__anon37
HANA_ONMARKEDUP_NONE	include/types/checks.h	/^	HANA_ONMARKEDUP_NONE	= 0,$/;"	e	enum:__anon38
HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS	include/types/checks.h	/^	HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS,	\/* Shutdown peer sessions *\/$/;"	e	enum:__anon38
HANA_STATUS_HTTP_BROKEN_PIPE	include/types/checks.h	/^	HANA_STATUS_HTTP_BROKEN_PIPE,	\/* Unexpected close from server *\/$/;"	e	enum:__anon35
HANA_STATUS_HTTP_HDRRSP	include/types/checks.h	/^	HANA_STATUS_HTTP_HDRRSP,	\/* Invalid http response (headers) *\/$/;"	e	enum:__anon35
HANA_STATUS_HTTP_OK	include/types/checks.h	/^	HANA_STATUS_HTTP_OK,		\/* Correct http response *\/$/;"	e	enum:__anon35
HANA_STATUS_HTTP_READ_ERROR	include/types/checks.h	/^	HANA_STATUS_HTTP_READ_ERROR,	\/* Read error *\/$/;"	e	enum:__anon35
HANA_STATUS_HTTP_READ_TIMEOUT	include/types/checks.h	/^	HANA_STATUS_HTTP_READ_TIMEOUT,	\/* Read timeout *\/$/;"	e	enum:__anon35
HANA_STATUS_HTTP_RSP	include/types/checks.h	/^	HANA_STATUS_HTTP_RSP,		\/* Invalid http response *\/$/;"	e	enum:__anon35
HANA_STATUS_HTTP_STS	include/types/checks.h	/^	HANA_STATUS_HTTP_STS,		\/* Wrong http response, for example HTTP 5xx *\/$/;"	e	enum:__anon35
HANA_STATUS_L4_ERR	include/types/checks.h	/^	HANA_STATUS_L4_ERR,		\/* L4 unsuccessful connection *\/$/;"	e	enum:__anon35
HANA_STATUS_L4_OK	include/types/checks.h	/^	HANA_STATUS_L4_OK,		\/* L4 successful connection *\/$/;"	e	enum:__anon35
HANA_STATUS_SIZE	include/types/checks.h	/^	HANA_STATUS_SIZE$/;"	e	enum:__anon35
HANA_STATUS_UNKNOWN	include/types/checks.h	/^	HANA_STATUS_UNKNOWN	= 0,$/;"	e	enum:__anon35
HAPROXY_BACKENDS	tests/test_hashes.c	31;"	d	file:
HAPROXY_DATE	include/common/version.h	64;"	d
HAPROXY_VERSION	include/common/version.h	58;"	d
HASHSIZE	tests/test_hashes.c	449;"	d	file:
HCHK_DESC_LEN	include/common/defaults.h	194;"	d
HCHK_STATUS_CHECKED	include/types/checks.h	/^	HCHK_STATUS_CHECKED,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon34
HCHK_STATUS_HANA	include/types/checks.h	/^	HCHK_STATUS_HANA,		\/* Health analyze detected enough consecutive errors *\/$/;"	e	enum:__anon34
HCHK_STATUS_INI	include/types/checks.h	/^	HCHK_STATUS_INI,		\/* Initializing *\/$/;"	e	enum:__anon34
HCHK_STATUS_L4CON	include/types/checks.h	/^	HCHK_STATUS_L4CON,		\/* L4 connection problem, for example: *\/$/;"	e	enum:__anon34
HCHK_STATUS_L4OK	include/types/checks.h	/^	HCHK_STATUS_L4OK,		\/* L4 check passed, for example tcp connect *\/$/;"	e	enum:__anon34
HCHK_STATUS_L4TOUT	include/types/checks.h	/^	HCHK_STATUS_L4TOUT,		\/* L4 timeout *\/$/;"	e	enum:__anon34
HCHK_STATUS_L57DATA	include/types/checks.h	/^	HCHK_STATUS_L57DATA,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon34
HCHK_STATUS_L6OK	include/types/checks.h	/^	HCHK_STATUS_L6OK,		\/* L6 check passed *\/$/;"	e	enum:__anon34
HCHK_STATUS_L6RSP	include/types/checks.h	/^	HCHK_STATUS_L6RSP,		\/* L6 invalid response - protocol error *\/$/;"	e	enum:__anon34
HCHK_STATUS_L6TOUT	include/types/checks.h	/^	HCHK_STATUS_L6TOUT,		\/* L6 (SSL) timeout *\/$/;"	e	enum:__anon34
HCHK_STATUS_L7OKCD	include/types/checks.h	/^	HCHK_STATUS_L7OKCD,		\/* L7 check conditionally passed *\/$/;"	e	enum:__anon34
HCHK_STATUS_L7OKD	include/types/checks.h	/^	HCHK_STATUS_L7OKD,		\/* L7 check passed *\/$/;"	e	enum:__anon34
HCHK_STATUS_L7RSP	include/types/checks.h	/^	HCHK_STATUS_L7RSP,		\/* L7 invalid response - protocol error *\/$/;"	e	enum:__anon34
HCHK_STATUS_L7STS	include/types/checks.h	/^	HCHK_STATUS_L7STS,		\/* L7 response error, for example HTTP 5xx *\/$/;"	e	enum:__anon34
HCHK_STATUS_L7TOUT	include/types/checks.h	/^	HCHK_STATUS_L7TOUT,		\/* L7 (HTTP\/SMTP) timeout *\/$/;"	e	enum:__anon34
HCHK_STATUS_SIZE	include/types/checks.h	/^	HCHK_STATUS_SIZE$/;"	e	enum:__anon34
HCHK_STATUS_SOCKERR	include/types/checks.h	/^	HCHK_STATUS_SOCKERR,		\/* Socket error *\/$/;"	e	enum:__anon34
HCHK_STATUS_START	include/types/checks.h	/^	HCHK_STATUS_START,		\/* Check started - SPECIAL STATUS *\/$/;"	e	enum:__anon34
HCHK_STATUS_UNKNOWN	include/types/checks.h	/^	HCHK_STATUS_UNKNOWN	 = 0,	\/* Unknown *\/$/;"	e	enum:__anon34
HOUR	include/common/standard.h	539;"	d
HTTP_100	src/proto_http.c	/^const char HTTP_100[] =$/;"	v
HTTP_301	src/proto_http.c	/^const char *HTTP_301 =$/;"	v
HTTP_302	src/proto_http.c	/^const char *HTTP_302 =$/;"	v
HTTP_303	src/proto_http.c	/^const char *HTTP_303 =$/;"	v
HTTP_307	src/proto_http.c	/^const char *HTTP_307 =$/;"	v
HTTP_308	src/proto_http.c	/^const char *HTTP_308 =$/;"	v
HTTP_401_fmt	src/proto_http.c	/^const char *HTTP_401_fmt =$/;"	v
HTTP_407_fmt	src/proto_http.c	/^const char *HTTP_407_fmt =$/;"	v
HTTP_AUTH_BASIC	include/types/proto_http.h	/^	HTTP_AUTH_BASIC,$/;"	e	enum:ht_auth_m
HTTP_AUTH_DIGEST	include/types/proto_http.h	/^	HTTP_AUTH_DIGEST,$/;"	e	enum:ht_auth_m
HTTP_AUTH_UNKNOWN	include/types/proto_http.h	/^	HTTP_AUTH_UNKNOWN	= 0,$/;"	e	enum:ht_auth_m
HTTP_AUTH_WRONG	include/types/proto_http.h	/^	HTTP_AUTH_WRONG		= -1,		\/* missing or unknown *\/$/;"	e	enum:ht_auth_m
HTTP_ERR_200	include/types/proto_http.h	/^	HTTP_ERR_200 = 0,$/;"	e	enum:__anon62
HTTP_ERR_400	include/types/proto_http.h	/^	HTTP_ERR_400,$/;"	e	enum:__anon62
HTTP_ERR_403	include/types/proto_http.h	/^	HTTP_ERR_403,$/;"	e	enum:__anon62
HTTP_ERR_408	include/types/proto_http.h	/^	HTTP_ERR_408,$/;"	e	enum:__anon62
HTTP_ERR_500	include/types/proto_http.h	/^	HTTP_ERR_500,$/;"	e	enum:__anon62
HTTP_ERR_502	include/types/proto_http.h	/^	HTTP_ERR_502,$/;"	e	enum:__anon62
HTTP_ERR_503	include/types/proto_http.h	/^	HTTP_ERR_503,$/;"	e	enum:__anon62
HTTP_ERR_504	include/types/proto_http.h	/^	HTTP_ERR_504,$/;"	e	enum:__anon62
HTTP_ERR_SIZE	include/types/proto_http.h	/^	HTTP_ERR_SIZE$/;"	e	enum:__anon62
HTTP_IS_CRLF	include/proto/proto_http.h	62;"	d
HTTP_IS_CTL	include/proto/proto_http.h	58;"	d
HTTP_IS_LWS	include/proto/proto_http.h	60;"	d
HTTP_IS_SEP	include/proto/proto_http.h	59;"	d
HTTP_IS_SPHT	include/proto/proto_http.h	61;"	d
HTTP_IS_TOKEN	include/proto/proto_http.h	63;"	d
HTTP_IS_VER_TOKEN	include/proto/proto_http.h	64;"	d
HTTP_METH_CONNECT	include/types/proto_http.h	/^	HTTP_METH_CONNECT,$/;"	e	enum:http_meth_t
HTTP_METH_DELETE	include/types/proto_http.h	/^	HTTP_METH_DELETE,$/;"	e	enum:http_meth_t
HTTP_METH_GET	include/types/proto_http.h	/^	HTTP_METH_GET,$/;"	e	enum:http_meth_t
HTTP_METH_HEAD	include/types/proto_http.h	/^	HTTP_METH_HEAD,$/;"	e	enum:http_meth_t
HTTP_METH_NONE	include/types/proto_http.h	/^	HTTP_METH_NONE = 0,$/;"	e	enum:http_meth_t
HTTP_METH_OPTIONS	include/types/proto_http.h	/^	HTTP_METH_OPTIONS,$/;"	e	enum:http_meth_t
HTTP_METH_OTHER	include/types/proto_http.h	/^	HTTP_METH_OTHER, \/* Must be the last entry *\/$/;"	e	enum:http_meth_t
HTTP_METH_POST	include/types/proto_http.h	/^	HTTP_METH_POST,$/;"	e	enum:http_meth_t
HTTP_METH_PUT	include/types/proto_http.h	/^	HTTP_METH_PUT,$/;"	e	enum:http_meth_t
HTTP_METH_TRACE	include/types/proto_http.h	/^	HTTP_METH_TRACE,$/;"	e	enum:http_meth_t
HTTP_MSGF_CNT_LEN	include/types/proto_http.h	181;"	d
HTTP_MSGF_TE_CHNK	include/types/proto_http.h	182;"	d
HTTP_MSGF_VER_11	include/types/proto_http.h	189;"	d
HTTP_MSGF_WAIT_CONN	include/types/proto_http.h	195;"	d
HTTP_MSGF_XFER_LEN	include/types/proto_http.h	188;"	d
HTTP_MSG_100_SENT	include/types/proto_http.h	/^	HTTP_MSG_100_SENT     = 28, \/\/ parsing body after a 100-Continue was sent$/;"	e	enum:ht_state
HTTP_MSG_BODY	include/types/proto_http.h	/^	HTTP_MSG_BODY         = 27, \/\/ parsing body at end of headers$/;"	e	enum:ht_state
HTTP_MSG_CHUNK_CRLF	include/types/proto_http.h	/^	HTTP_MSG_CHUNK_CRLF   = 31, \/\/ skipping CRLF after data chunk$/;"	e	enum:ht_state
HTTP_MSG_CHUNK_SIZE	include/types/proto_http.h	/^	HTTP_MSG_CHUNK_SIZE   = 29, \/\/ parsing the chunk size (RFC2616 #3.6.1)$/;"	e	enum:ht_state
HTTP_MSG_CLOSED	include/types/proto_http.h	/^	HTTP_MSG_CLOSED       = 35, \/\/ shutdown_w done, all bytes sent$/;"	e	enum:ht_state
HTTP_MSG_CLOSING	include/types/proto_http.h	/^	HTTP_MSG_CLOSING      = 34, \/\/ shutdown_w done, not all bytes sent yet$/;"	e	enum:ht_state
HTTP_MSG_DATA	include/types/proto_http.h	/^	HTTP_MSG_DATA         = 30, \/\/ skipping data chunk \/ content-length data$/;"	e	enum:ht_state
HTTP_MSG_DONE	include/types/proto_http.h	/^	HTTP_MSG_DONE         = 33, \/\/ message end received, waiting for resync or close$/;"	e	enum:ht_state
HTTP_MSG_ERROR	include/types/proto_http.h	/^	HTTP_MSG_ERROR        = 26, \/\/ an error occurred$/;"	e	enum:ht_state
HTTP_MSG_HDR_COL	include/types/proto_http.h	/^	HTTP_MSG_HDR_COL      = 18, \/\/ parsing header colon$/;"	e	enum:ht_state
HTTP_MSG_HDR_FIRST	include/types/proto_http.h	/^	HTTP_MSG_HDR_FIRST    = 16, \/\/ waiting for first header or last CRLF (no LWS possible)$/;"	e	enum:ht_state
HTTP_MSG_HDR_L1_LF	include/types/proto_http.h	/^	HTTP_MSG_HDR_L1_LF    = 20, \/\/ parsing header LWS (LF) before value$/;"	e	enum:ht_state
HTTP_MSG_HDR_L1_LWS	include/types/proto_http.h	/^	HTTP_MSG_HDR_L1_LWS   = 21, \/\/ checking whether it's a new header or an LWS$/;"	e	enum:ht_state
HTTP_MSG_HDR_L1_SP	include/types/proto_http.h	/^	HTTP_MSG_HDR_L1_SP    = 19, \/\/ parsing header LWS (SP|HT) before value$/;"	e	enum:ht_state
HTTP_MSG_HDR_L2_LF	include/types/proto_http.h	/^	HTTP_MSG_HDR_L2_LF    = 23, \/\/ parsing header LWS (LF) inside\/after value$/;"	e	enum:ht_state
HTTP_MSG_HDR_L2_LWS	include/types/proto_http.h	/^	HTTP_MSG_HDR_L2_LWS   = 24, \/\/ checking whether it's a new header or an LWS$/;"	e	enum:ht_state
HTTP_MSG_HDR_NAME	include/types/proto_http.h	/^	HTTP_MSG_HDR_NAME     = 17, \/\/ parsing header name$/;"	e	enum:ht_state
HTTP_MSG_HDR_VAL	include/types/proto_http.h	/^	HTTP_MSG_HDR_VAL      = 22, \/\/ parsing header value$/;"	e	enum:ht_state
HTTP_MSG_LAST_LF	include/types/proto_http.h	/^	HTTP_MSG_LAST_LF      = 25, \/\/ parsing last LF$/;"	e	enum:ht_state
HTTP_MSG_RPBEFORE	include/types/proto_http.h	/^	HTTP_MSG_RPBEFORE     =  8, \/\/ response: leading LF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RPBEFORE_CR	include/types/proto_http.h	/^	HTTP_MSG_RPBEFORE_CR  =  9, \/\/ response: leading CRLF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RPCODE	include/types/proto_http.h	/^	HTTP_MSG_RPCODE       = 12, \/\/ response code$/;"	e	enum:ht_state
HTTP_MSG_RPCODE_SP	include/types/proto_http.h	/^	HTTP_MSG_RPCODE_SP    = 13, \/\/ space(s) after the response code$/;"	e	enum:ht_state
HTTP_MSG_RPLINE_END	include/types/proto_http.h	/^	HTTP_MSG_RPLINE_END   = 15, \/\/ end of response line (CR or LF)$/;"	e	enum:ht_state
HTTP_MSG_RPREASON	include/types/proto_http.h	/^	HTTP_MSG_RPREASON     = 14, \/\/ response reason$/;"	e	enum:ht_state
HTTP_MSG_RPVER	include/types/proto_http.h	/^	HTTP_MSG_RPVER        = 10, \/\/ parsing the Response Version$/;"	e	enum:ht_state
HTTP_MSG_RPVER_SP	include/types/proto_http.h	/^	HTTP_MSG_RPVER_SP     = 11, \/\/ space(s) after the Response Version$/;"	e	enum:ht_state
HTTP_MSG_RQBEFORE	include/types/proto_http.h	/^	HTTP_MSG_RQBEFORE     =  0, \/\/ request: leading LF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RQBEFORE_CR	include/types/proto_http.h	/^	HTTP_MSG_RQBEFORE_CR  =  1, \/\/ request: leading CRLF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RQLINE_END	include/types/proto_http.h	/^	HTTP_MSG_RQLINE_END   =  7, \/\/ end of request line (CR or LF)$/;"	e	enum:ht_state
HTTP_MSG_RQMETH	include/types/proto_http.h	/^	HTTP_MSG_RQMETH       =  2, \/\/ parsing the Method$/;"	e	enum:ht_state
HTTP_MSG_RQMETH_SP	include/types/proto_http.h	/^	HTTP_MSG_RQMETH_SP    =  3, \/\/ space(s) after the Method$/;"	e	enum:ht_state
HTTP_MSG_RQURI	include/types/proto_http.h	/^	HTTP_MSG_RQURI        =  4, \/\/ parsing the Request URI$/;"	e	enum:ht_state
HTTP_MSG_RQURI_SP	include/types/proto_http.h	/^	HTTP_MSG_RQURI_SP     =  5, \/\/ space(s) after the Request URI$/;"	e	enum:ht_state
HTTP_MSG_RQVER	include/types/proto_http.h	/^	HTTP_MSG_RQVER        =  6, \/\/ parsing the Request Version$/;"	e	enum:ht_state
HTTP_MSG_TRAILERS	include/types/proto_http.h	/^	HTTP_MSG_TRAILERS     = 32, \/\/ trailers (post-data entity headers)$/;"	e	enum:ht_state
HTTP_MSG_TUNNEL	include/types/proto_http.h	/^	HTTP_MSG_TUNNEL       = 36, \/\/ tunneled data after DONE$/;"	e	enum:ht_state
HTTP_REQ_ACT_ADD_ACL	include/types/proto_http.h	/^	HTTP_REQ_ACT_ADD_ACL,$/;"	e	enum:__anon60
HTTP_REQ_ACT_ADD_HDR	include/types/proto_http.h	/^	HTTP_REQ_ACT_ADD_HDR,$/;"	e	enum:__anon60
HTTP_REQ_ACT_ALLOW	include/types/proto_http.h	/^	HTTP_REQ_ACT_ALLOW,$/;"	e	enum:__anon60
HTTP_REQ_ACT_AUTH	include/types/proto_http.h	/^	HTTP_REQ_ACT_AUTH,$/;"	e	enum:__anon60
HTTP_REQ_ACT_CUSTOM_CONT	include/types/proto_http.h	/^	HTTP_REQ_ACT_CUSTOM_CONT,$/;"	e	enum:__anon60
HTTP_REQ_ACT_CUSTOM_STOP	include/types/proto_http.h	/^	HTTP_REQ_ACT_CUSTOM_STOP,$/;"	e	enum:__anon60
HTTP_REQ_ACT_DEL_ACL	include/types/proto_http.h	/^	HTTP_REQ_ACT_DEL_ACL,$/;"	e	enum:__anon60
HTTP_REQ_ACT_DEL_HDR	include/types/proto_http.h	/^	HTTP_REQ_ACT_DEL_HDR,$/;"	e	enum:__anon60
HTTP_REQ_ACT_DEL_MAP	include/types/proto_http.h	/^	HTTP_REQ_ACT_DEL_MAP,$/;"	e	enum:__anon60
HTTP_REQ_ACT_DENY	include/types/proto_http.h	/^	HTTP_REQ_ACT_DENY,$/;"	e	enum:__anon60
HTTP_REQ_ACT_MAX	include/types/proto_http.h	/^	HTTP_REQ_ACT_MAX \/* must always be last *\/$/;"	e	enum:__anon60
HTTP_REQ_ACT_REDIR	include/types/proto_http.h	/^	HTTP_REQ_ACT_REDIR,$/;"	e	enum:__anon60
HTTP_REQ_ACT_REPLACE_HDR	include/types/proto_http.h	/^	HTTP_REQ_ACT_REPLACE_HDR,$/;"	e	enum:__anon60
HTTP_REQ_ACT_REPLACE_VAL	include/types/proto_http.h	/^	HTTP_REQ_ACT_REPLACE_VAL,$/;"	e	enum:__anon60
HTTP_REQ_ACT_SET_HDR	include/types/proto_http.h	/^	HTTP_REQ_ACT_SET_HDR,$/;"	e	enum:__anon60
HTTP_REQ_ACT_SET_LOGL	include/types/proto_http.h	/^	HTTP_REQ_ACT_SET_LOGL,$/;"	e	enum:__anon60
HTTP_REQ_ACT_SET_MAP	include/types/proto_http.h	/^	HTTP_REQ_ACT_SET_MAP,$/;"	e	enum:__anon60
HTTP_REQ_ACT_SET_MARK	include/types/proto_http.h	/^	HTTP_REQ_ACT_SET_MARK,$/;"	e	enum:__anon60
HTTP_REQ_ACT_SET_NICE	include/types/proto_http.h	/^	HTTP_REQ_ACT_SET_NICE,$/;"	e	enum:__anon60
HTTP_REQ_ACT_SET_TOS	include/types/proto_http.h	/^	HTTP_REQ_ACT_SET_TOS,$/;"	e	enum:__anon60
HTTP_REQ_ACT_TARPIT	include/types/proto_http.h	/^	HTTP_REQ_ACT_TARPIT,$/;"	e	enum:__anon60
HTTP_REQ_ACT_UNKNOWN	include/types/proto_http.h	/^	HTTP_REQ_ACT_UNKNOWN = 0,$/;"	e	enum:__anon60
HTTP_RES_ACT_ADD_ACL	include/types/proto_http.h	/^	HTTP_RES_ACT_ADD_ACL,$/;"	e	enum:__anon61
HTTP_RES_ACT_ADD_HDR	include/types/proto_http.h	/^	HTTP_RES_ACT_ADD_HDR,$/;"	e	enum:__anon61
HTTP_RES_ACT_ALLOW	include/types/proto_http.h	/^	HTTP_RES_ACT_ALLOW,$/;"	e	enum:__anon61
HTTP_RES_ACT_CUSTOM_CONT	include/types/proto_http.h	/^	HTTP_RES_ACT_CUSTOM_CONT,  \/* used for module keywords *\/$/;"	e	enum:__anon61
HTTP_RES_ACT_CUSTOM_STOP	include/types/proto_http.h	/^	HTTP_RES_ACT_CUSTOM_STOP,  \/* used for module keywords *\/$/;"	e	enum:__anon61
HTTP_RES_ACT_DEL_ACL	include/types/proto_http.h	/^	HTTP_RES_ACT_DEL_ACL,$/;"	e	enum:__anon61
HTTP_RES_ACT_DEL_HDR	include/types/proto_http.h	/^	HTTP_RES_ACT_DEL_HDR,$/;"	e	enum:__anon61
HTTP_RES_ACT_DEL_MAP	include/types/proto_http.h	/^	HTTP_RES_ACT_DEL_MAP,$/;"	e	enum:__anon61
HTTP_RES_ACT_DENY	include/types/proto_http.h	/^	HTTP_RES_ACT_DENY,$/;"	e	enum:__anon61
HTTP_RES_ACT_MAX	include/types/proto_http.h	/^	HTTP_RES_ACT_MAX \/* must always be last *\/$/;"	e	enum:__anon61
HTTP_RES_ACT_REPLACE_HDR	include/types/proto_http.h	/^	HTTP_RES_ACT_REPLACE_HDR,$/;"	e	enum:__anon61
HTTP_RES_ACT_REPLACE_VAL	include/types/proto_http.h	/^	HTTP_RES_ACT_REPLACE_VAL,$/;"	e	enum:__anon61
HTTP_RES_ACT_SET_HDR	include/types/proto_http.h	/^	HTTP_RES_ACT_SET_HDR,$/;"	e	enum:__anon61
HTTP_RES_ACT_SET_LOGL	include/types/proto_http.h	/^	HTTP_RES_ACT_SET_LOGL,$/;"	e	enum:__anon61
HTTP_RES_ACT_SET_MAP	include/types/proto_http.h	/^	HTTP_RES_ACT_SET_MAP,$/;"	e	enum:__anon61
HTTP_RES_ACT_SET_MARK	include/types/proto_http.h	/^	HTTP_RES_ACT_SET_MARK,$/;"	e	enum:__anon61
HTTP_RES_ACT_SET_NICE	include/types/proto_http.h	/^	HTTP_RES_ACT_SET_NICE,$/;"	e	enum:__anon61
HTTP_RES_ACT_SET_TOS	include/types/proto_http.h	/^	HTTP_RES_ACT_SET_TOS,$/;"	e	enum:__anon61
HTTP_RES_ACT_UNKNOWN	include/types/proto_http.h	/^	HTTP_RES_ACT_UNKNOWN = 0,$/;"	e	enum:__anon61
HTTP_RULE_RES_ABRT	include/types/proto_http.h	/^	HTTP_RULE_RES_ABRT,      \/* abort request, msg already sent (eg: auth) *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_BADREQ	include/types/proto_http.h	/^	HTTP_RULE_RES_BADREQ,    \/* bad request *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_CONT	include/types/proto_http.h	/^	HTTP_RULE_RES_CONT = 0,  \/* nothing special, continue rules evaluation *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_DENY	include/types/proto_http.h	/^	HTTP_RULE_RES_DENY,      \/* deny (or tarpit if TX_CLTARPIT)  *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_DONE	include/types/proto_http.h	/^	HTTP_RULE_RES_DONE,      \/* processing done, stop processing (eg: redirect) *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_STOP	include/types/proto_http.h	/^	HTTP_RULE_RES_STOP,      \/* stopped processing on an accept *\/$/;"	e	enum:rule_result
HiLink	examples/haproxy.vim	/^	command -nargs=+ HiLink hi def link <args>$/;"	c
HiLink	examples/haproxy.vim	/^	command -nargs=+ HiLink hi link <args>$/;"	c
ILH	include/common/mini-clist.h	60;"	d
IN6_IS_ADDR_V4MAPPED	include/common/compat.h	134;"	d
INCLUDE	contrib/halog/Makefile	/^INCLUDE  = -I..\/..\/include -I$(EBTREE_DIR)$/;"	m
IPV6_TRANSPARENT	include/common/compat.h	99;"	d
IP_FREEBIND	include/common/compat.h	93;"	d
IP_ORIGADDRS	include/import/ip_tproxy.h	23;"	d
IP_RECVORIGADDRS	include/import/ip_tproxy.h	22;"	d
IP_TPROXY	include/import/ip_tproxy.h	38;"	d
IP_TRANSPARENT	include/common/compat.h	96;"	d
ITP_APPLIED	include/import/ip_tproxy.h	58;"	d
ITP_CONNECT	include/import/ip_tproxy.h	52;"	d
ITP_ESTABLISHED	include/import/ip_tproxy.h	54;"	d
ITP_LISTEN	include/import/ip_tproxy.h	53;"	d
ITP_MARK	include/import/ip_tproxy.h	57;"	d
ITP_ONCE	include/import/ip_tproxy.h	56;"	d
ITP_UNIDIR	include/import/ip_tproxy.h	59;"	d
KWM_DEF	src/cfgparse.c	/^	KWM_DEF,      \/* "default" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_NO	src/cfgparse.c	/^	KWM_NO,       \/* "no" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_STD	src/cfgparse.c	/^	KWM_STD = 0,  \/* normal *\/$/;"	e	enum:kw_mod	file:
LBOUND	include/common/standard.h	64;"	d
LB_MAP_RECALC	include/types/lb_map.h	29;"	d
LD	Makefile	/^LD = $(CC)$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $(ARCH_FLAGS) -g$/;"	m
LDFLAGS	contrib/ip6range/Makefile	/^LDFLAGS  = -s$/;"	m
LDFLAGS	contrib/iprange/Makefile	/^LDFLAGS  = -s$/;"	m
LDOPTS	Makefile	/^LDOPTS = $(TARGET_LDFLAGS) $(OPTIONS_LDFLAGS) $(ADDLIB)$/;"	m
LF_EDARG	include/types/log.h	/^	LF_EDARG,      \/\/ '}' after '%{'$/;"	e	enum:__anon102
LF_EDEXPR	include/types/log.h	/^	LF_EDEXPR,     \/\/ ']' after '%['$/;"	e	enum:__anon102
LF_END	include/types/log.h	/^	LF_END,        \/\/ \\0 found$/;"	e	enum:__anon102
LF_INIT	include/types/log.h	/^	LF_INIT = 0,   \/\/ before first character$/;"	e	enum:__anon102
LF_SEPARATOR	include/types/log.h	/^	LF_SEPARATOR,  \/\/ a single separator$/;"	e	enum:__anon102
LF_STARG	include/types/log.h	/^	LF_STARG,      \/\/ after '%{' and berore '}'$/;"	e	enum:__anon102
LF_STARTVAR	include/types/log.h	/^	LF_STARTVAR,   \/\/ % in text$/;"	e	enum:__anon102
LF_STEXPR	include/types/log.h	/^	LF_STEXPR,     \/\/ after '%[' or '%{..}[' and berore ']'$/;"	e	enum:__anon102
LF_TEXT	include/types/log.h	/^	LF_TEXT,       \/\/ normal text$/;"	e	enum:__anon102
LF_VAR	include/types/log.h	/^	LF_VAR,        \/\/ variable name, after '%' or '%{..}'$/;"	e	enum:__anon102
LIB_EBTREE	Makefile	/^LIB_EBTREE = $(EBTREE_DIR)\/libebtree.a$/;"	m
LIM2A	include/common/standard.h	/^static inline const char *LIM2A(unsigned long n, const char *alt)$/;"	f
LINESIZE	include/common/defaults.h	53;"	d
LISTEN_DEFAULT_CIPHERS	include/common/defaults.h	204;"	d
LIST_ADD	include/common/mini-clist.h	117;"	d
LIST_ADDQ	include/common/mini-clist.h	120;"	d
LIST_DEL	include/common/mini-clist.h	123;"	d
LIST_ELEM	include/common/mini-clist.h	130;"	d
LIST_HEAD	include/common/mini-clist.h	52;"	d
LIST_HEAD	include/common/mini-clist.h	62;"	d
LIST_HEAD_INIT	include/common/mini-clist.h	66;"	d
LIST_INIT	include/common/mini-clist.h	53;"	d
LIST_INIT	include/common/mini-clist.h	64;"	d
LIST_ISEMPTY	include/common/mini-clist.h	133;"	d
LIST_NEXT	include/common/mini-clist.h	140;"	d
LIST_NEXT	include/common/mini-clist.h	54;"	d
LIST_PREV	include/common/mini-clist.h	147;"	d
LI_ASSIGNED	include/types/listener.h	/^	LI_ASSIGNED,    \/* assigned to the protocol, but not listening yet *\/$/;"	e	enum:li_state
LI_FULL	include/types/listener.h	/^	LI_FULL,        \/* reached its connection limit *\/$/;"	e	enum:li_state
LI_INIT	include/types/listener.h	/^	LI_INIT,        \/* all parameters filled in, but not assigned yet *\/$/;"	e	enum:li_state
LI_LIMITED	include/types/listener.h	/^	LI_LIMITED,     \/* transient state: limits have been reached, listener is queued *\/$/;"	e	enum:li_state
LI_LISTEN	include/types/listener.h	/^	LI_LISTEN,      \/* started, listening but not enabled *\/$/;"	e	enum:li_state
LI_NEW	include/types/listener.h	/^	LI_NEW	= 0,    \/* not initialized yet *\/$/;"	e	enum:li_state
LI_O_ACC_PROXY	include/types/listener.h	90;"	d
LI_O_CHK_MONNET	include/types/listener.h	89;"	d
LI_O_DEF_ACCEPT	include/types/listener.h	87;"	d
LI_O_FOREIGN	include/types/listener.h	85;"	d
LI_O_NOLINGER	include/types/listener.h	84;"	d
LI_O_NONE	include/types/listener.h	83;"	d
LI_O_NOQUICKACK	include/types/listener.h	86;"	d
LI_O_TCP_FO	include/types/listener.h	92;"	d
LI_O_TCP_RULES	include/types/listener.h	88;"	d
LI_O_UNLIMITED	include/types/listener.h	91;"	d
LI_O_V4V6	include/types/listener.h	94;"	d
LI_O_V6ONLY	include/types/listener.h	93;"	d
LI_PAUSED	include/types/listener.h	/^	LI_PAUSED,      \/* listener was paused, it's bound but not listening  *\/$/;"	e	enum:li_state
LI_READY	include/types/listener.h	/^	LI_READY,       \/* started, listening and enabled *\/$/;"	e	enum:li_state
LLONG_MAX	include/common/standard.h	37;"	d
LLONG_MIN	include/common/standard.h	38;"	d
LOGCHAR	src/log.c	899;"	d	file:
LOG_FMT_ACTCONN	include/types/log.h	/^	LOG_FMT_ACTCONN,$/;"	e	enum:__anon101
LOG_FMT_BACKEND	include/types/log.h	/^	LOG_FMT_BACKEND,$/;"	e	enum:__anon101
LOG_FMT_BACKENDIP	include/types/log.h	/^	LOG_FMT_BACKENDIP,$/;"	e	enum:__anon101
LOG_FMT_BACKENDPORT	include/types/log.h	/^	LOG_FMT_BACKENDPORT,$/;"	e	enum:__anon101
LOG_FMT_BCKQUEUE	include/types/log.h	/^	LOG_FMT_BCKQUEUE,$/;"	e	enum:__anon101
LOG_FMT_BECONN	include/types/log.h	/^	LOG_FMT_BECONN,$/;"	e	enum:__anon101
LOG_FMT_BYTES	include/types/log.h	/^	LOG_FMT_BYTES,$/;"	e	enum:__anon101
LOG_FMT_BYTES_UP	include/types/log.h	/^	LOG_FMT_BYTES_UP,$/;"	e	enum:__anon101
LOG_FMT_CCLIENT	include/types/log.h	/^	LOG_FMT_CCLIENT,$/;"	e	enum:__anon101
LOG_FMT_CLIENTIP	include/types/log.h	/^	LOG_FMT_CLIENTIP,$/;"	e	enum:__anon101
LOG_FMT_CLIENTPORT	include/types/log.h	/^	LOG_FMT_CLIENTPORT,$/;"	e	enum:__anon101
LOG_FMT_CONN	include/types/log.h	/^	LOG_FMT_CONN,$/;"	e	enum:__anon101
LOG_FMT_COUNTER	include/types/log.h	/^	LOG_FMT_COUNTER,$/;"	e	enum:__anon101
LOG_FMT_CSERVER	include/types/log.h	/^	LOG_FMT_CSERVER,$/;"	e	enum:__anon101
LOG_FMT_DATE	include/types/log.h	/^	LOG_FMT_DATE,$/;"	e	enum:__anon101
LOG_FMT_DATEGMT	include/types/log.h	/^	LOG_FMT_DATEGMT,$/;"	e	enum:__anon101
LOG_FMT_DATELOCAL	include/types/log.h	/^	LOG_FMT_DATELOCAL,$/;"	e	enum:__anon101
LOG_FMT_EXPR	include/types/log.h	/^	LOG_FMT_EXPR,     \/* sample expression *\/$/;"	e	enum:__anon101
LOG_FMT_FECONN	include/types/log.h	/^	LOG_FMT_FECONN,$/;"	e	enum:__anon101
LOG_FMT_FRONTEND	include/types/log.h	/^	LOG_FMT_FRONTEND,$/;"	e	enum:__anon101
LOG_FMT_FRONTENDIP	include/types/log.h	/^	LOG_FMT_FRONTENDIP,$/;"	e	enum:__anon101
LOG_FMT_FRONTENDPORT	include/types/log.h	/^	LOG_FMT_FRONTENDPORT,$/;"	e	enum:__anon101
LOG_FMT_FRONTEND_XPRT	include/types/log.h	/^	LOG_FMT_FRONTEND_XPRT,$/;"	e	enum:__anon101
LOG_FMT_GLOBAL	include/types/log.h	/^	LOG_FMT_GLOBAL,$/;"	e	enum:__anon101
LOG_FMT_HDRREQUEST	include/types/log.h	/^	LOG_FMT_HDRREQUEST,$/;"	e	enum:__anon101
LOG_FMT_HDRREQUESTLIST	include/types/log.h	/^	LOG_FMT_HDRREQUESTLIST,$/;"	e	enum:__anon101
LOG_FMT_HDRRESPONS	include/types/log.h	/^	LOG_FMT_HDRRESPONS,$/;"	e	enum:__anon101
LOG_FMT_HDRRESPONSLIST	include/types/log.h	/^	LOG_FMT_HDRRESPONSLIST,$/;"	e	enum:__anon101
LOG_FMT_HOSTNAME	include/types/log.h	/^	LOG_FMT_HOSTNAME,$/;"	e	enum:__anon101
LOG_FMT_MS	include/types/log.h	/^	LOG_FMT_MS,$/;"	e	enum:__anon101
LOG_FMT_PID	include/types/log.h	/^	LOG_FMT_PID,$/;"	e	enum:__anon101
LOG_FMT_QUEUES	include/types/log.h	/^	LOG_FMT_QUEUES,$/;"	e	enum:__anon101
LOG_FMT_REQ	include/types/log.h	/^	LOG_FMT_REQ,$/;"	e	enum:__anon101
LOG_FMT_RETRIES	include/types/log.h	/^	LOG_FMT_RETRIES,$/;"	e	enum:__anon101
LOG_FMT_SEPARATOR	include/types/log.h	/^	LOG_FMT_SEPARATOR, \/* separator replaced by one space *\/$/;"	e	enum:__anon101
LOG_FMT_SERVER	include/types/log.h	/^	LOG_FMT_SERVER,$/;"	e	enum:__anon101
LOG_FMT_SERVERIP	include/types/log.h	/^	LOG_FMT_SERVERIP,$/;"	e	enum:__anon101
LOG_FMT_SERVERPORT	include/types/log.h	/^	LOG_FMT_SERVERPORT,$/;"	e	enum:__anon101
LOG_FMT_SRVCONN	include/types/log.h	/^	LOG_FMT_SRVCONN,$/;"	e	enum:__anon101
LOG_FMT_SRVQUEUE	include/types/log.h	/^	LOG_FMT_SRVQUEUE,$/;"	e	enum:__anon101
LOG_FMT_SSL_CIPHER	include/types/log.h	/^	LOG_FMT_SSL_CIPHER,$/;"	e	enum:__anon101
LOG_FMT_SSL_VERSION	include/types/log.h	/^	LOG_FMT_SSL_VERSION,$/;"	e	enum:__anon101
LOG_FMT_STATUS	include/types/log.h	/^	LOG_FMT_STATUS,$/;"	e	enum:__anon101
LOG_FMT_T	include/types/log.h	/^	LOG_FMT_T,$/;"	e	enum:__anon101
LOG_FMT_TC	include/types/log.h	/^	LOG_FMT_TC,$/;"	e	enum:__anon101
LOG_FMT_TERMSTATE	include/types/log.h	/^	LOG_FMT_TERMSTATE,$/;"	e	enum:__anon101
LOG_FMT_TERMSTATE_CK	include/types/log.h	/^	LOG_FMT_TERMSTATE_CK,$/;"	e	enum:__anon101
LOG_FMT_TEXT	include/types/log.h	/^	LOG_FMT_TEXT = 0, \/* raw text *\/$/;"	e	enum:__anon101
LOG_FMT_TQ	include/types/log.h	/^	LOG_FMT_TQ,$/;"	e	enum:__anon101
LOG_FMT_TR	include/types/log.h	/^	LOG_FMT_TR,$/;"	e	enum:__anon101
LOG_FMT_TS	include/types/log.h	/^	LOG_FMT_TS,$/;"	e	enum:__anon101
LOG_FMT_TT	include/types/log.h	/^	LOG_FMT_TT,$/;"	e	enum:__anon101
LOG_FMT_TW	include/types/log.h	/^	LOG_FMT_TW,$/;"	e	enum:__anon101
LOG_FMT_UNIQUEID	include/types/log.h	/^	LOG_FMT_UNIQUEID,$/;"	e	enum:__anon101
LOG_FMT_VARIABLE	include/types/log.h	/^	LOG_FMT_VARIABLE,$/;"	e	enum:__anon101
LOG_OPT_HEXA	include/types/log.h	123;"	d
LOG_OPT_HTTP	include/types/log.h	128;"	d
LOG_OPT_MANDATORY	include/types/log.h	124;"	d
LOG_OPT_QUOTE	include/types/log.h	125;"	d
LOG_OPT_REQ_CAP	include/types/log.h	126;"	d
LOG_OPT_RES_CAP	include/types/log.h	127;"	d
LONGBITS	include/common/standard.h	46;"	d
LSTCHK_CAP_BIND	include/types/global.h	48;"	d
LSTCHK_CTTPROXY	include/types/global.h	49;"	d
LSTCHK_NETADM	include/types/global.h	50;"	d
LW_BCKIP	include/types/log.h	146;"	d
LW_BYTES	include/types/log.h	142;"	d
LW_CLIP	include/types/log.h	137;"	d
LW_COOKIE	include/types/log.h	143;"	d
LW_FRTIP	include/types/log.h	147;"	d
LW_INIT	include/types/log.h	136;"	d
LW_REQ	include/types/log.h	140;"	d
LW_REQHDR	include/types/log.h	144;"	d
LW_RESP	include/types/log.h	141;"	d
LW_RSPHDR	include/types/log.h	145;"	d
LW_SVID	include/types/log.h	139;"	d
LW_SVIP	include/types/log.h	138;"	d
LW_XPRT	include/types/log.h	148;"	d
MALLOC	include/common/config.h	47;"	d
MALLOC	include/common/config.h	49;"	d
MANDIR	Makefile	/^MANDIR = $(PREFIX)\/share\/man$/;"	m
MAX	include/common/tools.h	33;"	d
MAXLINE	contrib/halog/halog.c	39;"	d	file:
MAXLINE	contrib/ip6range/ip6range.c	27;"	d	file:
MAXLINE	contrib/iprange/iprange.c	27;"	d	file:
MAXLINE	tests/ip-hash.c	17;"	d	file:
MAXLINE	tests/uri_hash.c	6;"	d	file:
MAXPATHLEN	include/common/compat.h	76;"	d
MAXREWRITE	include/common/defaults.h	40;"	d
MAX_DELAY_MS	include/common/time.h	45;"	d
MAX_HDR_HISTORY	include/common/defaults.h	74;"	d
MAX_HOSTNAME_LEN	include/common/defaults.h	189;"	d
MAX_HTTP_HDR	include/common/defaults.h	69;"	d
MAX_LINE_ARGS	include/common/defaults.h	57;"	d
MAX_MATCH	include/common/defaults.h	64;"	d
MAX_POLLERS	include/types/fd.h	125;"	d
MAX_POLL_EVENTS	include/common/defaults.h	106;"	d
MAX_RANGE	include/common/tools.h	42;"	d
MAX_READ_POLL_LOOPS	include/common/defaults.h	85;"	d
MAX_SESS_STKCTR	include/common/defaults.h	79;"	d
MAX_SIGNAL	include/common/defaults.h	184;"	d
MAX_SPLICE_AT_ONCE	src/raw_sock.c	55;"	d	file:
MAX_START_RETRIES	src/haproxy.c	179;"	d	file:
MAX_STATS_ARGS	include/common/defaults.h	61;"	d
MAX_SYSLOG_LEN	include/types/log.h	31;"	d
MEM_F_SHARED	include/common/memory.h	117;"	d
METH_FIELD	contrib/halog/halog.c	37;"	d	file:
MID_RANGE	include/common/tools.h	39;"	d
MIN	include/common/tools.h	29;"	d
MINTIME	include/common/time.h	49;"	d
MINUTE	include/common/standard.h	538;"	d
MIN_RECV_AT_ONCE_ENOUGH	include/common/defaults.h	94;"	d
MIN_SPLICE_FORWARD	include/common/defaults.h	100;"	d
MODE_CHECK	include/types/global.h	41;"	d
MODE_DAEMON	include/types/global.h	39;"	d
MODE_DEBUG	include/types/global.h	38;"	d
MODE_FOREGROUND	include/types/global.h	44;"	d
MODE_QUIET	include/types/global.h	40;"	d
MODE_STARTING	include/types/global.h	43;"	d
MODE_SYSTEMD	include/types/global.h	45;"	d
MODE_VERBOSE	include/types/global.h	42;"	d
MSG_DONTWAIT	include/common/compat.h	59;"	d
MSG_MORE	include/common/compat.h	64;"	d
MSG_NOSIGNAL	include/common/compat.h	52;"	d
MSG_TRUNC_CLEARS_INPUT	include/common/compat.h	71;"	d
MS_TO_TICKS	include/common/ticks.h	63;"	d
MyPackage	examples/check	/^package MyPackage;$/;"	p
NB_ITOA_STR	include/common/standard.h	53;"	d
NB_LLMAX_STR	include/common/standard.h	50;"	d
NB_LOG_FACILITIES	include/types/log.h	32;"	d
NB_LOG_LEVELS	include/types/log.h	33;"	d
NB_QSTR	include/common/standard.h	57;"	d
NSERV	tests/ip-hash.c	16;"	d	file:
NSERV	tests/uri_hash.c	5;"	d	file:
OBJS	Makefile	/^OBJS = src\/haproxy.o src\/sessionhash.o src\/base64.o src\/protocol.o \\$/;"	m
OBJS	contrib/halog/Makefile	/^OBJS     = halog$/;"	m
OBJS	contrib/ip6range/Makefile	/^OBJS     = ip6range$/;"	m
OBJS	contrib/iprange/Makefile	/^OBJS     = iprange$/;"	m
OBJ_TYPE_APPCTX	include/types/obj_type.h	/^	OBJ_TYPE_APPCTX,       \/* object is a struct appctx *\/$/;"	e	enum:obj_type
OBJ_TYPE_APPLET	include/types/obj_type.h	/^	OBJ_TYPE_APPLET,       \/* object is a struct si_applet *\/$/;"	e	enum:obj_type
OBJ_TYPE_CONN	include/types/obj_type.h	/^	OBJ_TYPE_CONN,         \/* object is a struct connection *\/$/;"	e	enum:obj_type
OBJ_TYPE_ENTRIES	include/types/obj_type.h	/^	OBJ_TYPE_ENTRIES       \/* last one : number of entries *\/$/;"	e	enum:obj_type
OBJ_TYPE_LISTENER	include/types/obj_type.h	/^	OBJ_TYPE_LISTENER,     \/* object is a struct listener *\/$/;"	e	enum:obj_type
OBJ_TYPE_NONE	include/types/obj_type.h	/^	OBJ_TYPE_NONE = 0,     \/* pointer is NULL by definition *\/$/;"	e	enum:obj_type
OBJ_TYPE_PROXY	include/types/obj_type.h	/^	OBJ_TYPE_PROXY,        \/* object is a struct proxy *\/$/;"	e	enum:obj_type
OBJ_TYPE_SERVER	include/types/obj_type.h	/^	OBJ_TYPE_SERVER,       \/* object is a struct server *\/$/;"	e	enum:obj_type
OCSP_MAX_CERTID_ASN1_LENGTH	include/common/defaults.h	235;"	d
OCSP_MAX_RESPONSE_TIME_SKEW	include/common/defaults.h	239;"	d
OID_HAPROXY	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY => '1.3.6.1.4.1.29385.106';$/;"	c
OID_HAPROXY_INFO	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_INFO => OID_HAPROXY . '.2';$/;"	c
OID_HAPROXY_STATS	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_STATS => OID_HAPROXY . '.1';$/;"	c
OPTIMIZE	contrib/halog/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIMIZE	contrib/ip6range/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIMIZE	contrib/iprange/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIONS_CFLAGS	Makefile	/^OPTIONS_CFLAGS  =$/;"	m
OPTIONS_LDFLAGS	Makefile	/^OPTIONS_LDFLAGS =$/;"	m
OPTIONS_OBJS	Makefile	/^OPTIONS_OBJS    =$/;"	m
PAT_MATCH	include/types/pattern.h	/^	PAT_MATCH = 3,           \/* sample matched at least one pattern *\/$/;"	e	enum:pat_match_res
PAT_MATCH_BEG	include/types/pattern.h	/^	PAT_MATCH_BEG,   \/* beginning of string (str) *\/$/;"	e	enum:__anon9
PAT_MATCH_BIN	include/types/pattern.h	/^	PAT_MATCH_BIN,   \/* hex string (bin) *\/$/;"	e	enum:__anon9
PAT_MATCH_BOOL	include/types/pattern.h	/^	PAT_MATCH_BOOL,  \/* match fetch's integer value as boolean *\/$/;"	e	enum:__anon9
PAT_MATCH_DIR	include/types/pattern.h	/^	PAT_MATCH_DIR,   \/* directory-like sub-string (str) *\/$/;"	e	enum:__anon9
PAT_MATCH_DOM	include/types/pattern.h	/^	PAT_MATCH_DOM,   \/* domain-like sub-string (str) *\/$/;"	e	enum:__anon9
PAT_MATCH_END	include/types/pattern.h	/^	PAT_MATCH_END,   \/* end of string (str) *\/$/;"	e	enum:__anon9
PAT_MATCH_FOUND	include/types/pattern.h	/^	PAT_MATCH_FOUND, \/* just ensure that fetch found the sample *\/$/;"	e	enum:__anon9
PAT_MATCH_INT	include/types/pattern.h	/^	PAT_MATCH_INT,   \/* unsigned integer (int) *\/$/;"	e	enum:__anon9
PAT_MATCH_IP	include/types/pattern.h	/^	PAT_MATCH_IP,    \/* IPv4\/IPv6 address (IP) *\/$/;"	e	enum:__anon9
PAT_MATCH_LEN	include/types/pattern.h	/^	PAT_MATCH_LEN,   \/* string length (str -> int) *\/$/;"	e	enum:__anon9
PAT_MATCH_NUM	include/types/pattern.h	/^	PAT_MATCH_NUM$/;"	e	enum:__anon9
PAT_MATCH_REG	include/types/pattern.h	/^	PAT_MATCH_REG,   \/* regex (str -> reg) *\/$/;"	e	enum:__anon9
PAT_MATCH_STR	include/types/pattern.h	/^	PAT_MATCH_STR,   \/* exact string match (str) *\/$/;"	e	enum:__anon9
PAT_MATCH_SUB	include/types/pattern.h	/^	PAT_MATCH_SUB,   \/* substring (str) *\/$/;"	e	enum:__anon9
PAT_MF_IGNORE_CASE	include/types/pattern.h	/^	PAT_MF_IGNORE_CASE = 1 << 0,       \/* ignore case *\/$/;"	e	enum:__anon7
PAT_MF_NO_DNS	include/types/pattern.h	/^	PAT_MF_NO_DNS      = 1 << 1,       \/* dont perform any DNS requests *\/$/;"	e	enum:__anon7
PAT_NOMATCH	include/types/pattern.h	/^	PAT_NOMATCH = 0,         \/* sample didn't match any pattern *\/$/;"	e	enum:pat_match_res
PAT_REF_ACL	include/types/pattern.h	95;"	d
PAT_REF_MAP	include/types/pattern.h	94;"	d
PAT_REF_SMP	include/types/pattern.h	96;"	d
PAT_SF_TREE	include/types/pattern.h	/^	PAT_SF_TREE        = 1 << 0,       \/* some patterns are arranged in a tree *\/$/;"	e	enum:__anon8
PCREDIR	Makefile	/^PCREDIR	        := $(shell pcre-config --prefix 2>\/dev\/null || echo \/usr\/local)$/;"	m
PCRE_INC	Makefile	/^PCRE_INC        := $(PCREDIR)\/include$/;"	m
PCRE_LIB	Makefile	/^PCRE_LIB        := $(PCREDIR)\/lib$/;"	m
PEER_F_LEARN_ASSIGN	src/peers.c	74;"	d	file:
PEER_F_LEARN_NOTUP2DATE	src/peers.c	75;"	d	file:
PEER_F_TEACH_COMPLETE	src/peers.c	73;"	d	file:
PEER_F_TEACH_FINISHED	src/peers.c	72;"	d	file:
PEER_F_TEACH_PROCESS	src/peers.c	69;"	d	file:
PEER_F_TEACH_STAGE1	src/peers.c	70;"	d	file:
PEER_F_TEACH_STAGE2	src/peers.c	71;"	d	file:
PEER_LEARN_RESET	src/peers.c	78;"	d	file:
PEER_SESSION_PROTO_NAME	src/peers.c	119;"	d	file:
PEER_SESS_SC_CONNECTCODE	src/peers.c	104;"	d	file:
PEER_SESS_SC_CONNECTEDCODE	src/peers.c	105;"	d	file:
PEER_SESS_SC_ERRHOST	src/peers.c	113;"	d	file:
PEER_SESS_SC_ERRPEER	src/peers.c	114;"	d	file:
PEER_SESS_SC_ERRPROTO	src/peers.c	111;"	d	file:
PEER_SESS_SC_ERRSIZE	src/peers.c	116;"	d	file:
PEER_SESS_SC_ERRTABLE	src/peers.c	117;"	d	file:
PEER_SESS_SC_ERRTYPE	src/peers.c	115;"	d	file:
PEER_SESS_SC_ERRVERSION	src/peers.c	112;"	d	file:
PEER_SESS_SC_SUCCESSCODE	src/peers.c	107;"	d	file:
PEER_SESS_SC_TRYAGAIN	src/peers.c	109;"	d	file:
PEER_SESS_ST_ACCEPT	src/peers.c	/^	PEER_SESS_ST_ACCEPT = 0,     \/* Initial state for session create by an accept, must be zero! *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_CONNECT	src/peers.c	/^	PEER_SESS_ST_CONNECT,        \/* Initial state for session create on a connect, push presentation into buffer *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_END	src/peers.c	/^	PEER_SESS_ST_END,            \/* Killed session *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_EXIT	src/peers.c	/^	PEER_SESS_ST_EXIT,           \/* Exit with status code *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_GETHOST	src/peers.c	/^	PEER_SESS_ST_GETHOST,        \/* Validate host ID correspond to local host id *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_GETPEER	src/peers.c	/^	PEER_SESS_ST_GETPEER,        \/* Validate peer ID correspond to a known remote peer id *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_GETSTATUS	src/peers.c	/^	PEER_SESS_ST_GETSTATUS,      \/* Wait for the welcome message *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_GETTABLE	src/peers.c	/^	PEER_SESS_ST_GETTABLE,       \/* Search into registered table for a table with same id and validate type and size *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_GETVERSION	src/peers.c	/^	PEER_SESS_ST_GETVERSION,     \/* Validate supported protocol version *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_SENDSUCCESS	src/peers.c	/^	PEER_SESS_ST_SENDSUCCESS,    \/* Send ret code 200 (success) and wait for message *\/$/;"	e	enum:__anon113	file:
PEER_SESS_ST_WAITMSG	src/peers.c	/^	PEER_SESS_ST_WAITMSG,        \/* Wait for data messages *\/$/;"	e	enum:__anon113	file:
PEER_TEACH_RESET	src/peers.c	77;"	d	file:
PERSIST_TYPE_FORCE	include/types/proto_http.h	/^	PERSIST_TYPE_FORCE,             \/* force-persist *\/$/;"	e	enum:__anon59
PERSIST_TYPE_IGNORE	include/types/proto_http.h	/^	PERSIST_TYPE_IGNORE,            \/* ignore-persist *\/$/;"	e	enum:__anon59
PERSIST_TYPE_NONE	include/types/proto_http.h	/^	PERSIST_TYPE_NONE = 0,          \/* no persistence *\/$/;"	e	enum:__anon59
PE_ARG_INVC	include/common/errors.h	/^	PE_ARG_INVC,      \/* invalid char in argument (pointer not provided) *\/$/;"	e	enum:__anon105
PE_ARG_INVC_PTR	include/common/errors.h	/^	PE_ARG_INVC_PTR,  \/* invalid char in argument (pointer provided) *\/$/;"	e	enum:__anon105
PE_ARG_MISSING	include/common/errors.h	/^	PE_ARG_MISSING,   \/* mandatory argument not provided *\/$/;"	e	enum:__anon105
PE_ARG_NOT_FOUND	include/common/errors.h	/^	PE_ARG_NOT_FOUND, \/* argument references something not found *\/$/;"	e	enum:__anon105
PE_ARG_NOT_USED	include/common/errors.h	/^	PE_ARG_NOT_USED,  \/* argument provided cannot be used *\/$/;"	e	enum:__anon105
PE_ENUM_OOR	include/common/errors.h	/^	PE_ENUM_OOR,      \/* enum data out of allowed range *\/$/;"	e	enum:__anon105
PE_EXIST	include/common/errors.h	/^	PE_EXIST,         \/* trying to create something which already exists *\/$/;"	e	enum:__anon105
PE_NONE	include/common/errors.h	/^	PE_NONE = 0,      \/* no error *\/$/;"	e	enum:__anon105
POWEROF2	include/common/standard.h	68;"	d
PP2_ADDR_LEN_INET	include/types/connection.h	296;"	d
PP2_ADDR_LEN_INET6	include/types/connection.h	297;"	d
PP2_ADDR_LEN_UNIX	include/types/connection.h	298;"	d
PP2_ADDR_LEN_UNSPEC	include/types/connection.h	295;"	d
PP2_CLIENT_CERT	include/types/connection.h	349;"	d
PP2_CLIENT_SSL	include/types/connection.h	348;"	d
PP2_CMD_LOCAL	include/types/connection.h	276;"	d
PP2_CMD_MASK	include/types/connection.h	278;"	d
PP2_CMD_PROXY	include/types/connection.h	277;"	d
PP2_FAM_INET	include/types/connection.h	290;"	d
PP2_FAM_INET6	include/types/connection.h	291;"	d
PP2_FAM_MASK	include/types/connection.h	293;"	d
PP2_FAM_UNIX	include/types/connection.h	292;"	d
PP2_FAM_UNSPEC	include/types/connection.h	289;"	d
PP2_HDR_LEN_INET	include/types/connection.h	301;"	d
PP2_HDR_LEN_INET6	include/types/connection.h	302;"	d
PP2_HDR_LEN_UNIX	include/types/connection.h	303;"	d
PP2_HDR_LEN_UNSPEC	include/types/connection.h	300;"	d
PP2_HEADER_LEN	include/types/connection.h	273;"	d
PP2_SIGNATURE	include/types/connection.h	271;"	d
PP2_SIGNATURE_LEN	include/types/connection.h	272;"	d
PP2_TRANS_DGRAM	include/types/connection.h	286;"	d
PP2_TRANS_MASK	include/types/connection.h	287;"	d
PP2_TRANS_STREAM	include/types/connection.h	285;"	d
PP2_TRANS_UNSPEC	include/types/connection.h	284;"	d
PP2_TYPE_SSL	include/types/connection.h	330;"	d
PP2_TYPE_SSL_CN	include/types/connection.h	332;"	d
PP2_TYPE_SSL_VERSION	include/types/connection.h	331;"	d
PP2_VERSION	include/types/connection.h	280;"	d
PP2_VERSION_MASK	include/types/connection.h	281;"	d
PREFIX	Makefile	/^PREFIX = \/usr\/local$/;"	m
PREFIX	contrib/systemd/Makefile	/^PREFIX = \/usr\/local$/;"	m
PRODUCT_BRANCH	include/common/version.h	34;"	d
PRODUCT_BRANCH	include/common/version.h	36;"	d
PRODUCT_NAME	include/common/version.h	28;"	d
PRODUCT_NAME	include/common/version.h	30;"	d
PRODUCT_URL	include/common/version.h	40;"	d
PRODUCT_URL	include/common/version.h	42;"	d
PRODUCT_URL_DOC	include/common/version.h	52;"	d
PRODUCT_URL_DOC	include/common/version.h	54;"	d
PRODUCT_URL_UPD	include/common/version.h	46;"	d
PRODUCT_URL_UPD	include/common/version.h	48;"	d
PROTO_NAME_LEN	include/types/protocol.h	37;"	d
PR_CAP_BE	include/types/proxy.h	73;"	d
PR_CAP_FE	include/types/proxy.h	72;"	d
PR_CAP_LISTEN	include/types/proxy.h	75;"	d
PR_CAP_NONE	include/types/proxy.h	71;"	d
PR_CAP_RS	include/types/proxy.h	74;"	d
PR_CK_ANY	include/types/proxy.h	176;"	d
PR_CK_HTTPONLY	include/types/proxy.h	180;"	d
PR_CK_IND	include/types/proxy.h	173;"	d
PR_CK_INS	include/types/proxy.h	174;"	d
PR_CK_NOC	include/types/proxy.h	177;"	d
PR_CK_PFX	include/types/proxy.h	175;"	d
PR_CK_POST	include/types/proxy.h	178;"	d
PR_CK_PSV	include/types/proxy.h	179;"	d
PR_CK_RW	include/types/proxy.h	172;"	d
PR_CK_SECURE	include/types/proxy.h	181;"	d
PR_MODE_HEALTH	include/types/proxy.h	/^	PR_MODE_HEALTH,$/;"	e	enum:pr_mode
PR_MODE_HTTP	include/types/proxy.h	/^	PR_MODE_HTTP,$/;"	e	enum:pr_mode
PR_MODE_TCP	include/types/proxy.h	/^	PR_MODE_TCP = 0,$/;"	e	enum:pr_mode
PR_O2_AS_M_ANY	include/types/proxy.h	138;"	d
PR_O2_AS_M_PP	include/types/proxy.h	136;"	d
PR_O2_AS_M_QS	include/types/proxy.h	137;"	d
PR_O2_AS_PFX	include/types/proxy.h	133;"	d
PR_O2_AS_REQL	include/types/proxy.h	132;"	d
PR_O2_CHK_ANY	include/types/proxy.h	168;"	d
PR_O2_CHK_NONE	include/types/proxy.h	157;"	d
PR_O2_CHK_SNDST	include/types/proxy.h	141;"	d
PR_O2_CLFLOG	include/types/proxy.h	126;"	d
PR_O2_EXP_INV	include/types/proxy.h	153;"	d
PR_O2_EXP_NONE	include/types/proxy.h	147;"	d
PR_O2_EXP_RSTR	include/types/proxy.h	151;"	d
PR_O2_EXP_RSTS	include/types/proxy.h	149;"	d
PR_O2_EXP_STR	include/types/proxy.h	150;"	d
PR_O2_EXP_STS	include/types/proxy.h	148;"	d
PR_O2_EXP_TYPE	include/types/proxy.h	152;"	d
PR_O2_FAKE_KA	include/types/proxy.h	145;"	d
PR_O2_HTTP_CHK	include/types/proxy.h	161;"	d
PR_O2_INDEPSTR	include/types/proxy.h	128;"	d
PR_O2_LB_AGENT_CHK	include/types/proxy.h	165;"	d
PR_O2_LDAP_CHK	include/types/proxy.h	163;"	d
PR_O2_LOGERRORS	include/types/proxy.h	122;"	d
PR_O2_LOGHCHKS	include/types/proxy.h	127;"	d
PR_O2_MYSQL_CHK	include/types/proxy.h	162;"	d
PR_O2_NODELAY	include/types/proxy.h	139;"	d
PR_O2_NOLOGNORM	include/types/proxy.h	121;"	d
PR_O2_PGSQL_CHK	include/types/proxy.h	158;"	d
PR_O2_RDPC_PRST	include/types/proxy.h	125;"	d
PR_O2_REDIS_CHK	include/types/proxy.h	159;"	d
PR_O2_REQBUG_OK	include/types/proxy.h	119;"	d
PR_O2_RSPBUG_OK	include/types/proxy.h	120;"	d
PR_O2_SMARTACC	include/types/proxy.h	123;"	d
PR_O2_SMARTCON	include/types/proxy.h	124;"	d
PR_O2_SMTP_CHK	include/types/proxy.h	160;"	d
PR_O2_SOCKSTAT	include/types/proxy.h	129;"	d
PR_O2_SPLIC_ANY	include/types/proxy.h	118;"	d
PR_O2_SPLIC_AUT	include/types/proxy.h	117;"	d
PR_O2_SPLIC_REQ	include/types/proxy.h	115;"	d
PR_O2_SPLIC_RTR	include/types/proxy.h	116;"	d
PR_O2_SRC_ADDR	include/types/proxy.h	143;"	d
PR_O2_SSL3_CHK	include/types/proxy.h	164;"	d
PR_O2_TCPCHK_CHK	include/types/proxy.h	166;"	d
PR_O2_USE_PXHDR	include/types/proxy.h	140;"	d
PR_O_ABRT_CLOSE	include/types/proxy.h	98;"	d
PR_O_CHK_CACHE	include/types/proxy.h	92;"	d
PR_O_CONTSTATS	include/types/proxy.h	109;"	d
PR_O_DISABLE404	include/types/proxy.h	111;"	d
PR_O_DISPATCH	include/types/proxy.h	82;"	d
PR_O_FF_ALWAYS	include/types/proxy.h	88;"	d
PR_O_FWDFOR	include/types/proxy.h	84;"	d
PR_O_HTTP_FCL	include/types/proxy.h	103;"	d
PR_O_HTTP_KAL	include/types/proxy.h	101;"	d
PR_O_HTTP_MODE	include/types/proxy.h	107;"	d
PR_O_HTTP_PCL	include/types/proxy.h	102;"	d
PR_O_HTTP_PROXY	include/types/proxy.h	110;"	d
PR_O_HTTP_SCL	include/types/proxy.h	104;"	d
PR_O_HTTP_TUN	include/types/proxy.h	105;"	d
PR_O_LOGASAP	include/types/proxy.h	90;"	d
PR_O_NULLNOLOG	include/types/proxy.h	86;"	d
PR_O_ORGTO	include/types/proxy.h	112;"	d
PR_O_PERSIST	include/types/proxy.h	89;"	d
PR_O_PREF_LAST	include/types/proxy.h	81;"	d
PR_O_REDISP	include/types/proxy.h	78;"	d
PR_O_TCPCHK_SSL	include/types/proxy.h	108;"	d
PR_O_TCP_CLI_KA	include/types/proxy.h	93;"	d
PR_O_TCP_NOLING	include/types/proxy.h	97;"	d
PR_O_TCP_SRV_KA	include/types/proxy.h	94;"	d
PR_O_TRANSP	include/types/proxy.h	79;"	d
PR_O_USE_ALL_BK	include/types/proxy.h	95;"	d
PR_STERROR	include/types/proxy.h	/^	PR_STERROR,             \/* proxy experienced an unrecoverable error *\/$/;"	e	enum:pr_state
PR_STFULL	include/types/proxy.h	/^	PR_STFULL,              \/* frontend is full (maxconn reached) *\/$/;"	e	enum:pr_state
PR_STNEW	include/types/proxy.h	/^	PR_STNEW = 0,           \/* proxy has not been initialized yet *\/$/;"	e	enum:pr_state
PR_STPAUSED	include/types/proxy.h	/^	PR_STPAUSED,            \/* frontend is paused (during hot restart) *\/$/;"	e	enum:pr_state
PR_STREADY	include/types/proxy.h	/^	PR_STREADY,             \/* proxy has been initialized and is ready *\/$/;"	e	enum:pr_state
PR_STSTOPPED	include/types/proxy.h	/^	PR_STSTOPPED,           \/* proxy is stopped (end of a restart) *\/$/;"	e	enum:pr_state
PTR_INT_TYPE	ebtree/ebpttree.h	37;"	d
QBITS	contrib/halog/halog.c	40;"	d	file:
QSTR_SIZE	include/common/standard.h	56;"	d
QUEUE_LEN_FIELD	contrib/halog/halog.c	36;"	d	file:
RB_BLACK	include/common/rbtree.h	107;"	d
RB_RED	include/common/rbtree.h	106;"	d
RB_ROOT	include/common/rbtree.h	124;"	d
REDIRECT_FLAG_APPEND_SLASH	include/types/proto_http.h	/^	REDIRECT_FLAG_APPEND_SLASH = 2,	\/* append a slash if missing at the end *\/$/;"	e	enum:__anon57
REDIRECT_FLAG_DROP_QS	include/types/proto_http.h	/^	REDIRECT_FLAG_DROP_QS = 1,	\/* drop query string *\/$/;"	e	enum:__anon57
REDIRECT_FLAG_NONE	include/types/proto_http.h	/^	REDIRECT_FLAG_NONE = 0,$/;"	e	enum:__anon57
REDIRECT_TYPE_LOCATION	include/types/proto_http.h	/^	REDIRECT_TYPE_LOCATION,         \/* location redirect *\/$/;"	e	enum:__anon58
REDIRECT_TYPE_NONE	include/types/proto_http.h	/^	REDIRECT_TYPE_NONE = 0,         \/* no redirection *\/$/;"	e	enum:__anon58
REDIRECT_TYPE_PREFIX	include/types/proto_http.h	/^	REDIRECT_TYPE_PREFIX,           \/* prefix redirect *\/$/;"	e	enum:__anon58
REDIRECT_TYPE_SCHEME	include/types/proto_http.h	/^	REDIRECT_TYPE_SCHEME,           \/* scheme redirect (eg: switch from http to https) *\/$/;"	e	enum:__anon58
REEXEC_FLAG	src/haproxy-systemd-wrapper.c	21;"	d	file:
REGEX	Makefile	/^REGEX = libc$/;"	m
REGPRM1	include/common/compiler.h	46;"	d
REGPRM1	include/common/compiler.h	48;"	d
REGPRM2	include/common/compiler.h	54;"	d
REGPRM2	include/common/compiler.h	56;"	d
REGPRM3	include/common/compiler.h	62;"	d
REGPRM3	include/common/compiler.h	64;"	d
REQURI_LEN	include/common/defaults.h	44;"	d
SBINDIR	Makefile	/^SBINDIR = $(PREFIX)\/sbin$/;"	m
SBINDIR	contrib/systemd/Makefile	/^SBINDIR = $(PREFIX)\/sbin$/;"	m
SCHEDULER_RESOLUTION	include/common/config.h	33;"	d
SCH_HTTP	include/common/standard.h	/^	SCH_HTTP,$/;"	e	enum:http_scheme
SCH_HTTPS	include/common/standard.h	/^	SCH_HTTPS,$/;"	e	enum:http_scheme
SD_DEBUG	src/haproxy-systemd-wrapper.c	22;"	d	file:
SD_NOTICE	src/haproxy-systemd-wrapper.c	23;"	d	file:
SEC	include/common/standard.h	537;"	d
SEP	contrib/halog/halog.c	42;"	d	file:
SERVER_FIELD	contrib/halog/halog.c	30;"	d	file:
SESSION_HASH_H	include/common/sessionhash.h	2;"	d
SETNOW	include/common/time.h	50;"	d
SHCTX_APPNAME	include/proto/shctx.h	28;"	d
SHCTX_E_ALLOC_CACHE	include/proto/shctx.h	31;"	d
SHCTX_E_INIT_LOCK	include/proto/shctx.h	32;"	d
SHCTX_H	include/proto/shctx.h	15;"	d
SHSESS_BLOCK_MIN_SIZE	include/proto/shctx.h	20;"	d
SHSESS_MAX_DATA_LEN	include/proto/shctx.h	24;"	d
SHTABLE_F_DONOTSTOP	src/peers.c	58;"	d	file:
SHTABLE_F_RESYNC_ASSIGN	src/peers.c	56;"	d	file:
SHTABLE_F_RESYNC_LOCAL	src/peers.c	54;"	d	file:
SHTABLE_F_RESYNC_PROCESS	src/peers.c	57;"	d	file:
SHTABLE_F_RESYNC_REMOTE	src/peers.c	55;"	d	file:
SHTABLE_RESYNC_FINISHED	src/peers.c	64;"	d	file:
SHTABLE_RESYNC_FROMLOCAL	src/peers.c	62;"	d	file:
SHTABLE_RESYNC_FROMREMOTE	src/peers.c	63;"	d	file:
SHTABLE_RESYNC_STATEMASK	src/peers.c	61;"	d	file:
SHUT_RD	include/common/compat.h	43;"	d
SHUT_WR	include/common/compat.h	47;"	d
SIG_F_ONE_SHOOT	include/types/signal.h	24;"	d
SIG_F_TYPE_FCT	include/types/signal.h	25;"	d
SIG_F_TYPE_TASK	include/types/signal.h	26;"	d
SILENT_DEFINE	Makefile	/^SILENT_DEFINE =$/;"	m
SI_ET_CONN_ABRT	include/types/stream_interface.h	/^	SI_ET_CONN_ABRT  = 0x0020,  \/* connection aborted by external cause (eg: abort) *\/$/;"	e	enum:__anon41
SI_ET_CONN_ERR	include/types/stream_interface.h	/^	SI_ET_CONN_ERR   = 0x0010,  \/* connection error (eg: no server available) *\/$/;"	e	enum:__anon41
SI_ET_CONN_OTHER	include/types/stream_interface.h	/^	SI_ET_CONN_OTHER = 0x0080,  \/* connection aborted for other reason (eg: 500) *\/$/;"	e	enum:__anon41
SI_ET_CONN_RES	include/types/stream_interface.h	/^	SI_ET_CONN_RES   = 0x0040,  \/* connection aborted due to lack of resources *\/$/;"	e	enum:__anon41
SI_ET_CONN_TO	include/types/stream_interface.h	/^	SI_ET_CONN_TO    = 0x0008,  \/* connection timeout *\/$/;"	e	enum:__anon41
SI_ET_DATA_ABRT	include/types/stream_interface.h	/^	SI_ET_DATA_ABRT  = 0x0400,  \/* data phase aborted by external cause *\/$/;"	e	enum:__anon41
SI_ET_DATA_ERR	include/types/stream_interface.h	/^	SI_ET_DATA_ERR   = 0x0200,  \/* error during data phase *\/$/;"	e	enum:__anon41
SI_ET_DATA_TO	include/types/stream_interface.h	/^	SI_ET_DATA_TO    = 0x0100,  \/* timeout during data phase *\/$/;"	e	enum:__anon41
SI_ET_NONE	include/types/stream_interface.h	/^	SI_ET_NONE       = 0x0000,  \/* no error yet, leave it to zero *\/$/;"	e	enum:__anon41
SI_ET_QUEUE_ABRT	include/types/stream_interface.h	/^	SI_ET_QUEUE_ABRT = 0x0004,  \/* aborted in queue by external cause *\/$/;"	e	enum:__anon41
SI_ET_QUEUE_ERR	include/types/stream_interface.h	/^	SI_ET_QUEUE_ERR  = 0x0002,  \/* queue error (eg: full) *\/$/;"	e	enum:__anon41
SI_ET_QUEUE_TO	include/types/stream_interface.h	/^	SI_ET_QUEUE_TO   = 0x0001,  \/* queue timeout *\/$/;"	e	enum:__anon41
SI_FL_DONT_WAKE	include/types/stream_interface.h	/^	SI_FL_DONT_WAKE  = 0x0020,  \/* resync in progress, don't wake up *\/$/;"	e	enum:__anon42
SI_FL_ERR	include/types/stream_interface.h	/^	SI_FL_ERR        = 0x0002,  \/* a non-recoverable error has occurred *\/$/;"	e	enum:__anon42
SI_FL_EXP	include/types/stream_interface.h	/^	SI_FL_EXP        = 0x0001,  \/* timeout has expired *\/$/;"	e	enum:__anon42
SI_FL_INDEP_STR	include/types/stream_interface.h	/^	SI_FL_INDEP_STR  = 0x0040,  \/* independent streams = don't update rex on write *\/$/;"	e	enum:__anon42
SI_FL_NOHALF	include/types/stream_interface.h	/^	SI_FL_NOHALF     = 0x0100,  \/* no half close, close both sides at once *\/$/;"	e	enum:__anon42
SI_FL_NOLINGER	include/types/stream_interface.h	/^	SI_FL_NOLINGER   = 0x0080,  \/* may close without lingering. One-shot. *\/$/;"	e	enum:__anon42
SI_FL_NONE	include/types/stream_interface.h	/^	SI_FL_NONE       = 0x0000,  \/* nothing *\/$/;"	e	enum:__anon42
SI_FL_SRC_ADDR	include/types/stream_interface.h	/^	SI_FL_SRC_ADDR   = 0x1000,  \/* get the source ip\/port with getsockname *\/$/;"	e	enum:__anon42
SI_FL_WAIT_DATA	include/types/stream_interface.h	/^	SI_FL_WAIT_DATA  = 0x0008,  \/* waiting for more data to send *\/$/;"	e	enum:__anon42
SI_FL_WAIT_ROOM	include/types/stream_interface.h	/^	SI_FL_WAIT_ROOM  = 0x0004,  \/* waiting for space to store incoming data *\/$/;"	e	enum:__anon42
SI_ST_ASS	include/types/stream_interface.h	/^	SI_ST_ASS,               \/* server just assigned to this interface *\/$/;"	e	enum:si_state
SI_ST_CER	include/types/stream_interface.h	/^	SI_ST_CER,               \/* [transient] previous connection attempt failed (resource released) *\/$/;"	e	enum:si_state
SI_ST_CLO	include/types/stream_interface.h	/^	SI_ST_CLO,               \/* stream intf closed, might not existing anymore. Buffers shut. *\/$/;"	e	enum:si_state
SI_ST_CON	include/types/stream_interface.h	/^	SI_ST_CON,               \/* initiated connection request (resource exists) *\/$/;"	e	enum:si_state
SI_ST_DIS	include/types/stream_interface.h	/^	SI_ST_DIS,               \/* [transient] disconnected from other side, but cleanup not done yet *\/$/;"	e	enum:si_state
SI_ST_EST	include/types/stream_interface.h	/^	SI_ST_EST,               \/* connection established (resource exists) *\/$/;"	e	enum:si_state
SI_ST_INI	include/types/stream_interface.h	/^	SI_ST_INI = 0,           \/* interface not sollicitated yet *\/$/;"	e	enum:si_state
SI_ST_QUE	include/types/stream_interface.h	/^	SI_ST_QUE,               \/* interface waiting in queue *\/$/;"	e	enum:si_state
SI_ST_REQ	include/types/stream_interface.h	/^	SI_ST_REQ,               \/* [transient] connection initiation desired and not started yet *\/$/;"	e	enum:si_state
SI_ST_TAR	include/types/stream_interface.h	/^	SI_ST_TAR,               \/* interface in turn-around state after failed connect attempt *\/$/;"	e	enum:si_state
SKIP_CHAR	contrib/halog/halog.c	43;"	d	file:
SMALL_OPTS	Makefile	/^SMALL_OPTS =$/;"	m
SMP_CKP_BE_HRQ_BDY	include/types/sample.h	/^	SMP_CKP_BE_HRQ_BDY,  \/* BE HTTP request body *\/$/;"	e	enum:__anon87
SMP_CKP_BE_HRQ_HDR	include/types/sample.h	/^	SMP_CKP_BE_HRQ_HDR,  \/* BE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon87
SMP_CKP_BE_HRS_BDY	include/types/sample.h	/^	SMP_CKP_BE_HRS_BDY,  \/* BE HTTP response body (stick-store rules are there) *\/$/;"	e	enum:__anon87
SMP_CKP_BE_HRS_HDR	include/types/sample.h	/^	SMP_CKP_BE_HRS_HDR,  \/* BE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon87
SMP_CKP_BE_REQ_CNT	include/types/sample.h	/^	SMP_CKP_BE_REQ_CNT,  \/* BE request content rules ("tcp request content") *\/$/;"	e	enum:__anon87
SMP_CKP_BE_RES_CNT	include/types/sample.h	/^	SMP_CKP_BE_RES_CNT,  \/* BE response content rules ("tcp response content") *\/$/;"	e	enum:__anon87
SMP_CKP_BE_SET_SRV	include/types/sample.h	/^	SMP_CKP_BE_SET_SRV,  \/* BE server switching rules ("use_server", "balance", "force-persist", "stick", ...) *\/$/;"	e	enum:__anon87
SMP_CKP_BE_SRV_CON	include/types/sample.h	/^	SMP_CKP_BE_SRV_CON,  \/* BE server connect (eg: "source") *\/$/;"	e	enum:__anon87
SMP_CKP_BE_STO_RUL	include/types/sample.h	/^	SMP_CKP_BE_STO_RUL,  \/* BE stick-store rules *\/$/;"	e	enum:__anon87
SMP_CKP_ENTRIES	include/types/sample.h	/^	SMP_CKP_ENTRIES \/* nothing after this *\/$/;"	e	enum:__anon87
SMP_CKP_FE_CON_ACC	include/types/sample.h	/^	SMP_CKP_FE_CON_ACC,  \/* FE connection accept rules ("tcp request connection") *\/$/;"	e	enum:__anon87
SMP_CKP_FE_HRQ_BDY	include/types/sample.h	/^	SMP_CKP_FE_HRQ_BDY,  \/* FE HTTP request body *\/$/;"	e	enum:__anon87
SMP_CKP_FE_HRQ_HDR	include/types/sample.h	/^	SMP_CKP_FE_HRQ_HDR,  \/* FE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon87
SMP_CKP_FE_HRS_BDY	include/types/sample.h	/^	SMP_CKP_FE_HRS_BDY,  \/* FE HTTP response body *\/$/;"	e	enum:__anon87
SMP_CKP_FE_HRS_HDR	include/types/sample.h	/^	SMP_CKP_FE_HRS_HDR,  \/* FE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon87
SMP_CKP_FE_LOG_END	include/types/sample.h	/^	SMP_CKP_FE_LOG_END,  \/* FE log at the end of the txn\/session *\/$/;"	e	enum:__anon87
SMP_CKP_FE_REQ_CNT	include/types/sample.h	/^	SMP_CKP_FE_REQ_CNT,  \/* FE request content rules ("tcp request content") *\/$/;"	e	enum:__anon87
SMP_CKP_FE_RES_CNT	include/types/sample.h	/^	SMP_CKP_FE_RES_CNT,  \/* FE response content rules ("tcp response content") *\/$/;"	e	enum:__anon87
SMP_CKP_FE_SES_ACC	include/types/sample.h	/^	SMP_CKP_FE_SES_ACC,  \/* FE session accept rules (to come soon) *\/$/;"	e	enum:__anon87
SMP_CKP_FE_SET_BCK	include/types/sample.h	/^	SMP_CKP_FE_SET_BCK,  \/* FE backend switching rules ("use_backend") *\/$/;"	e	enum:__anon87
SMP_F_CONST	include/types/sample.h	/^	SMP_F_CONST      = 1 << 7, \/* This sample use constant memory. May diplicate it before changes *\/$/;"	e	enum:__anon91
SMP_F_MAY_CHANGE	include/types/sample.h	/^	SMP_F_MAY_CHANGE = 1 << 1, \/* sample is unstable and might change (eg: request length) *\/$/;"	e	enum:__anon91
SMP_F_NOT_LAST	include/types/sample.h	/^	SMP_F_NOT_LAST   = 1 << 0, \/* other occurrences might exist for this sample *\/$/;"	e	enum:__anon91
SMP_F_VOLATILE	include/types/sample.h	/^	SMP_F_VOLATILE   = (1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6), \/* any volatility condition *\/$/;"	e	enum:__anon91
SMP_F_VOL_1ST	include/types/sample.h	/^	SMP_F_VOL_1ST    = 1 << 3, \/* result sensitive to changes in first line (eg: URI) *\/$/;"	e	enum:__anon91
SMP_F_VOL_HDR	include/types/sample.h	/^	SMP_F_VOL_HDR    = 1 << 4, \/* result sensitive to changes in headers *\/$/;"	e	enum:__anon91
SMP_F_VOL_SESS	include/types/sample.h	/^	SMP_F_VOL_SESS   = 1 << 6, \/* result sensitive to new session (eg: src IP) *\/$/;"	e	enum:__anon91
SMP_F_VOL_TEST	include/types/sample.h	/^	SMP_F_VOL_TEST   = 1 << 2, \/* result must not survive longer than the test (eg: time) *\/$/;"	e	enum:__anon91
SMP_F_VOL_TXN	include/types/sample.h	/^	SMP_F_VOL_TXN    = 1 << 5, \/* result sensitive to new transaction (eg: HTTP version) *\/$/;"	e	enum:__anon91
SMP_OPT_DIR	include/types/sample.h	/^	SMP_OPT_DIR     = (SMP_OPT_DIR_REQ|SMP_OPT_DIR_RES), \/* mask to get direction *\/$/;"	e	enum:__anon90
SMP_OPT_DIR_REQ	include/types/sample.h	/^	SMP_OPT_DIR_REQ = 0,    \/* direction = request *\/$/;"	e	enum:__anon90
SMP_OPT_DIR_RES	include/types/sample.h	/^	SMP_OPT_DIR_RES = 1,    \/* direction = response *\/$/;"	e	enum:__anon90
SMP_OPT_FINAL	include/types/sample.h	/^	SMP_OPT_FINAL   = 2,    \/* final fetch, contents won't change anymore *\/$/;"	e	enum:__anon90
SMP_OPT_ITERATE	include/types/sample.h	/^	SMP_OPT_ITERATE = 4,    \/* fetches may be iterated if supported (for ACLs) *\/$/;"	e	enum:__anon90
SMP_SRC_BKEND	include/types/sample.h	/^	SMP_SRC_BKEND,  \/* fetch uses information about the backend *\/$/;"	e	enum:__anon86
SMP_SRC_ENTRIES	include/types/sample.h	/^	SMP_SRC_ENTRIES \/* nothing after this *\/$/;"	e	enum:__anon86
SMP_SRC_FTEND	include/types/sample.h	/^	SMP_SRC_FTEND,  \/* frontend which accepted the connection *\/$/;"	e	enum:__anon86
SMP_SRC_HRQBO	include/types/sample.h	/^	SMP_SRC_HRQBO,  \/* fetch uses information about HTTP request body *\/$/;"	e	enum:__anon86
SMP_SRC_HRQHP	include/types/sample.h	/^	SMP_SRC_HRQHP,  \/* fetch uses persistent information about HTTP request headers (eg: meth) *\/$/;"	e	enum:__anon86
SMP_SRC_HRQHV	include/types/sample.h	/^	SMP_SRC_HRQHV,  \/* fetch uses volatile information about HTTP request headers (eg: value) *\/$/;"	e	enum:__anon86
SMP_SRC_HRSBO	include/types/sample.h	/^	SMP_SRC_HRSBO,  \/* fetch uses information about HTTP response body *\/$/;"	e	enum:__anon86
SMP_SRC_HRSHP	include/types/sample.h	/^	SMP_SRC_HRSHP,  \/* fetch uses persistent information about HTTP response headers (eg: status) *\/$/;"	e	enum:__anon86
SMP_SRC_HRSHV	include/types/sample.h	/^	SMP_SRC_HRSHV,  \/* fetch uses volatile information about HTTP response headers (eg: value) *\/$/;"	e	enum:__anon86
SMP_SRC_INTRN	include/types/sample.h	/^	SMP_SRC_INTRN,  \/* internal context-less information *\/$/;"	e	enum:__anon86
SMP_SRC_L4CLI	include/types/sample.h	/^	SMP_SRC_L4CLI,  \/* L4 information about the client *\/$/;"	e	enum:__anon86
SMP_SRC_L4SRV	include/types/sample.h	/^	SMP_SRC_L4SRV,  \/* fetch uses information about the server L4 connection *\/$/;"	e	enum:__anon86
SMP_SRC_L5CLI	include/types/sample.h	/^	SMP_SRC_L5CLI,  \/* fetch uses client information from embryonic session *\/$/;"	e	enum:__anon86
SMP_SRC_L5SRV	include/types/sample.h	/^	SMP_SRC_L5SRV,  \/* fetch uses information about the server L5 connection *\/$/;"	e	enum:__anon86
SMP_SRC_L6REQ	include/types/sample.h	/^	SMP_SRC_L6REQ,  \/* fetch uses raw information from the request buffer *\/$/;"	e	enum:__anon86
SMP_SRC_L6RES	include/types/sample.h	/^	SMP_SRC_L6RES,  \/* fetch uses raw information from the response buffer *\/$/;"	e	enum:__anon86
SMP_SRC_LISTN	include/types/sample.h	/^	SMP_SRC_LISTN,  \/* listener which accepted the connection *\/$/;"	e	enum:__anon86
SMP_SRC_RQFIN	include/types/sample.h	/^	SMP_SRC_RQFIN,  \/* final information about request buffer (eg: tot bytes) *\/$/;"	e	enum:__anon86
SMP_SRC_RSFIN	include/types/sample.h	/^	SMP_SRC_RSFIN,  \/* final information about response buffer (eg: tot bytes) *\/$/;"	e	enum:__anon86
SMP_SRC_SERVR	include/types/sample.h	/^	SMP_SRC_SERVR,  \/* fetch uses information about the selected server *\/$/;"	e	enum:__anon86
SMP_SRC_SSFIN	include/types/sample.h	/^	SMP_SRC_SSFIN,  \/* final information about the session (eg: #requests, final flags) *\/$/;"	e	enum:__anon86
SMP_SRC_TRACK	include/types/sample.h	/^	SMP_SRC_TRACK,  \/* fetch involves track counters *\/$/;"	e	enum:__anon86
SMP_SRC_TXFIN	include/types/sample.h	/^	SMP_SRC_TXFIN,  \/* final information about the transaction (eg: #comp rate) *\/$/;"	e	enum:__anon86
SMP_TYPES	include/types/sample.h	/^	SMP_TYPES        \/* number of types, must always be last *\/$/;"	e	enum:__anon85
SMP_T_ADDR	include/types/sample.h	/^	SMP_T_ADDR,      \/* ipv4 or ipv6, only used for input type compatibility *\/$/;"	e	enum:__anon85
SMP_T_BIN	include/types/sample.h	/^	SMP_T_BIN,       \/* buffer type *\/$/;"	e	enum:__anon85
SMP_T_BOOL	include/types/sample.h	/^	SMP_T_BOOL = 0,  \/* boolean *\/$/;"	e	enum:__anon85
SMP_T_IPV4	include/types/sample.h	/^	SMP_T_IPV4,      \/* ipv4 type *\/$/;"	e	enum:__anon85
SMP_T_IPV6	include/types/sample.h	/^	SMP_T_IPV6,      \/* ipv6 type *\/$/;"	e	enum:__anon85
SMP_T_METH	include/types/sample.h	/^	SMP_T_METH,      \/* contain method *\/$/;"	e	enum:__anon85
SMP_T_SINT	include/types/sample.h	/^	SMP_T_SINT,      \/* signed 32bits integer type *\/$/;"	e	enum:__anon85
SMP_T_STR	include/types/sample.h	/^	SMP_T_STR,       \/* char string type *\/$/;"	e	enum:__anon85
SMP_T_UINT	include/types/sample.h	/^	SMP_T_UINT,      \/* unsigned 32bits integer type *\/$/;"	e	enum:__anon85
SMP_USE_BKEND	include/types/sample.h	/^	SMP_USE_BKEND = 1 << SMP_SRC_BKEND,  \/* fetch uses information about the backend *\/$/;"	e	enum:__anon88
SMP_USE_FTEND	include/types/sample.h	/^	SMP_USE_FTEND = 1 << SMP_SRC_FTEND,  \/* frontend which accepted the connection *\/$/;"	e	enum:__anon88
SMP_USE_HRQBO	include/types/sample.h	/^	SMP_USE_HRQBO = 1 << SMP_SRC_HRQBO,  \/* fetch uses information about HTTP request body *\/$/;"	e	enum:__anon88
SMP_USE_HRQHP	include/types/sample.h	/^	SMP_USE_HRQHP = 1 << SMP_SRC_HRQHP,  \/* fetch uses persistent information about HTTP request headers (eg: meth) *\/$/;"	e	enum:__anon88
SMP_USE_HRQHV	include/types/sample.h	/^	SMP_USE_HRQHV = 1 << SMP_SRC_HRQHV,  \/* fetch uses volatile information about HTTP request headers (eg: value) *\/$/;"	e	enum:__anon88
SMP_USE_HRSBO	include/types/sample.h	/^	SMP_USE_HRSBO = 1 << SMP_SRC_HRSBO,  \/* fetch uses information about HTTP response body *\/$/;"	e	enum:__anon88
SMP_USE_HRSHP	include/types/sample.h	/^	SMP_USE_HRSHP = 1 << SMP_SRC_HRSHP,  \/* fetch uses persistent information about HTTP response headers (eg: status) *\/$/;"	e	enum:__anon88
SMP_USE_HRSHV	include/types/sample.h	/^	SMP_USE_HRSHV = 1 << SMP_SRC_HRSHV,  \/* fetch uses volatile information about HTTP response headers (eg: value) *\/$/;"	e	enum:__anon88
SMP_USE_HTTP_ANY	include/types/sample.h	/^	SMP_USE_HTTP_ANY = SMP_USE_HRQHV | SMP_USE_HRQHP | SMP_USE_HRQBO |$/;"	e	enum:__anon88
SMP_USE_INTRN	include/types/sample.h	/^	SMP_USE_INTRN = 1 << SMP_SRC_INTRN,  \/* internal context-less information *\/$/;"	e	enum:__anon88
SMP_USE_L4CLI	include/types/sample.h	/^	SMP_USE_L4CLI = 1 << SMP_SRC_L4CLI,  \/* L4 information about the client *\/$/;"	e	enum:__anon88
SMP_USE_L4SRV	include/types/sample.h	/^	SMP_USE_L4SRV = 1 << SMP_SRC_L4SRV,  \/* fetch uses information about the server L4 connection *\/$/;"	e	enum:__anon88
SMP_USE_L5CLI	include/types/sample.h	/^	SMP_USE_L5CLI = 1 << SMP_SRC_L5CLI,  \/* fetch uses client information from embryonic session *\/$/;"	e	enum:__anon88
SMP_USE_L5SRV	include/types/sample.h	/^	SMP_USE_L5SRV = 1 << SMP_SRC_L5SRV,  \/* fetch uses information about the server L5 connection *\/$/;"	e	enum:__anon88
SMP_USE_L6REQ	include/types/sample.h	/^	SMP_USE_L6REQ = 1 << SMP_SRC_L6REQ,  \/* fetch uses raw information from the request buffer *\/$/;"	e	enum:__anon88
SMP_USE_L6RES	include/types/sample.h	/^	SMP_USE_L6RES = 1 << SMP_SRC_L6RES,  \/* fetch uses raw information from the response buffer *\/$/;"	e	enum:__anon88
SMP_USE_LISTN	include/types/sample.h	/^	SMP_USE_LISTN = 1 << SMP_SRC_LISTN,  \/* listener which accepted the connection *\/$/;"	e	enum:__anon88
SMP_USE_RQFIN	include/types/sample.h	/^	SMP_USE_RQFIN = 1 << SMP_SRC_RQFIN,  \/* final information about request buffer (eg: tot bytes) *\/$/;"	e	enum:__anon88
SMP_USE_RSFIN	include/types/sample.h	/^	SMP_USE_RSFIN = 1 << SMP_SRC_RSFIN,  \/* final information about response buffer (eg: tot bytes) *\/$/;"	e	enum:__anon88
SMP_USE_SERVR	include/types/sample.h	/^	SMP_USE_SERVR = 1 << SMP_SRC_SERVR,  \/* fetch uses information about the selected server *\/$/;"	e	enum:__anon88
SMP_USE_SSFIN	include/types/sample.h	/^	SMP_USE_SSFIN = 1 << SMP_SRC_SSFIN,  \/* final information about the session (eg: #requests, final flags) *\/$/;"	e	enum:__anon88
SMP_USE_TRACK	include/types/sample.h	/^	SMP_USE_TRACK = 1 << SMP_SRC_TRACK,  \/* fetch involves track counters *\/$/;"	e	enum:__anon88
SMP_USE_TXFIN	include/types/sample.h	/^	SMP_USE_TXFIN = 1 << SMP_SRC_TXFIN,  \/* final information about the transaction (eg: #comp rate) *\/$/;"	e	enum:__anon88
SMP_VAL_BE_HRQ_BDY	include/types/sample.h	/^	SMP_VAL_BE_HRQ_BDY = 1 << SMP_CKP_BE_HRQ_BDY,  \/* BE HTTP request body *\/$/;"	e	enum:__anon89
SMP_VAL_BE_HRQ_HDR	include/types/sample.h	/^	SMP_VAL_BE_HRQ_HDR = 1 << SMP_CKP_BE_HRQ_HDR,  \/* BE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon89
SMP_VAL_BE_HRS_BDY	include/types/sample.h	/^	SMP_VAL_BE_HRS_BDY = 1 << SMP_CKP_BE_HRS_BDY,  \/* BE HTTP response body (stick-store rules are there) *\/$/;"	e	enum:__anon89
SMP_VAL_BE_HRS_HDR	include/types/sample.h	/^	SMP_VAL_BE_HRS_HDR = 1 << SMP_CKP_BE_HRS_HDR,  \/* BE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon89
SMP_VAL_BE_REQ_CNT	include/types/sample.h	/^	SMP_VAL_BE_REQ_CNT = 1 << SMP_CKP_BE_REQ_CNT,  \/* BE request content rules ("tcp request content") *\/$/;"	e	enum:__anon89
SMP_VAL_BE_RES_CNT	include/types/sample.h	/^	SMP_VAL_BE_RES_CNT = 1 << SMP_CKP_BE_RES_CNT,  \/* BE response content rules ("tcp response content") *\/$/;"	e	enum:__anon89
SMP_VAL_BE_SET_SRV	include/types/sample.h	/^	SMP_VAL_BE_SET_SRV = 1 << SMP_CKP_BE_SET_SRV,  \/* BE server switching rules ("use_server", "balance", "force-persist", "stick", ...) *\/$/;"	e	enum:__anon89
SMP_VAL_BE_SRV_CON	include/types/sample.h	/^	SMP_VAL_BE_SRV_CON = 1 << SMP_CKP_BE_SRV_CON,  \/* BE server connect (eg: "source") *\/$/;"	e	enum:__anon89
SMP_VAL_BE_STO_RUL	include/types/sample.h	/^	SMP_VAL_BE_STO_RUL = 1 << SMP_CKP_BE_STO_RUL,  \/* BE stick-store rules *\/$/;"	e	enum:__anon89
SMP_VAL_FE_CON_ACC	include/types/sample.h	/^	SMP_VAL_FE_CON_ACC = 1 << SMP_CKP_FE_CON_ACC,  \/* FE connection accept rules ("tcp request connection") *\/$/;"	e	enum:__anon89
SMP_VAL_FE_HRQ_BDY	include/types/sample.h	/^	SMP_VAL_FE_HRQ_BDY = 1 << SMP_CKP_FE_HRQ_BDY,  \/* FE HTTP request body *\/$/;"	e	enum:__anon89
SMP_VAL_FE_HRQ_HDR	include/types/sample.h	/^	SMP_VAL_FE_HRQ_HDR = 1 << SMP_CKP_FE_HRQ_HDR,  \/* FE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon89
SMP_VAL_FE_HRS_BDY	include/types/sample.h	/^	SMP_VAL_FE_HRS_BDY = 1 << SMP_CKP_FE_HRS_BDY,  \/* FE HTTP response body *\/$/;"	e	enum:__anon89
SMP_VAL_FE_HRS_HDR	include/types/sample.h	/^	SMP_VAL_FE_HRS_HDR = 1 << SMP_CKP_FE_HRS_HDR,  \/* FE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon89
SMP_VAL_FE_LOG_END	include/types/sample.h	/^	SMP_VAL_FE_LOG_END = 1 << SMP_CKP_FE_LOG_END,  \/* FE log at the end of the txn\/session *\/$/;"	e	enum:__anon89
SMP_VAL_FE_REQ_CNT	include/types/sample.h	/^	SMP_VAL_FE_REQ_CNT = 1 << SMP_CKP_FE_REQ_CNT,  \/* FE request content rules ("tcp request content") *\/$/;"	e	enum:__anon89
SMP_VAL_FE_RES_CNT	include/types/sample.h	/^	SMP_VAL_FE_RES_CNT = 1 << SMP_CKP_FE_RES_CNT,  \/* FE response content rules ("tcp response content") *\/$/;"	e	enum:__anon89
SMP_VAL_FE_SES_ACC	include/types/sample.h	/^	SMP_VAL_FE_SES_ACC = 1 << SMP_CKP_FE_SES_ACC,  \/* FE session accept rules (to come soon) *\/$/;"	e	enum:__anon89
SMP_VAL_FE_SET_BCK	include/types/sample.h	/^	SMP_VAL_FE_SET_BCK = 1 << SMP_CKP_FE_SET_BCK,  \/* FE backend switching rules ("use_backend") *\/$/;"	e	enum:__anon89
SMP_VAL_REQUEST	include/types/sample.h	/^	SMP_VAL_REQUEST    = SMP_VAL_FE_CON_ACC | SMP_VAL_FE_SES_ACC | SMP_VAL_FE_REQ_CNT |$/;"	e	enum:__anon89
SMP_VAL_RESPONSE	include/types/sample.h	/^	SMP_VAL_RESPONSE   = SMP_VAL_BE_SRV_CON | SMP_VAL_BE_RES_CNT | SMP_VAL_BE_HRS_HDR |$/;"	e	enum:__anon89
SMP_VAL___________	include/types/sample.h	/^	SMP_VAL___________ = 0,        \/* Just used as a visual marker *\/$/;"	e	enum:__anon89
SN_ADDR_SET	include/types/session.h	50;"	d
SN_ASSIGNED	include/types/session.h	49;"	d
SN_BE_ASSIGNED	include/types/session.h	51;"	d
SN_COMP_READY	include/types/session.h	91;"	d
SN_CONN_TAR	include/types/session.h	58;"	d
SN_CURR_SESS	include/types/session.h	55;"	d
SN_DIRECT	include/types/session.h	48;"	d
SN_ERR_CLICL	include/types/session.h	66;"	d
SN_ERR_CLITO	include/types/session.h	65;"	d
SN_ERR_DOWN	include/types/session.h	72;"	d
SN_ERR_INTERNAL	include/types/session.h	71;"	d
SN_ERR_KILLED	include/types/session.h	73;"	d
SN_ERR_LOCAL	include/types/session.h	64;"	d
SN_ERR_MASK	include/types/session.h	75;"	d
SN_ERR_NONE	include/types/session.h	63;"	d
SN_ERR_PRXCOND	include/types/session.h	69;"	d
SN_ERR_RESOURCE	include/types/session.h	70;"	d
SN_ERR_SHIFT	include/types/session.h	76;"	d
SN_ERR_SRVCL	include/types/session.h	68;"	d
SN_ERR_SRVTO	include/types/session.h	67;"	d
SN_ERR_UP	include/types/session.h	74;"	d
SN_FINST_C	include/types/session.h	80;"	d
SN_FINST_D	include/types/session.h	82;"	d
SN_FINST_H	include/types/session.h	81;"	d
SN_FINST_L	include/types/session.h	83;"	d
SN_FINST_MASK	include/types/session.h	86;"	d
SN_FINST_Q	include/types/session.h	84;"	d
SN_FINST_R	include/types/session.h	79;"	d
SN_FINST_SHIFT	include/types/session.h	87;"	d
SN_FINST_T	include/types/session.h	85;"	d
SN_FORCE_PRST	include/types/session.h	53;"	d
SN_IGNORE_PRST	include/types/session.h	89;"	d
SN_INITIALIZED	include/types/session.h	56;"	d
SN_MONITOR	include/types/session.h	54;"	d
SN_REDIRECTABLE	include/types/session.h	59;"	d
SN_REDISP	include/types/session.h	57;"	d
SN_SRV_REUSED	include/types/session.h	92;"	d
SN_TUNNEL	include/types/session.h	60;"	d
SOCK_NONBLOCK	include/common/accept4.h	41;"	d
SOURCE_FIELD	contrib/halog/halog.c	28;"	d	file:
SO_REUSEPORT	include/common/compat.h	119;"	d
SO_REUSEPORT	include/common/compat.h	121;"	d
SPEC_CFLAGS	Makefile	/^SPEC_CFLAGS = -fno-strict-aliasing$/;"	m
SPLICE_FULL_HINT	src/raw_sock.c	51;"	d	file:
SPLICE_F_MORE	include/common/splice.h	47;"	d
SPLICE_F_MOVE	include/common/splice.h	39;"	d
SPLICE_F_NONBLOCK	include/common/splice.h	43;"	d
SRV_ADMF_DRAIN	include/types/server.h	/^	SRV_ADMF_DRAIN     = 0xC,        \/* mask to check if any drain flag is present *\/$/;"	e	enum:srv_admin
SRV_ADMF_FDRAIN	include/types/server.h	/^	SRV_ADMF_FDRAIN    = 0x4,        \/* the server was explicitly forced into drain state *\/$/;"	e	enum:srv_admin
SRV_ADMF_FMAINT	include/types/server.h	/^	SRV_ADMF_FMAINT    = 0x1,        \/* the server was explicitly forced into maintenance *\/$/;"	e	enum:srv_admin
SRV_ADMF_IDRAIN	include/types/server.h	/^	SRV_ADMF_IDRAIN    = 0x8,        \/* the server has inherited the drain status from a tracked server *\/$/;"	e	enum:srv_admin
SRV_ADMF_IMAINT	include/types/server.h	/^	SRV_ADMF_IMAINT    = 0x2,        \/* the server has inherited the maintenance status from a tracked server *\/$/;"	e	enum:srv_admin
SRV_ADMF_MAINT	include/types/server.h	/^	SRV_ADMF_MAINT     = 0x3,        \/* mask to check if any maintenance flag is present *\/$/;"	e	enum:srv_admin
SRV_CHK_INTER_THRES	include/common/defaults.h	169;"	d
SRV_EWGHT_MAX	include/types/server.h	106;"	d
SRV_EWGHT_RANGE	include/types/server.h	105;"	d
SRV_F_BACKUP	include/types/server.h	85;"	d
SRV_F_MAPPORTS	include/types/server.h	86;"	d
SRV_F_NON_STICK	include/types/server.h	87;"	d
SRV_PP_V1	include/types/server.h	90;"	d
SRV_PP_V2	include/types/server.h	91;"	d
SRV_PP_V2_SSL	include/types/server.h	92;"	d
SRV_PP_V2_SSL_CN	include/types/server.h	93;"	d
SRV_SSL_O_NONE	include/types/server.h	110;"	d
SRV_SSL_O_NO_SSLV3	include/types/server.h	112;"	d
SRV_SSL_O_NO_TLSV10	include/types/server.h	113;"	d
SRV_SSL_O_NO_TLSV11	include/types/server.h	114;"	d
SRV_SSL_O_NO_TLSV12	include/types/server.h	115;"	d
SRV_SSL_O_NO_TLS_TICKETS	include/types/server.h	123;"	d
SRV_SSL_O_NO_VMASK	include/types/server.h	111;"	d
SRV_SSL_O_USE_SSLV3	include/types/server.h	118;"	d
SRV_SSL_O_USE_TLSV10	include/types/server.h	119;"	d
SRV_SSL_O_USE_TLSV11	include/types/server.h	120;"	d
SRV_SSL_O_USE_TLSV12	include/types/server.h	121;"	d
SRV_SSL_O_USE_VMASK	include/types/server.h	117;"	d
SRV_STATUS_FULL	include/types/server.h	99;"	d
SRV_STATUS_INTERNAL	include/types/server.h	97;"	d
SRV_STATUS_NOSRV	include/types/server.h	98;"	d
SRV_STATUS_OK	include/types/server.h	96;"	d
SRV_STATUS_QUEUED	include/types/server.h	100;"	d
SRV_ST_RUNNING	include/types/server.h	/^	SRV_ST_RUNNING,                  \/* the server is fully up *\/$/;"	e	enum:srv_state
SRV_ST_STARTING	include/types/server.h	/^	SRV_ST_STARTING,                 \/* the server is warming up (up but throttled) *\/$/;"	e	enum:srv_state
SRV_ST_STOPPED	include/types/server.h	/^	SRV_ST_STOPPED = 0,              \/* the server is down. Please keep set to zero. *\/$/;"	e	enum:srv_state
SRV_ST_STOPPING	include/types/server.h	/^	SRV_ST_STOPPING,                 \/* the server is up but soft-stopping (eg: 404) *\/$/;"	e	enum:srv_state
SRV_UWGHT_MAX	include/types/server.h	104;"	d
SRV_UWGHT_RANGE	include/types/server.h	103;"	d
SSLCACHESIZE	include/common/defaults.h	214;"	d
SSL_DEFAULT_DH_PARAM	include/common/defaults.h	219;"	d
SSL_MODE_RELEASE_BUFFERS	src/ssl_sock.c	1365;"	d	file:
SSL_OP_CIPHER_SERVER_PREFERENCE	src/ssl_sock.c	1336;"	d	file:
SSL_OP_NO_COMPRESSION	src/ssl_sock.c	1350;"	d	file:
SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	src/ssl_sock.c	1340;"	d	file:
SSL_OP_NO_TICKET	src/ssl_sock.c	1347;"	d	file:
SSL_OP_NO_TLSv1_1	src/ssl_sock.c	1353;"	d	file:
SSL_OP_NO_TLSv1_2	src/ssl_sock.c	1356;"	d	file:
SSL_OP_SINGLE_DH_USE	src/ssl_sock.c	1359;"	d	file:
SSL_OP_SINGLE_ECDH_USE	src/ssl_sock.c	1344;"	d	file:
SSL_OP_SINGLE_ECDH_USE	src/ssl_sock.c	1362;"	d	file:
SSL_SERVER_VERIFY_NONE	include/types/global.h	/^	SSL_SERVER_VERIFY_NONE = 0,$/;"	e	enum:__anon94
SSL_SERVER_VERIFY_REQUIRED	include/types/global.h	/^	SSL_SERVER_VERIFY_REQUIRED = 1,$/;"	e	enum:__anon94
SSL_SOCK_CAEDEPTH_TO_ST	src/ssl_sock.c	90;"	d	file:
SSL_SOCK_CA_ERROR_TO_ST	src/ssl_sock.c	89;"	d	file:
SSL_SOCK_CRTERROR_TO_ST	src/ssl_sock.c	91;"	d	file:
SSL_SOCK_RECV_HEARTBEAT	src/ssl_sock.c	84;"	d	file:
SSL_SOCK_SEND_UNLIMITED	src/ssl_sock.c	83;"	d	file:
SSL_SOCK_ST_FL_16K_WBFSIZE	src/ssl_sock.c	82;"	d	file:
SSL_SOCK_ST_FL_VERIFY_DONE	src/ssl_sock.c	81;"	d	file:
SSL_SOCK_ST_TO_CAEDEPTH	src/ssl_sock.c	94;"	d	file:
SSL_SOCK_ST_TO_CA_ERROR	src/ssl_sock.c	93;"	d	file:
SSL_SOCK_ST_TO_CRTERROR	src/ssl_sock.c	95;"	d	file:
SSL_SOCK_VERIFY_DEFAULT	src/ssl_sock.c	/^	SSL_SOCK_VERIFY_DEFAULT  = 0,$/;"	e	enum:__anon116	file:
SSL_SOCK_VERIFY_NONE	src/ssl_sock.c	/^	SSL_SOCK_VERIFY_NONE     = 3,$/;"	e	enum:__anon116	file:
SSL_SOCK_VERIFY_OPTIONAL	src/ssl_sock.c	/^	SSL_SOCK_VERIFY_OPTIONAL = 2,$/;"	e	enum:__anon116	file:
SSL_SOCK_VERIFY_REQUIRED	src/ssl_sock.c	/^	SSL_SOCK_VERIFY_REQUIRED = 1,$/;"	e	enum:__anon116	file:
SSL_renegotiate_pending	src/ssl_sock.c	1341;"	d	file:
STATS_DEFAULT_REALM	include/common/uri_auth.h	59;"	d
STATS_DEFAULT_REALM	include/common/uri_auth.h	61;"	d
STATS_DEFAULT_URI	include/common/uri_auth.h	52;"	d
STATS_DEFAULT_URI	include/common/uri_auth.h	54;"	d
STATS_IID	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_IID => 27;$/;"	c
STATS_PXNAME	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_PXNAME => 0;$/;"	c
STATS_SID	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SID => 28;$/;"	c
STATS_SVNAME	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SVNAME => 1;$/;"	c
STATS_TYPE	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_TYPE => 32;$/;"	c
STATS_TYPE_BE	include/proto/dumpstats.h	38;"	d
STATS_TYPE_FE	include/proto/dumpstats.h	37;"	d
STATS_TYPE_SO	include/proto/dumpstats.h	40;"	d
STATS_TYPE_SV	include/proto/dumpstats.h	39;"	d
STATS_VERSION_STRING	include/common/defaults.h	177;"	d
STATUS_FIELD	contrib/halog/halog.c	32;"	d	file:
STAT_ADMIN	include/proto/dumpstats.h	33;"	d
STAT_BOUND	include/proto/dumpstats.h	35;"	d
STAT_CHUNKED	include/proto/dumpstats.h	34;"	d
STAT_CLI_END	src/dumpstats.c	/^	STAT_CLI_END,        \/* final state, let's close *\/$/;"	e	enum:__anon109	file:
STAT_CLI_GETREQ	src/dumpstats.c	/^	STAT_CLI_GETREQ,     \/* wait for a request *\/$/;"	e	enum:__anon109	file:
STAT_CLI_INIT	src/dumpstats.c	/^	STAT_CLI_INIT = 0,   \/* initial state, must leave to zero ! *\/$/;"	e	enum:__anon109	file:
STAT_CLI_OUTPUT	src/dumpstats.c	/^	STAT_CLI_OUTPUT,     \/* all states after this one are responses *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_CLR	src/dumpstats.c	/^	STAT_CLI_O_CLR,      \/* clear tables *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_ERR	src/dumpstats.c	/^	STAT_CLI_O_ERR,      \/* dump errors *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_INFO	src/dumpstats.c	/^	STAT_CLI_O_INFO,     \/* dump info *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_MLOOK	src/dumpstats.c	/^	STAT_CLI_O_MLOOK,    \/* lookup a map entry *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_PAT	src/dumpstats.c	/^	STAT_CLI_O_PAT,      \/* list all entries of a pattern *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_PATS	src/dumpstats.c	/^	STAT_CLI_O_PATS,     \/* list all pattern reference avalaible *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_POOLS	src/dumpstats.c	/^	STAT_CLI_O_POOLS,    \/* dump memory pools *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_SESS	src/dumpstats.c	/^	STAT_CLI_O_SESS,     \/* dump sessions *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_SET	src/dumpstats.c	/^	STAT_CLI_O_SET,      \/* set entries in tables *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_STAT	src/dumpstats.c	/^	STAT_CLI_O_STAT,     \/* dump stats *\/$/;"	e	enum:__anon109	file:
STAT_CLI_O_TAB	src/dumpstats.c	/^	STAT_CLI_O_TAB,      \/* dump tables *\/$/;"	e	enum:__anon109	file:
STAT_CLI_PRINT	src/dumpstats.c	/^	STAT_CLI_PRINT,      \/* display message in cli->msg *\/$/;"	e	enum:__anon109	file:
STAT_CLI_PRINT_FREE	src/dumpstats.c	/^	STAT_CLI_PRINT_FREE, \/* display message in cli->msg. After the display, free the pointer *\/$/;"	e	enum:__anon109	file:
STAT_CLI_PROMPT	src/dumpstats.c	/^	STAT_CLI_PROMPT,     \/* display the prompt (first output, same code) *\/$/;"	e	enum:__anon109	file:
STAT_FMT_HTML	include/proto/dumpstats.h	30;"	d
STAT_HIDE_DOWN	include/proto/dumpstats.h	31;"	d
STAT_HTTP_DONE	include/proto/dumpstats.h	/^	STAT_HTTP_DONE = 0,  \/* finished *\/$/;"	e	enum:__anon106
STAT_HTTP_DUMP	include/proto/dumpstats.h	/^	STAT_HTTP_DUMP,      \/* dumping stats *\/$/;"	e	enum:__anon106
STAT_HTTP_HEAD	include/proto/dumpstats.h	/^	STAT_HTTP_HEAD,      \/* send headers before dump *\/$/;"	e	enum:__anon106
STAT_HTTP_LAST	include/proto/dumpstats.h	/^	STAT_HTTP_LAST,      \/* sending last chunk of response *\/$/;"	e	enum:__anon106
STAT_HTTP_POST	include/proto/dumpstats.h	/^	STAT_HTTP_POST,      \/* waiting post data *\/$/;"	e	enum:__anon106
STAT_NO_REFRESH	include/proto/dumpstats.h	32;"	d
STAT_PX_ST_BE	src/dumpstats.c	/^	STAT_PX_ST_BE,$/;"	e	enum:__anon112	file:
STAT_PX_ST_END	src/dumpstats.c	/^	STAT_PX_ST_END,$/;"	e	enum:__anon112	file:
STAT_PX_ST_FE	src/dumpstats.c	/^	STAT_PX_ST_FE,$/;"	e	enum:__anon112	file:
STAT_PX_ST_FIN	src/dumpstats.c	/^	STAT_PX_ST_FIN,$/;"	e	enum:__anon112	file:
STAT_PX_ST_INIT	src/dumpstats.c	/^	STAT_PX_ST_INIT = 0,$/;"	e	enum:__anon112	file:
STAT_PX_ST_LI	src/dumpstats.c	/^	STAT_PX_ST_LI,$/;"	e	enum:__anon112	file:
STAT_PX_ST_SV	src/dumpstats.c	/^	STAT_PX_ST_SV,$/;"	e	enum:__anon112	file:
STAT_PX_ST_TH	src/dumpstats.c	/^	STAT_PX_ST_TH,$/;"	e	enum:__anon112	file:
STAT_SCOPE_INPUT_NAME	include/proto/dumpstats.h	53;"	d
STAT_SCOPE_PATTERN	include/proto/dumpstats.h	54;"	d
STAT_SCOPE_TXT_MAXLEN	include/proto/dumpstats.h	52;"	d
STAT_STATUS_DENY	include/types/proto_http.h	/^	STAT_STATUS_DENY,	\/* action denied *\/$/;"	e	enum:__anon63
STAT_STATUS_DONE	include/types/proto_http.h	/^	STAT_STATUS_DONE,	\/* the action is successful *\/$/;"	e	enum:__anon63
STAT_STATUS_ERRP	include/types/proto_http.h	/^	STAT_STATUS_ERRP,	\/* an error occured due to invalid values in parameters *\/$/;"	e	enum:__anon63
STAT_STATUS_EXCD	include/types/proto_http.h	/^	STAT_STATUS_EXCD,	\/* an error occured because the buffer couldn't store all data *\/$/;"	e	enum:__anon63
STAT_STATUS_INIT	include/types/proto_http.h	/^	STAT_STATUS_INIT = 0,$/;"	e	enum:__anon63
STAT_STATUS_NONE	include/types/proto_http.h	/^	STAT_STATUS_NONE,	\/* nothing happened (no action chosen or servers state didn't change) *\/$/;"	e	enum:__anon63
STAT_STATUS_PART	include/types/proto_http.h	/^	STAT_STATUS_PART,	\/* the action is partially successful *\/$/;"	e	enum:__anon63
STAT_STATUS_SIZE	include/types/proto_http.h	/^	STAT_STATUS_SIZE$/;"	e	enum:__anon63
STAT_STATUS_UNKN	include/types/proto_http.h	/^	STAT_STATUS_UNKN,	\/* an unknown error occured, shouldn't happen *\/$/;"	e	enum:__anon63
STAT_ST_END	src/dumpstats.c	/^	STAT_ST_END,$/;"	e	enum:__anon111	file:
STAT_ST_FIN	src/dumpstats.c	/^	STAT_ST_FIN,$/;"	e	enum:__anon111	file:
STAT_ST_HEAD	src/dumpstats.c	/^	STAT_ST_HEAD,$/;"	e	enum:__anon111	file:
STAT_ST_INFO	src/dumpstats.c	/^	STAT_ST_INFO,$/;"	e	enum:__anon111	file:
STAT_ST_INIT	src/dumpstats.c	/^	STAT_ST_INIT = 0,$/;"	e	enum:__anon111	file:
STAT_ST_LIST	src/dumpstats.c	/^	STAT_ST_LIST,$/;"	e	enum:__anon111	file:
STD_OP_EQ	include/common/standard.h	/^	STD_OP_EQ = 2, STD_OP_NE = 3,$/;"	e	enum:__anon103
STD_OP_GE	include/common/standard.h	/^	STD_OP_GE = 4, STD_OP_LT = 5,$/;"	e	enum:__anon103
STD_OP_GT	include/common/standard.h	/^	STD_OP_LE = 0, STD_OP_GT = 1,$/;"	e	enum:__anon103
STD_OP_LE	include/common/standard.h	/^	STD_OP_LE = 0, STD_OP_GT = 1,$/;"	e	enum:__anon103
STD_OP_LT	include/common/standard.h	/^	STD_OP_GE = 4, STD_OP_LT = 5,$/;"	e	enum:__anon103
STD_OP_NE	include/common/standard.h	/^	STD_OP_EQ = 2, STD_OP_NE = 3,$/;"	e	enum:__anon103
STD_T_FRQP	include/types/stick_table.h	/^	STD_T_FRQP,               \/* data is of type freq_ctr_period *\/$/;"	e	enum:__anon27
STD_T_SINT	include/types/stick_table.h	/^	STD_T_SINT = 0,           \/* data is of type signed int *\/$/;"	e	enum:__anon27
STD_T_UINT	include/types/stick_table.h	/^	STD_T_UINT,               \/* data is of type unsigned int *\/$/;"	e	enum:__anon27
STD_T_ULL	include/types/stick_table.h	/^	STD_T_ULL,                \/* data is of type unsigned long long *\/$/;"	e	enum:__anon27
STKCTR_TRACK_BACKEND	include/types/session.h	98;"	d
STKCTR_TRACK_CONTENT	include/types/session.h	99;"	d
STKTABLE_DATA_TYPES	include/types/stick_table.h	/^	STKTABLE_DATA_TYPES       \/* Number of data types, must always be last *\/$/;"	e	enum:__anon26
STKTABLE_DT_BYTES_IN_CNT	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_IN_CNT, \/* cumulated bytes count from client to servers *\/$/;"	e	enum:__anon26
STKTABLE_DT_BYTES_IN_RATE	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_IN_RATE,\/* bytes rate from client to servers *\/$/;"	e	enum:__anon26
STKTABLE_DT_BYTES_OUT_CNT	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_OUT_CNT,\/* cumulated bytes count from servers to client *\/$/;"	e	enum:__anon26
STKTABLE_DT_BYTES_OUT_RATE	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_OUT_RATE,\/* bytes rate from servers to client *\/$/;"	e	enum:__anon26
STKTABLE_DT_CONN_CNT	include/types/stick_table.h	/^	STKTABLE_DT_CONN_CNT,     \/* cumulated number of connections *\/$/;"	e	enum:__anon26
STKTABLE_DT_CONN_CUR	include/types/stick_table.h	/^	STKTABLE_DT_CONN_CUR,     \/* concurrent number of connections *\/$/;"	e	enum:__anon26
STKTABLE_DT_CONN_RATE	include/types/stick_table.h	/^	STKTABLE_DT_CONN_RATE,    \/* incoming connection rate *\/$/;"	e	enum:__anon26
STKTABLE_DT_GPC0	include/types/stick_table.h	/^	STKTABLE_DT_GPC0,         \/* General Purpose Counter 0 (unsigned 32-bit integer) *\/$/;"	e	enum:__anon26
STKTABLE_DT_GPC0_RATE	include/types/stick_table.h	/^	STKTABLE_DT_GPC0_RATE,    \/* General Purpose Counter 0's event rate *\/$/;"	e	enum:__anon26
STKTABLE_DT_HTTP_ERR_CNT	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_ERR_CNT, \/* cumulated number of HTTP requests errors (4xx) *\/$/;"	e	enum:__anon26
STKTABLE_DT_HTTP_ERR_RATE	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_ERR_RATE,\/* HTTP request error rate *\/$/;"	e	enum:__anon26
STKTABLE_DT_HTTP_REQ_CNT	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_REQ_CNT, \/* cumulated number of incoming HTTP requests *\/$/;"	e	enum:__anon26
STKTABLE_DT_HTTP_REQ_RATE	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_REQ_RATE,\/* incoming HTTP request rate *\/$/;"	e	enum:__anon26
STKTABLE_DT_SERVER_ID	include/types/stick_table.h	/^	STKTABLE_DT_SERVER_ID,    \/* the server ID to use with this session if > 0 *\/$/;"	e	enum:__anon26
STKTABLE_DT_SESS_CNT	include/types/stick_table.h	/^	STKTABLE_DT_SESS_CNT,     \/* cumulated number of sessions (accepted connections) *\/$/;"	e	enum:__anon26
STKTABLE_DT_SESS_RATE	include/types/stick_table.h	/^	STKTABLE_DT_SESS_RATE,    \/* accepted sessions rate *\/$/;"	e	enum:__anon26
STKTABLE_TYPES	include/types/stick_table.h	/^	STKTABLE_TYPES            \/* Number of types, must always be last *\/$/;"	e	enum:__anon25
STKTABLE_TYPE_BINARY	include/types/stick_table.h	/^	STKTABLE_TYPE_BINARY,     \/* table key is a buffer of data  *\/$/;"	e	enum:__anon25
STKTABLE_TYPE_INTEGER	include/types/stick_table.h	/^	STKTABLE_TYPE_INTEGER,    \/* table key is unsigned 32bit integer *\/$/;"	e	enum:__anon25
STKTABLE_TYPE_IP	include/types/stick_table.h	/^	STKTABLE_TYPE_IP = 0,     \/* table key is ipv4 *\/$/;"	e	enum:__anon25
STKTABLE_TYPE_IPV6	include/types/stick_table.h	/^	STKTABLE_TYPE_IPV6,       \/* table key is ipv6 *\/$/;"	e	enum:__anon25
STKTABLE_TYPE_STRING	include/types/stick_table.h	/^	STKTABLE_TYPE_STRING,     \/* table key is a null terminated string *\/$/;"	e	enum:__anon25
STK_F_CUSTOM_KEYSIZE	include/types/stick_table.h	116;"	d
STK_IS_MATCH	include/types/proxy.h	184;"	d
STK_IS_STORE	include/types/proxy.h	185;"	d
STK_ON_RSP	include/types/proxy.h	186;"	d
ST_ADM_ACTION_ADOWN	src/dumpstats.c	/^	ST_ADM_ACTION_ADOWN,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_ARUNN	src/dumpstats.c	/^	ST_ADM_ACTION_ARUNN,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_DAGENT	src/dumpstats.c	/^	ST_ADM_ACTION_DAGENT,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_DHLTH	src/dumpstats.c	/^	ST_ADM_ACTION_DHLTH,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_DISABLE	src/dumpstats.c	/^	ST_ADM_ACTION_DISABLE,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_DRAIN	src/dumpstats.c	/^	ST_ADM_ACTION_DRAIN,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_EAGENT	src/dumpstats.c	/^	ST_ADM_ACTION_EAGENT,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_EHLTH	src/dumpstats.c	/^	ST_ADM_ACTION_EHLTH,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_ENABLE	src/dumpstats.c	/^	ST_ADM_ACTION_ENABLE,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_HDOWN	src/dumpstats.c	/^	ST_ADM_ACTION_HDOWN,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_HNOLB	src/dumpstats.c	/^	ST_ADM_ACTION_HNOLB,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_HRUNN	src/dumpstats.c	/^	ST_ADM_ACTION_HRUNN,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_MAINT	src/dumpstats.c	/^	ST_ADM_ACTION_MAINT,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_NONE	src/dumpstats.c	/^	ST_ADM_ACTION_NONE = 0,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_READY	src/dumpstats.c	/^	ST_ADM_ACTION_READY,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_SHUTDOWN	src/dumpstats.c	/^	ST_ADM_ACTION_SHUTDOWN,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_START	src/dumpstats.c	/^	ST_ADM_ACTION_START,$/;"	e	enum:__anon110	file:
ST_ADM_ACTION_STOP	src/dumpstats.c	/^	ST_ADM_ACTION_STOP,$/;"	e	enum:__anon110	file:
ST_CONVDONE	include/common/uri_auth.h	33;"	d
ST_HIDEVER	include/common/uri_auth.h	29;"	d
ST_SHDESC	include/common/uri_auth.h	31;"	d
ST_SHLGNDS	include/common/uri_auth.h	32;"	d
ST_SHNODE	include/common/uri_auth.h	30;"	d
SUBVERS	Makefile	/^SUBVERS := $(shell (grep -v '\\$$Format' SUBVERS 2>\/dev\/null || touch SUBVERS) | head -n 1)$/;"	m
SUBVERS	Makefile	/^SUBVERS := $(shell comms=`git log --format=oneline --no-merges v$(VERSION).. 2>\/dev\/null | wc -l | tr -dc '0-9'`; [ $$comms -gt 0 ] && echo "-$$comms")$/;"	m
SYSLOG_PORT	include/types/log.h	34;"	d
SYS_ACCEPT4	include/common/syscall.h	140;"	d
SuperFastHash	tests/test_hashes.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f
SuperFastHash	tests/uri_hash.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f
SuperFastHash2	tests/test_hashes.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f
SuperFastHash2	tests/uri_hash.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f
TABLEMASK	include/common/sessionhash.h	21;"	d
TABLESHIFT	include/common/sessionhash.h	18;"	d
TABLESIZE	include/common/sessionhash.h	20;"	d
TARGET	Makefile	/^TARGET =$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS   = -D_MSGQSUPPORT$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS   = -Dss_family=__ss_family$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS  = $(if $(filter 1.5.%, $(shell uname -r)), -DUSE_IPV6 -DAF_INET6=23 -DINET6_ADDRSTRLEN=46, )$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT$/;"	m
TARGET_LDFLAGS	Makefile	/^  TARGET_LDFLAGS = -lnsl -lsocket$/;"	m
TASK_REASON_SHIFT	include/types/task.h	51;"	d
TASK_RUNNING	include/types/task.h	33;"	d
TASK_SLEEPING	include/types/task.h	32;"	d
TASK_WOKEN_ANY	include/types/task.h	43;"	d
TASK_WOKEN_INIT	include/types/task.h	34;"	d
TASK_WOKEN_IO	include/types/task.h	36;"	d
TASK_WOKEN_MSG	include/types/task.h	38;"	d
TASK_WOKEN_OTHER	include/types/task.h	40;"	d
TASK_WOKEN_RES	include/types/task.h	39;"	d
TASK_WOKEN_SIGNAL	include/types/task.h	37;"	d
TASK_WOKEN_TIMER	include/types/task.h	35;"	d
TBLCHKINT	include/common/appsession.h	7;"	d
TCP	examples/check	/^sub TCP$/;"	s
TCPCHK_ACT_CONNECT	include/types/checks.h	/^	TCPCHK_ACT_CONNECT,                     \/* connect action, to probe a new port *\/$/;"	e	enum:__anon40
TCPCHK_ACT_EXPECT	include/types/checks.h	/^	TCPCHK_ACT_EXPECT,                      \/* expect action, either regular or binary string *\/$/;"	e	enum:__anon40
TCPCHK_ACT_SEND	include/types/checks.h	/^	TCPCHK_ACT_SEND        = 0,             \/* send action, regular string format *\/$/;"	e	enum:__anon40
TCPCHK_OPT_NONE	include/types/checks.h	169;"	d
TCPCHK_OPT_SEND_PROXY	include/types/checks.h	170;"	d
TCPCHK_OPT_SSL	include/types/checks.h	171;"	d
TCP_ACT_ACCEPT	include/types/proto_tcp.h	/^	TCP_ACT_ACCEPT = 1,$/;"	e	enum:__anon1
TCP_ACT_CAPTURE	include/types/proto_tcp.h	/^	TCP_ACT_CAPTURE, \/* capture a fetched sample *\/$/;"	e	enum:__anon1
TCP_ACT_CLOSE	include/types/proto_tcp.h	/^	TCP_ACT_CLOSE, \/* close at the sender's *\/$/;"	e	enum:__anon1
TCP_ACT_EXPECT_PX	include/types/proto_tcp.h	/^	TCP_ACT_EXPECT_PX = 3,$/;"	e	enum:__anon1
TCP_ACT_REJECT	include/types/proto_tcp.h	/^	TCP_ACT_REJECT = 2,$/;"	e	enum:__anon1
TCP_ACT_TRK_SC0	include/types/proto_tcp.h	/^	TCP_ACT_TRK_SC0 = 4, \/* TCP request tracking : must be contiguous and cover up to MAX_SESS_STKCTR values *\/$/;"	e	enum:__anon1
TCP_ACT_TRK_SC1	include/types/proto_tcp.h	/^	TCP_ACT_TRK_SC1 = 5,$/;"	e	enum:__anon1
TCP_ACT_TRK_SC2	include/types/proto_tcp.h	/^	TCP_ACT_TRK_SC2 = 6,$/;"	e	enum:__anon1
TCP_ACT_TRK_SCMAX	include/types/proto_tcp.h	/^	TCP_ACT_TRK_SCMAX = TCP_ACT_TRK_SC0 + MAX_SESS_STKCTR - 1,$/;"	e	enum:__anon1
TCP_FASTOPEN	include/common/compat.h	128;"	d
TCP_NODELAY	include/common/compat.h	39;"	d
TERM_CODES_FIELD	contrib/halog/halog.c	34;"	d	file:
TICKS_TO_MS	include/common/ticks.h	64;"	d
TICK_ETERNITY	include/common/ticks.h	58;"	d
TIMER_LOOK_BACK	include/proto/task.h	78;"	d
TIME_ETERNITY	include/common/time.h	40;"	d
TIME_FIELD	contrib/halog/halog.c	31;"	d	file:
TIME_STATS_SAMPLES	include/common/defaults.h	230;"	d
TIME_UNIT_DAY	include/common/standard.h	534;"	d
TIME_UNIT_HOUR	include/common/standard.h	533;"	d
TIME_UNIT_MASK	include/common/standard.h	535;"	d
TIME_UNIT_MIN	include/common/standard.h	532;"	d
TIME_UNIT_MS	include/common/standard.h	530;"	d
TIME_UNIT_S	include/common/standard.h	531;"	d
TIME_UNIT_US	include/common/standard.h	529;"	d
TPROXY_ALLOC	include/import/ip_tproxy.h	/^	TPROXY_ALLOC,$/;"	e	enum:__anon107
TPROXY_ASSIGN	include/import/ip_tproxy.h	/^	TPROXY_ASSIGN,$/;"	e	enum:__anon107
TPROXY_CONNECT	include/import/ip_tproxy.h	/^	TPROXY_CONNECT$/;"	e	enum:__anon107
TPROXY_FLAGS	include/import/ip_tproxy.h	/^	TPROXY_FLAGS,$/;"	e	enum:__anon107
TPROXY_QUERY	include/import/ip_tproxy.h	/^	TPROXY_QUERY,$/;"	e	enum:__anon107
TPROXY_UNASSIGN	include/import/ip_tproxy.h	/^	TPROXY_UNASSIGN,$/;"	e	enum:__anon107
TPROXY_VERSION	include/import/ip_tproxy.h	/^	TPROXY_VERSION = 0,$/;"	e	enum:__anon107
TRACE	Makefile	/^TRACE =$/;"	m
TRACE	include/common/debug.h	48;"	d
TRACE_COPTS	Makefile	/^TRACE_COPTS := $(filter-out -O0 -O1 -O2 -pg -finstrument-functions,$(COPTS)) -O3 -fomit-frame-pointer$/;"	m
TV_ETERNITY	include/common/time.h	32;"	d
TV_ETERNITY_MS	include/common/time.h	37;"	d
TX_CACHEABLE	include/types/proto_http.h	65;"	d
TX_CACHE_COOK	include/types/proto_http.h	66;"	d
TX_CACHE_SHIFT	include/types/proto_http.h	67;"	d
TX_CK_DOWN	include/types/proto_http.h	44;"	d
TX_CK_EXPIRED	include/types/proto_http.h	46;"	d
TX_CK_INVALID	include/types/proto_http.h	43;"	d
TX_CK_MASK	include/types/proto_http.h	49;"	d
TX_CK_NONE	include/types/proto_http.h	42;"	d
TX_CK_OLD	include/types/proto_http.h	47;"	d
TX_CK_SHIFT	include/types/proto_http.h	50;"	d
TX_CK_UNUSED	include/types/proto_http.h	48;"	d
TX_CK_VALID	include/types/proto_http.h	45;"	d
TX_CLALLOW	include/types/proto_http.h	36;"	d
TX_CLDENY	include/types/proto_http.h	35;"	d
TX_CLTARPIT	include/types/proto_http.h	39;"	d
TX_CON_CLO_SET	include/types/proto_http.h	84;"	d
TX_CON_KAL_SET	include/types/proto_http.h	85;"	d
TX_CON_WANT_CLO	include/types/proto_http.h	81;"	d
TX_CON_WANT_KAL	include/types/proto_http.h	78;"	d
TX_CON_WANT_MSK	include/types/proto_http.h	82;"	d
TX_CON_WANT_SCL	include/types/proto_http.h	80;"	d
TX_CON_WANT_TUN	include/types/proto_http.h	79;"	d
TX_HDR_CONN_CLO	include/types/proto_http.h	93;"	d
TX_HDR_CONN_KAL	include/types/proto_http.h	94;"	d
TX_HDR_CONN_PRS	include/types/proto_http.h	92;"	d
TX_HDR_CONN_UPG	include/types/proto_http.h	89;"	d
TX_NOT_FIRST	include/types/proto_http.h	98;"	d
TX_PREFER_LAST	include/types/proto_http.h	87;"	d
TX_SCK_DELETED	include/types/proto_http.h	55;"	d
TX_SCK_FOUND	include/types/proto_http.h	54;"	d
TX_SCK_INSERTED	include/types/proto_http.h	56;"	d
TX_SCK_MASK	include/types/proto_http.h	59;"	d
TX_SCK_NONE	include/types/proto_http.h	53;"	d
TX_SCK_PRESENT	include/types/proto_http.h	62;"	d
TX_SCK_REPLACED	include/types/proto_http.h	57;"	d
TX_SCK_SHIFT	include/types/proto_http.h	60;"	d
TX_SCK_UPDATED	include/types/proto_http.h	58;"	d
TX_SVALLOW	include/types/proto_http.h	38;"	d
TX_SVDENY	include/types/proto_http.h	37;"	d
TX_USE_PX_CONN	include/types/proto_http.h	95;"	d
TX_WAIT_NEXT_RQ	include/types/proto_http.h	90;"	d
U2A	include/common/standard.h	/^static inline const char *U2A(unsigned long n)$/;"	f
U2H	include/common/standard.h	/^static inline const char *U2H(unsigned long long n)$/;"	f
UBOUND	include/common/standard.h	61;"	d
ULLONG_MAX	include/common/standard.h	42;"	d
UNIQUEID_LEN	include/types/log.h	35;"	d
UNIX_MAX_PATH	include/types/global.h	34;"	d
UPDATE_ANALYSERS	src/session.c	1614;"	d	file:
URL_FIELD	contrib/halog/halog.c	38;"	d	file:
USE_ACCEPT4	Makefile	/^  USE_ACCEPT4     = implicit$/;"	m
USE_CPU_AFFINITY	Makefile	/^  USE_CPU_AFFINITY= implicit$/;"	m
USE_CRYPT_H	Makefile	/^  USE_CRYPT_H     = implicit$/;"	m
USE_EPOLL	Makefile	/^  USE_EPOLL       = implicit$/;"	m
USE_FUTEX	Makefile	/^  USE_FUTEX       = implicit$/;"	m
USE_GETADDRINFO	Makefile	/^  USE_GETADDRINFO = implicit$/;"	m
USE_GETSOCKNAME	Makefile	/^  USE_GETSOCKNAME = implicit$/;"	m
USE_KQUEUE	Makefile	/^  USE_KQUEUE     = implicit$/;"	m
USE_LIBCRYPT	Makefile	/^  USE_LIBCRYPT    = implicit$/;"	m
USE_LIBCRYPT	Makefile	/^  USE_LIBCRYPT   = implicit$/;"	m
USE_LINUX_SPLICE	Makefile	/^  USE_LINUX_SPLICE= implicit$/;"	m
USE_LINUX_TPROXY	Makefile	/^  USE_LINUX_TPROXY= implicit$/;"	m
USE_MY_EPOLL	Makefile	/^  USE_MY_EPOLL    = implicit$/;"	m
USE_NETFILTER	Makefile	/^  USE_NETFILTER   = implicit$/;"	m
USE_PCRE	Makefile	/^USE_PCRE = 1$/;"	m
USE_POLL	Makefile	/^  USE_POLL        = implicit$/;"	m
USE_POLL	Makefile	/^  USE_POLL       = implicit$/;"	m
USE_POLL	Makefile	/^  USE_POLL   = implicit$/;"	m
USE_POLL	Makefile	/^USE_POLL   = default$/;"	m
USE_STATIC_PCRE	Makefile	/^USE_STATIC_PCRE = 1$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY      = implicit$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY     = implicit$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY = implicit$/;"	m
USE_TPROXY	Makefile	/^USE_TPROXY = 1$/;"	m
VAR_ARRAY	include/common/compiler.h	31;"	d
VAR_ARRAY	include/common/compiler.h	33;"	d
VERBOSE_CFLAGS	Makefile	/^VERBOSE_CFLAGS = $(CFLAGS) $(TARGET_CFLAGS) $(SMALL_OPTS) $(DEFINE)$/;"	m
VERDATE	Makefile	/^VERDATE := $(shell (grep -v '^\\$$Format' VERDATE 2>\/dev\/null || touch VERDATE) | head -n 1 | cut -f1 -d' ' | tr '-' '\/')$/;"	m
VERDATE	Makefile	/^VERDATE := $(shell git log -1 --pretty=format:%ci | cut -f1 -d' ' | tr '-' '\/')$/;"	m
VERSION	Makefile	/^VERSION := $(shell [ -d .git\/. ] && ref=`(git describe --tags --match 'v*' --abbrev=0) 2>\/dev\/null` && ref=$${ref%-g*} && echo "$${ref\\#v}")$/;"	m
VERSION	Makefile	/^VERSION := $(shell cat VERSION 2>\/dev\/null || touch VERSION)$/;"	m
WARN_BLOCK_DEPRECATED	include/types/global.h	182;"	d
WARN_CLITO_DEPRECATED	include/types/global.h	185;"	d
WARN_CONTO_DEPRECATED	include/types/global.h	187;"	d
WARN_REDISPATCH_DEPRECATED	include/types/global.h	184;"	d
WARN_REQSETBE_DEPRECATED	include/types/global.h	183;"	d
WARN_SRVTO_DEPRECATED	include/types/global.h	186;"	d
WRAPPER_OBJS	Makefile	/^WRAPPER_OBJS = src\/haproxy-systemd-wrapper.o$/;"	m
Warning	src/log.c	/^void Warning(const char *fmt, ...)$/;"	f
ZLIB_INC	Makefile	/^ZLIB_INC =$/;"	m
ZLIB_LIB	Makefile	/^ZLIB_LIB =$/;"	m
_COMMON_ACCEPT4_H	include/common/accept4.h	24;"	d
_COMMON_APPSESS_H	include/common/appsession.h	2;"	d
_COMMON_BASE64_H	include/common/base64.h	15;"	d
_COMMON_BUFFER_H	include/common/buffer.h	23;"	d
_COMMON_CFGPARSE_H	include/common/cfgparse.h	23;"	d
_COMMON_COMPAT_H	include/common/compat.h	23;"	d
_COMMON_COMPILER_H	include/common/compiler.h	23;"	d
_COMMON_CONFIG_H	include/common/config.h	23;"	d
_COMMON_DEBUG_H	include/common/debug.h	23;"	d
_COMMON_DEFAULTS_H	include/common/defaults.h	23;"	d
_COMMON_EPOLL_H	include/common/epoll.h	30;"	d
_COMMON_ERRORS_H	include/common/errors.h	23;"	d
_COMMON_HASH_H_	include/common/hash.h	23;"	d
_COMMON_MEMORY_H	include/common/memory.h	23;"	d
_COMMON_MINI_CLIST_H	include/common/mini-clist.h	8;"	d
_COMMON_REGEX_H	include/common/regex.h	23;"	d
_COMMON_SPLICE_H	include/common/splice.h	24;"	d
_COMMON_STANDARD_H	include/common/standard.h	23;"	d
_COMMON_SYSCALL_H	include/common/syscall.h	25;"	d
_COMMON_TEMPLATE_H	include/common/template.h	23;"	d
_COMMON_TICKS_H	include/common/ticks.h	53;"	d
_COMMON_TIME_H	include/common/time.h	23;"	d
_COMMON_TOOLS_H	include/common/tools.h	23;"	d
_COMMON_URI_AUTH_H	include/common/uri_auth.h	14;"	d
_COMMON_VERSION_H	include/common/version.h	23;"	d
_EB32TREE_H	ebtree/eb32tree.h	22;"	d
_EB64TREE_H	ebtree/eb64tree.h	22;"	d
_EBIMTREE_H	ebtree/ebimtree.h	22;"	d
_EBISTREE_H	ebtree/ebistree.h	24;"	d
_EBMBTREE_H	ebtree/ebmbtree.h	22;"	d
_EBPTTREE_H	ebtree/ebpttree.h	22;"	d
_EBSTTREE_H	ebtree/ebsttree.h	24;"	d
_EBTREE_H	ebtree/ebtree.h	247;"	d
_GNU_SOURCE	src/auth.c	15;"	d	file:
_GNU_SOURCE	src/listener.c	13;"	d	file:
_GNU_SOURCE	src/raw_sock.c	13;"	d	file:
_GNU_SOURCE	src/ssl_sock.c	25;"	d	file:
_IP_TPROXY_H	include/import/ip_tproxy.h	14;"	d
_LINUX_RBTREE_H	include/common/rbtree.h	95;"	d
_PROTO_ACL_H	include/proto/acl.h	23;"	d
_PROTO_ARG_H	include/proto/arg.h	23;"	d
_PROTO_AUTH_H	include/proto/auth.h	14;"	d
_PROTO_BACKEND_H	include/proto/backend.h	23;"	d
_PROTO_CHANNEL_H	include/proto/channel.h	23;"	d
_PROTO_CHECKS_H	include/proto/checks.h	23;"	d
_PROTO_COMP_H	include/proto/compression.h	24;"	d
_PROTO_CONNECTION_H	include/proto/connection.h	23;"	d
_PROTO_CTTPROXY_H	include/proto/cttproxy.h	24;"	d
_PROTO_DUMPSTATS_H	include/proto/dumpstats.h	24;"	d
_PROTO_FD_H	include/proto/fd.h	23;"	d
_PROTO_FREQ_CTR_H	include/proto/freq_ctr.h	23;"	d
_PROTO_FRONTEND_H	include/proto/frontend.h	23;"	d
_PROTO_HDR_IDX_H	include/proto/hdr_idx.h	23;"	d
_PROTO_LB_CHASH_H	include/proto/lb_chash.h	23;"	d
_PROTO_LB_FAS_H	include/proto/lb_fas.h	23;"	d
_PROTO_LB_FWLC_H	include/proto/lb_fwlc.h	23;"	d
_PROTO_LB_FWRR_H	include/proto/lb_fwrr.h	23;"	d
_PROTO_LB_MAP_H	include/proto/lb_map.h	23;"	d
_PROTO_LISTENER_H	include/proto/listener.h	23;"	d
_PROTO_LOG_H	include/proto/log.h	24;"	d
_PROTO_MAP_H	include/proto/map.h	23;"	d
_PROTO_OBJ_TYPE_H	include/proto/obj_type.h	23;"	d
_PROTO_PATTERN_H	include/proto/pattern.h	23;"	d
_PROTO_PEERS_H	include/proto/peers.h	23;"	d
_PROTO_PIPE_H	include/proto/pipe.h	23;"	d
_PROTO_PORT_RANGE_H	include/proto/port_range.h	23;"	d
_PROTO_PROTOCOL_H	include/proto/protocol.h	23;"	d
_PROTO_PROTO_HTTP_H	include/proto/proto_http.h	23;"	d
_PROTO_PROTO_PAYLOAD_H	include/proto/payload.h	23;"	d
_PROTO_PROTO_TCP_H	include/proto/proto_tcp.h	23;"	d
_PROTO_PROTO_UXST_H	include/proto/proto_uxst.h	23;"	d
_PROTO_PROXY_H	include/proto/proxy.h	23;"	d
_PROTO_QUEUE_H	include/proto/queue.h	23;"	d
_PROTO_RAW_SOCK_H	include/proto/raw_sock.h	23;"	d
_PROTO_SAMPLE_H	include/proto/sample.h	24;"	d
_PROTO_SERVER_H	include/proto/server.h	23;"	d
_PROTO_SESSION_H	include/proto/session.h	23;"	d
_PROTO_SSL_SOCK_H	include/proto/ssl_sock.h	23;"	d
_PROTO_STICK_TABLE_H	include/proto/stick_table.h	24;"	d
_PROTO_STREAM_INTERFACE_H	include/proto/stream_interface.h	23;"	d
_PROTO_TASK_H	include/proto/task.h	23;"	d
_PROTO_TEMPLATE_H	include/proto/template.h	23;"	d
_TYPES_ACL_H	include/types/acl.h	23;"	d
_TYPES_ARG_H	include/types/arg.h	23;"	d
_TYPES_AUTH_H	include/types/auth.h	14;"	d
_TYPES_BACKEND_H	include/types/backend.h	23;"	d
_TYPES_CAPTURE_H	include/types/capture.h	23;"	d
_TYPES_CHANNEL_H	include/types/channel.h	23;"	d
_TYPES_CHECKS_H	include/types/checks.h	14;"	d
_TYPES_CHUNK_H	include/common/chunk.h	23;"	d
_TYPES_COMP_H	include/types/compression.h	24;"	d
_TYPES_CONNECTION_H	include/types/connection.h	23;"	d
_TYPES_COUNTERS_H	include/types/counters.h	24;"	d
_TYPES_FD_H	include/types/fd.h	23;"	d
_TYPES_FREQ_CTR_H	include/types/freq_ctr.h	23;"	d
_TYPES_GLOBAL_H	include/types/global.h	23;"	d
_TYPES_HDR_IDX_H	include/types/hdr_idx.h	42;"	d
_TYPES_LB_CHASH_H	include/types/lb_chash.h	23;"	d
_TYPES_LB_FAS_H	include/types/lb_fas.h	23;"	d
_TYPES_LB_FWLC_H	include/types/lb_fwlc.h	23;"	d
_TYPES_LB_FWRR_H	include/types/lb_fwrr.h	23;"	d
_TYPES_LB_MAP_H	include/types/lb_map.h	23;"	d
_TYPES_LISTENER_H	include/types/listener.h	23;"	d
_TYPES_LOG_H	include/types/log.h	23;"	d
_TYPES_MAP_H	include/types/map.h	23;"	d
_TYPES_OBJ_TYPE_H	include/types/obj_type.h	23;"	d
_TYPES_PATTERN_H	include/types/pattern.h	23;"	d
_TYPES_PEERS_H	include/types/peers.h	23;"	d
_TYPES_PIPE_H	include/types/pipe.h	23;"	d
_TYPES_PORT_RANGE_H	include/types/port_range.h	23;"	d
_TYPES_PROTOCOL_H	include/types/protocol.h	23;"	d
_TYPES_PROTO_HTTP_H	include/types/proto_http.h	23;"	d
_TYPES_PROTO_TCP_H	include/types/proto_tcp.h	23;"	d
_TYPES_PROXY_H	include/types/proxy.h	23;"	d
_TYPES_QUEUE_H	include/types/queue.h	23;"	d
_TYPES_SAMPLE_H	include/types/sample.h	24;"	d
_TYPES_SERVER_H	include/types/server.h	23;"	d
_TYPES_SESSION_H	include/types/session.h	23;"	d
_TYPES_SIGNAL_H	include/types/signal.h	15;"	d
_TYPES_SSL_SOCK_H	include/types/ssl_sock.h	23;"	d
_TYPES_STICK_TABLE_H	include/types/stick_table.h	24;"	d
_TYPES_STREAM_INTERFACE_H	include/types/stream_interface.h	23;"	d
_TYPES_TASK_H	include/types/task.h	23;"	d
_TYPES_TEMPLATE_H	include/types/template.h	23;"	d
__NR_accept4	include/common/syscall.h	132;"	d
__NR_accept4	include/common/syscall.h	134;"	d
__NR_accept4	include/common/syscall.h	136;"	d
__NR_epoll_create	include/common/epoll.h	85;"	d
__NR_epoll_create	include/common/syscall.h	100;"	d
__NR_epoll_create	include/common/syscall.h	104;"	d
__NR_epoll_create	include/common/syscall.h	88;"	d
__NR_epoll_create	include/common/syscall.h	92;"	d
__NR_epoll_create	include/common/syscall.h	96;"	d
__NR_epoll_ctl	include/common/epoll.h	86;"	d
__NR_epoll_ctl	include/common/syscall.h	101;"	d
__NR_epoll_ctl	include/common/syscall.h	105;"	d
__NR_epoll_ctl	include/common/syscall.h	89;"	d
__NR_epoll_ctl	include/common/syscall.h	93;"	d
__NR_epoll_ctl	include/common/syscall.h	97;"	d
__NR_epoll_wait	include/common/epoll.h	87;"	d
__NR_epoll_wait	include/common/syscall.h	102;"	d
__NR_epoll_wait	include/common/syscall.h	106;"	d
__NR_epoll_wait	include/common/syscall.h	90;"	d
__NR_epoll_wait	include/common/syscall.h	94;"	d
__NR_epoll_wait	include/common/syscall.h	98;"	d
__NR_splice	include/common/splice.h	62;"	d
__NR_splice	include/common/syscall.h	115;"	d
__NR_splice	include/common/syscall.h	117;"	d
__NR_splice	include/common/syscall.h	119;"	d
__NR_splice	include/common/syscall.h	121;"	d
__NR_splice	include/common/syscall.h	123;"	d
__USE_GNU	src/haproxy.c	50;"	d	file:
__USE_GNU	src/haproxy.c	52;"	d	file:
__acl_init	src/acl.c	/^static void __acl_init(void)$/;"	f	file:
__backend_init	src/backend.c	/^static void __backend_init(void)$/;"	f	file:
__builtin_expect	include/common/compiler.h	89;"	d
__channel_forward	src/channel.c	/^unsigned long long __channel_forward(struct channel *chn, unsigned long long bytes)$/;"	f
__comp_fetch_init	src/compression.c	/^static void __comp_fetch_init(void)$/;"	f	file:
__conn_data_stop_both	include/proto/connection.h	/^static inline void __conn_data_stop_both(struct connection *c)$/;"	f
__conn_data_stop_recv	include/proto/connection.h	/^static inline void __conn_data_stop_recv(struct connection *c)$/;"	f
__conn_data_stop_send	include/proto/connection.h	/^static inline void __conn_data_stop_send(struct connection *c)$/;"	f
__conn_data_want_recv	include/proto/connection.h	/^static inline void __conn_data_want_recv(struct connection *c)$/;"	f
__conn_data_want_send	include/proto/connection.h	/^static inline void __conn_data_want_send(struct connection *c)$/;"	f
__conn_sock_stop_both	include/proto/connection.h	/^static inline void __conn_sock_stop_both(struct connection *c)$/;"	f
__conn_sock_stop_recv	include/proto/connection.h	/^static inline void __conn_sock_stop_recv(struct connection *c)$/;"	f
__conn_sock_stop_send	include/proto/connection.h	/^static inline void __conn_sock_stop_send(struct connection *c)$/;"	f
__conn_sock_want_recv	include/proto/connection.h	/^static inline void __conn_sock_want_recv(struct connection *c)$/;"	f
__conn_sock_want_send	include/proto/connection.h	/^static inline void __conn_sock_want_send(struct connection *c)$/;"	f
__cyg_profile_func_enter	src/trace.c	/^void __cyg_profile_func_enter(void *to,  void *from)$/;"	f
__cyg_profile_func_exit	src/trace.c	/^void __cyg_profile_func_exit(void *to,  void *from)$/;"	f
__dumpstats_module_init	src/dumpstats.c	/^static void __dumpstats_module_init(void)$/;"	f	file:
__eb32_delete	ebtree/eb32tree.h	/^static forceinline void __eb32_delete(struct eb32_node *eb32)$/;"	f
__eb32_insert	ebtree/eb32tree.h	/^__eb32_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f
__eb32_lookup	ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32_lookup(struct eb_root *root, u32 x)$/;"	f
__eb32i_insert	ebtree/eb32tree.h	/^__eb32i_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f
__eb32i_lookup	ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32i_lookup(struct eb_root *root, s32 x)$/;"	f
__eb64_delete	ebtree/eb64tree.h	/^static forceinline void __eb64_delete(struct eb64_node *eb64)$/;"	f
__eb64_insert	ebtree/eb64tree.h	/^__eb64_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f
__eb64_lookup	ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64_lookup(struct eb_root *root, u64 x)$/;"	f
__eb64i_insert	ebtree/eb64tree.h	/^__eb64i_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f
__eb64i_lookup	ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64i_lookup(struct eb_root *root, s64 x)$/;"	f
__eb_delete	ebtree/ebtree.h	/^static forceinline void __eb_delete(struct eb_node *node)$/;"	f
__eb_insert_dup	ebtree/ebtree.h	/^__eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f
__ebim_insert	ebtree/ebimtree.h	/^__ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f
__ebim_lookup	ebtree/ebimtree.h	/^__ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
__ebis_insert	ebtree/ebistree.h	/^__ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
__ebis_lookup	ebtree/ebistree.h	/^static forceinline struct ebpt_node *__ebis_lookup(struct eb_root *root, const void *x)$/;"	f
__ebmb_delete	ebtree/ebmbtree.h	/^static forceinline void __ebmb_delete(struct ebmb_node *ebmb)$/;"	f
__ebmb_insert	ebtree/ebmbtree.h	/^__ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
__ebmb_insert_prefix	ebtree/ebmbtree.h	/^__ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
__ebmb_lookup	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
__ebmb_lookup_longest	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f
__ebmb_lookup_prefix	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f
__ebpt_delete	ebtree/ebpttree.h	/^static forceinline void __ebpt_delete(struct ebpt_node *ebpt)$/;"	f
__ebpt_insert	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
__ebpt_lookup	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_lookup(struct eb_root *root, void *x)$/;"	f
__ebst_insert	ebtree/ebsttree.h	/^__ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f
__ebst_lookup	ebtree/ebsttree.h	/^static forceinline struct ebmb_node *__ebst_lookup(struct eb_root *root, const void *x)$/;"	f
__fd_clo	src/ev_epoll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clo	src/ev_poll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clo	src/ev_select.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__frontend_init	src/frontend.c	/^static void __frontend_init(void)$/;"	f	file:
__full_hash	include/common/standard.h	/^static inline unsigned int __full_hash(unsigned int a)$/;"	f
__health_adjust	src/checks.c	/^void __health_adjust(struct server *s, short status)$/;"	f
__http_protocol_init	src/proto_http.c	/^static void __http_protocol_init(void)$/;"	f	file:
__i386_linux_vsyscall_init	src/i386-linux-vsys.c	/^static void __i386_linux_vsyscall_init(void)$/;"	f	file:
__listener_init	src/listener.c	/^static void __listener_init(void)$/;"	f	file:
__listener_init	src/server.c	/^static void __listener_init(void)$/;"	f	file:
__map_init	src/map.c	/^static void __map_init(void)$/;"	f	file:
__objt_appctx	include/proto/obj_type.h	/^static inline struct appctx *__objt_appctx(enum obj_type *t)$/;"	f
__objt_applet	include/proto/obj_type.h	/^static inline struct si_applet *__objt_applet(enum obj_type *t)$/;"	f
__objt_conn	include/proto/obj_type.h	/^static inline struct connection *__objt_conn(enum obj_type *t)$/;"	f
__objt_listener	include/proto/obj_type.h	/^static inline struct listener *__objt_listener(enum obj_type *t)$/;"	f
__objt_proxy	include/proto/obj_type.h	/^static inline struct proxy *__objt_proxy(enum obj_type *t)$/;"	f
__objt_server	include/proto/obj_type.h	/^static inline struct server *__objt_server(enum obj_type *t)$/;"	f
__payload_init	src/payload.c	/^static void __payload_init(void)$/;"	f	file:
__pipe_module_init	src/pipe.c	/^static void __pipe_module_init(void)$/;"	f	file:
__proxy_module_init	src/proxy.c	/^static void __proxy_module_init(void)$/;"	f	file:
__rb_erase_color	src/rbtree.c	/^static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,$/;"	f	file:
__rb_rotate_left	src/rbtree.c	/^static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)$/;"	f	file:
__rb_rotate_right	src/rbtree.c	/^static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)$/;"	f	file:
__read_uint	include/common/standard.h	/^static inline unsigned int __read_uint(const char **s, const char *end)$/;"	f
__sample_init	src/sample.c	/^static void __sample_init(void)$/;"	f	file:
__send_log	src/log.c	/^void __send_log(struct proxy *p, int level, char *message, size_t size)$/;"	f
__session_init	src/session.c	/^static void __session_init(void)$/;"	f	file:
__signal_process_queue	src/signal.c	/^void __signal_process_queue()$/;"	f
__ssl_sock_init	src/ssl_sock.c	/^static void __ssl_sock_init(void)$/;"	f	file:
__str2ui	include/common/standard.h	/^static inline unsigned int __str2ui(const char *s)$/;"	f
__str2uic	include/common/standard.h	/^static inline unsigned int __str2uic(const char *s)$/;"	f
__strl2ui	contrib/halog/halog.c	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f	file:
__strl2ui	include/common/standard.h	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f
__strl2uic	include/common/standard.h	/^static inline unsigned int __strl2uic(const char *s, int len)$/;"	f
__task_queue	src/task.c	/^void __task_queue(struct task *task)$/;"	f
__task_unlink_rq	include/proto/task.h	/^static inline struct task *__task_unlink_rq(struct task *t)$/;"	f
__task_unlink_wq	include/proto/task.h	/^static inline struct task *__task_unlink_wq(struct task *t)$/;"	f
__task_wakeup	src/task.c	/^struct task *__task_wakeup(struct task *t)$/;"	f
__tcp_protocol_init	src/proto_tcp.c	/^static void __tcp_protocol_init(void)$/;"	f	file:
__tv_add	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
__tv_add2	include/common/time.h	/^REGPRM2 static inline struct timeval *__tv_add2(struct timeval *tv, const struct timeval *inc)$/;"	f
__tv_add_ifset	include/common/time.h	/^REGPRM3 static inline int __tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
__tv_cmp	include/common/time.h	/^REGPRM2 static inline int __tv_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_from_ms	include/common/time.h	/^REGPRM2 static inline struct timeval * __tv_from_ms(struct timeval *tv, unsigned long ms)$/;"	f
__tv_iseq	include/common/time.h	/^REGPRM2 static inline int __tv_iseq(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isge	include/common/time.h	/^REGPRM2 static inline int __tv_isge(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isgt	include/common/time.h	/^REGPRM2 static inline int __tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isle	include/common/time.h	/^REGPRM2 static inline int __tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_islt	include/common/time.h	/^REGPRM2 static inline int __tv_islt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_add	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f
__tv_ms_cmp	include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_cmp2	include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_elapsed	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_le2	include/common/time.h	/^REGPRM2 static inline int __tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_remain	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_remain2	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_remain	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
__tv_remain2	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
__tv_to_ms	include/common/time.h	/^REGPRM1 static inline unsigned long __tv_to_ms(const struct timeval *tv)$/;"	f
__usec_to_1024th	include/common/time.h	/^REGPRM1 static inline unsigned int __usec_to_1024th(unsigned int usec)$/;"	f
__uxst_protocol_init	src/proto_uxst.c	/^static void __uxst_protocol_init(void)$/;"	f	file:
_do_fork	src/ev_epoll.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_fork	src/ev_kqueue.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_init	src/ev_epoll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_init	src/ev_kqueue.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_init	src/ev_poll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_init	src/ev_select.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	src/ev_epoll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_poll	src/ev_kqueue.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_poll	src/ev_poll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_poll	src/ev_select.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	src/ev_epoll.c	/^static void _do_register(void)$/;"	f	file:
_do_register	src/ev_kqueue.c	/^static void _do_register(void)$/;"	f	file:
_do_register	src/ev_poll.c	/^static void _do_register(void)$/;"	f	file:
_do_register	src/ev_select.c	/^static void _do_register(void)$/;"	f	file:
_do_term	src/ev_epoll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_term	src/ev_kqueue.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_term	src/ev_poll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_term	src/ev_select.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	src/ev_epoll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_do_test	src/ev_kqueue.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_do_test	src/ev_poll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_do_test	src/ev_select.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_in_args	include/import/ip_tproxy.h	/^	union _in_args {$/;"	u	struct:in_tproxy
_shared_context_awakelocker	src/shctx.c	/^static inline void _shared_context_awakelocker(unsigned int *uaddr)$/;"	f	file:
_shared_context_awakelocker	src/shctx.c	131;"	d	file:
_shared_context_lock	src/shctx.c	/^static inline void _shared_context_lock(void)$/;"	f	file:
_shared_context_unlock	src/shctx.c	/^static inline void _shared_context_unlock(void)$/;"	f	file:
_shared_context_wait4lock	src/shctx.c	/^static inline void _shared_context_wait4lock(unsigned int *count, unsigned int *uaddr, int value)$/;"	f	file:
_syscall1	include/common/syscall.h	39;"	d
_syscall2	include/common/syscall.h	46;"	d
_syscall3	include/common/syscall.h	53;"	d
_syscall4	include/common/syscall.h	60;"	d
_syscall5	include/common/syscall.h	67;"	d
_syscall6	include/common/syscall.h	74;"	d
_tv_add	src/time.c	/^REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
_tv_add_ifset	src/time.c	/^REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
_tv_isgt	src/time.c	/^REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_isle	src/time.c	/^REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_add	src/time.c	/^REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f
_tv_ms_cmp	src/time.c	/^REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_cmp2	src/time.c	/^REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_elapsed	src/time.c	/^REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_le2	src/time.c	/^REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_remain	src/time.c	/^REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_remain2	src/time.c	/^REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_remain	src/time.c	/^REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
_tv_remain2	src/time.c	/^REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
a	include/types/sample.h	/^	void *a[8];     \/* any array of up to 8 pointers *\/$/;"	m	union:smp_ctx
a2base64	src/base64.c	/^int a2base64(char *in, int ilen, char *out, int olen)$/;"	f
a_and_b	contrib/ip6range/ip6range.c	/^static inline struct in6_addr *a_and_b(struct in6_addr *a, struct in6_addr *b, struct in6_addr *r)$/;"	f	file:
a_eq_b	contrib/ip6range/ip6range.c	/^static inline int a_eq_b(struct in6_addr *a, struct in6_addr *b)$/;"	f	file:
a_gt_b	contrib/ip6range/ip6range.c	/^static inline int a_gt_b(struct in6_addr *a, struct in6_addr *b)$/;"	f	file:
a_le_b	contrib/ip6range/ip6range.c	/^static inline int a_le_b(struct in6_addr *a, struct in6_addr *b)$/;"	f	file:
a_minus_b	contrib/ip6range/ip6range.c	/^static inline struct in6_addr *a_minus_b(struct in6_addr *a, struct in6_addr *b, struct in6_addr *r)$/;"	f	file:
a_plus_b	contrib/ip6range/ip6range.c	/^static inline struct in6_addr *a_plus_b(struct in6_addr *a, struct in6_addr *b, struct in6_addr *r)$/;"	f	file:
absmaxevents	src/ev_epoll.c	/^static int absmaxevents = 0;    \/\/ absolute maximum amounts of polled events$/;"	v	file:
accept	include/types/listener.h	/^	int (*accept)(struct listener *l, int fd, struct sockaddr_storage *addr); \/* upper layer's accept() *\/$/;"	m	struct:listener
accept	include/types/protocol.h	/^	int (*accept)(int fd);				\/* generic accept function *\/$/;"	m	struct:protocol
accept	include/types/proxy.h	/^	int (*accept)(struct session *s);       \/* application layer's accept() *\/$/;"	m	struct:proxy
accept4	include/common/accept4.h	/^static int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags)$/;"	f
accept_date	include/types/session.h	/^		struct timeval accept_date;	\/* date of the accept() in user date *\/$/;"	m	struct:session::__anon55	typeref:struct:session::__anon55::timeval
acl	include/types/acl.h	/^	struct acl *acl;            \/* acl pointed to by this term *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::acl
acl	include/types/acl.h	/^struct acl {$/;"	s
acl	include/types/proxy.h	/^	struct list acl;                        \/* ACL declared on this proxy *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
acl_cond	include/types/acl.h	/^struct acl_cond {$/;"	s
acl_cond_conflicts	src/acl.c	/^const struct acl *acl_cond_conflicts(const struct acl_cond *cond, unsigned int where)$/;"	f
acl_cond_kw_conflicts	src/acl.c	/^int acl_cond_kw_conflicts(const struct acl_cond *cond, unsigned int where, struct acl const **acl, char const **kw)$/;"	f
acl_cond_pol	include/types/acl.h	/^enum acl_cond_pol {$/;"	g
acl_exec_cond	src/acl.c	/^enum acl_test_res acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, unsigned int opt)$/;"	f
acl_expr	include/types/acl.h	/^struct acl_expr {$/;"	s
acl_find_targets	src/acl.c	/^int acl_find_targets(struct proxy *p)$/;"	f
acl_keyword	include/types/acl.h	/^struct acl_keyword {$/;"	s
acl_keywords	src/acl.c	/^static struct acl_kw_list acl_keywords = {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kw_list	include/types/acl.h	/^struct acl_kw_list {$/;"	s
acl_kws	src/acl.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/backend.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/compression.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/frontend.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/listener.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/payload.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/proto_http.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/proto_tcp.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/session.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/ssl_sock.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_neg	include/proto/acl.h	/^static inline enum acl_test_res acl_neg(enum acl_test_res res)$/;"	f
acl_pass	include/proto/acl.h	/^static inline int acl_pass(enum acl_test_res res)$/;"	f
acl_register_keywords	src/acl.c	/^void acl_register_keywords(struct acl_kw_list *kwl)$/;"	f
acl_term	include/types/acl.h	/^struct acl_term {$/;"	s
acl_term_suite	include/types/acl.h	/^struct acl_term_suite {$/;"	s
acl_test_res	include/types/acl.h	/^enum acl_test_res {$/;"	g
acl_unregister_keywords	src/acl.c	/^void acl_unregister_keywords(struct acl_kw_list *kwl)$/;"	f
act	include/types/lb_chash.h	/^	struct eb_root act;	\/* weighted chash entries of active servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root
act	include/types/lb_fas.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fas	typeref:struct:lb_fas::eb_root
act	include/types/lb_fwlc.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root
act	include/types/lb_fwrr.h	/^	struct fwrr_group act;	\/* weighted round robin on the active servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group
act_prm	include/types/proto_tcp.h	/^	} act_prm;$/;"	m	struct:tcp_rule	typeref:union:tcp_rule::__anon2
actconn	src/fd.c	/^int actconn;                    \/* # of active sessions *\/$/;"	v
actconns	include/types/server.h	/^	struct list actconns;			\/* active connections *\/$/;"	m	struct:server	typeref:struct:server::list
action	include/common/regex.h	/^    int action;				\/* ACT_ALLOW, ACT_REPLACE, ACT_REMOVE, ACT_DENY *\/$/;"	m	struct:hdr_exp
action	include/types/checks.h	/^	int action;                             \/* action: send or expect *\/$/;"	m	struct:tcpcheck_rule
action	include/types/proto_http.h	/^	unsigned int action;                   \/* HTTP_REQ_* *\/$/;"	m	struct:http_req_rule
action	include/types/proto_http.h	/^	unsigned int action;                   \/* HTTP_RES_* *\/$/;"	m	struct:http_res_rule
action	include/types/proto_tcp.h	/^	int action;$/;"	m	struct:tcp_rule
action_http_req_custom	src/proto_http.c	/^struct http_req_action_kw *action_http_req_custom(const char *kw)$/;"	f
action_http_res_custom	src/proto_http.c	/^struct http_res_action_kw *action_http_res_custom(const char *kw)$/;"	f
action_ptr	include/types/proto_http.h	/^	int (*action_ptr)(struct http_req_rule *rule, struct proxy *px, struct session *s, struct http_txn *http_txn);  \/* ptr to custom action *\/$/;"	m	struct:http_req_rule
action_ptr	include/types/proto_http.h	/^	int (*action_ptr)(struct http_res_rule *rule, struct proxy *px, struct session *s, struct http_txn *http_txn);  \/* ptr to custom action *\/$/;"	m	struct:http_res_rule
active	src/shctx.c	/^	struct shared_block active;$/;"	m	struct:shared_context	typeref:struct:shared_context::shared_block	file:
add_data	include/types/compression.h	/^	int (*add_data)(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out);$/;"	m	struct:comp_algo
add_sample_to_logformat_list	src/log.c	/^void add_sample_to_logformat_list(char *text, char *arg, int arg_len, struct proxy *curpx, struct list *list_format, int options, int cap, const char *file, int line)$/;"	f
add_to_logformat_list	src/log.c	/^void add_to_logformat_list(char *start, char *end, int type, struct list *list_format)$/;"	f
addr	include/import/ip_tproxy.h	/^		struct in_tproxy_addr	addr;$/;"	m	union:in_tproxy::_in_args	typeref:struct:in_tproxy::_in_args::in_tproxy_addr
addr	include/types/connection.h	/^	} addr; \/* addresses of the remote side, client for producer and server for consumer *\/$/;"	m	struct:connection	typeref:struct:connection::__anon80
addr	include/types/connection.h	/^	} addr;$/;"	m	struct:proxy_hdr_v2	typeref:union:proxy_hdr_v2::__anon81
addr	include/types/listener.h	/^	struct sockaddr_storage addr;	\/* the address we listen to *\/$/;"	m	struct:listener	typeref:struct:listener::sockaddr_storage
addr	include/types/log.h	/^	struct sockaddr_storage addr;$/;"	m	struct:logsrv	typeref:struct:logsrv::sockaddr_storage
addr	include/types/pattern.h	/^			struct in6_addr addr;$/;"	m	struct:pattern::__anon10::__anon13	typeref:struct:pattern::__anon10::__anon13::in6_addr
addr	include/types/pattern.h	/^			struct in_addr addr;$/;"	m	struct:pattern::__anon10::__anon12	typeref:struct:pattern::__anon10::__anon12::in_addr
addr	include/types/peers.h	/^	struct sockaddr_storage addr;  \/* peer address *\/$/;"	m	struct:peer	typeref:struct:peer::sockaddr_storage
addr	include/types/server.h	/^		struct sockaddr_storage addr;   \/* the address to check, if different from <addr> *\/$/;"	m	struct:server::__anon98	typeref:struct:server::__anon98::sockaddr_storage
addr	include/types/server.h	/^	struct sockaddr_storage addr;		\/* the address to connect to *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_storage
addr_to_stktable_key	include/proto/proto_tcp.h	/^static inline struct stktable_key *addr_to_stktable_key(struct sockaddr_storage *addr, long type)$/;"	f
addr_to_str	src/standard.c	/^int addr_to_str(struct sockaddr_storage *addr, char *str, int size)$/;"	f
admin	include/types/server.h	/^	enum srv_admin admin, prev_admin;       \/* server maintenance status : SRV_ADMF_* *\/$/;"	m	struct:server	typeref:enum:server::srv_admin
admin_rules	include/common/uri_auth.h	/^	struct list admin_rules;	\/* 'stats admin' rules (chained) *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list
after_poll	src/time.c	/^struct timeval after_poll;      \/* system date after leaving poll() *\/$/;"	v	typeref:struct:timeval
agent	include/types/server.h	/^	struct check agent;                     \/* agent specific configuration *\/$/;"	m	struct:server	typeref:struct:server::check
algo	include/types/backend.h	/^	int algo;			\/* load balancing algorithm and variants: BE_LB_* *\/$/;"	m	struct:lbprm
algos	include/types/compression.h	/^	struct comp_algo *algos;$/;"	m	struct:comp	typeref:struct:comp::comp_algo
alloc_stats_fe	src/dumpstats.c	/^static struct proxy *alloc_stats_fe(const char *name, const char *file, int line)$/;"	f	file:
alloc_trash_buffers	src/chunk.c	/^int alloc_trash_buffers(int bufsize)$/;"	f
alloc_zlib	src/compression.c	/^static void *alloc_zlib(void *opaque, unsigned int items, unsigned int size)$/;"	f	file:
allocated	include/common/memory.h	/^	unsigned int allocated;	\/* how many chunks have been allocated *\/$/;"	m	struct:pool_head
alltrim	include/common/standard.h	/^static inline char *alltrim(char *s, char c) {$/;"	f
alpn_len	include/types/listener.h	/^	int alpn_len;              \/* ALPN protocol string length *\/$/;"	m	struct:bind_conf
alpn_str	include/types/listener.h	/^	char *alpn_str;            \/* ALPN protocol string *\/$/;"	m	struct:bind_conf
already_warned	include/types/global.h	/^static inline int already_warned(unsigned int warning)$/;"	f
analyse_exp	include/types/channel.h	/^	int analyse_exp;                \/* expiration date for current analysers (if set) *\/$/;"	m	struct:channel
analysers	include/types/channel.h	/^	unsigned int analysers;         \/* bit field indicating what to do on the channel *\/$/;"	m	struct:channel
analysers	include/types/listener.h	/^	unsigned int analysers;		\/* bitmap of required protocol analysers *\/$/;"	m	struct:listener
analyze_status	include/types/checks.h	/^struct analyze_status {$/;"	s
analyze_statuses	src/checks.c	/^static const struct analyze_status analyze_statuses[HANA_STATUS_SIZE] = {		\/* 0: ignore, 1: error, 2: OK *\/$/;"	v	typeref:struct:analyze_status	file:
apools	src/appsession.c	/^struct app_pool apools;$/;"	v	typeref:struct:app_pool
app_pool	include/common/appsession.h	/^struct app_pool {$/;"	s
appctx	include/types/stream_interface.h	/^struct appctx {$/;"	s
appctx_free	include/proto/stream_interface.h	/^static inline void appctx_free(struct appctx *appctx)$/;"	f
appctx_init	include/proto/stream_interface.h	/^static inline void appctx_init(struct appctx *appctx)$/;"	f
appctx_new	include/proto/stream_interface.h	/^static inline struct appctx *appctx_new()$/;"	f
appctx_set_applet	include/proto/stream_interface.h	/^static inline void appctx_set_applet(struct appctx *appctx, struct si_applet *applet)$/;"	f
applet	include/types/stream_interface.h	/^	struct si_applet *applet;  \/* applet this context refers to *\/$/;"	m	struct:appctx	typeref:struct:appctx::si_applet
apply_filter_to_req_headers	src/proto_http.c	/^int apply_filter_to_req_headers(struct session *s, struct channel *req, struct hdr_exp *exp)$/;"	f
apply_filter_to_req_line	src/proto_http.c	/^int apply_filter_to_req_line(struct session *s, struct channel *req, struct hdr_exp *exp)$/;"	f
apply_filter_to_resp_headers	src/proto_http.c	/^int apply_filter_to_resp_headers(struct session *s, struct channel *rtr, struct hdr_exp *exp)$/;"	f
apply_filter_to_sts_line	src/proto_http.c	/^int apply_filter_to_sts_line(struct session *s, struct channel *rtr, struct hdr_exp *exp)$/;"	f
apply_filters_to_request	src/proto_http.c	/^int apply_filters_to_request(struct session *s, struct channel *req, struct proxy *px)$/;"	f
apply_filters_to_response	src/proto_http.c	/^int apply_filters_to_response(struct session *s, struct channel *rtr, struct proxy *px)$/;"	f
appsess	include/common/appsession.h	/^} appsess;$/;"	t	typeref:struct:appsessions
appsess_refresh	src/appsession.c	/^static struct task *appsess_refresh = NULL;$/;"	v	typeref:struct:task	file:
appsession	include/types/proxy.h	/^		int appsession;                 \/* appsession cookie expiration *\/$/;"	m	struct:proxy::__anon18
appsession_cleanup	src/appsession.c	/^void appsession_cleanup( void )$/;"	f
appsession_hash	include/common/sessionhash.h	/^struct appsession_hash$/;"	s
appsession_hash_destroy	src/sessionhash.c	/^void appsession_hash_destroy(struct appsession_hash *hash)$/;"	f
appsession_hash_dump	src/sessionhash.c	/^void appsession_hash_dump(struct appsession_hash *hash)$/;"	f
appsession_hash_f	src/sessionhash.c	/^unsigned int appsession_hash_f(char *ptr)$/;"	f
appsession_hash_init	src/sessionhash.c	/^int appsession_hash_init(struct appsession_hash *hash,$/;"	f
appsession_hash_insert	src/sessionhash.c	/^void appsession_hash_insert(struct appsession_hash *hash, appsess *session)$/;"	f
appsession_hash_lookup	src/sessionhash.c	/^appsess *appsession_hash_lookup(struct appsession_hash *hash, char *sessid)$/;"	f
appsession_hash_remove	src/sessionhash.c	/^void appsession_hash_remove(struct appsession_hash *hash, appsess *session)$/;"	f
appsession_init	src/appsession.c	/^int appsession_init(void)$/;"	f
appsession_len	include/types/proxy.h	/^	int  appsession_len;			\/* length of the appsession cookie value to be used *\/$/;"	m	struct:proxy
appsession_name	include/types/proxy.h	/^	char *appsession_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy
appsession_name_len	include/types/proxy.h	/^	int  appsession_name_len;		\/* strlen(appsession_name), computed only once *\/$/;"	m	struct:proxy
appsession_refresh	src/appsession.c	/^static struct task *appsession_refresh(struct task *t)$/;"	f	file:
appsession_task_init	src/appsession.c	/^int appsession_task_init(void)$/;"	f
appsessions	include/common/appsession.h	/^typedef struct appsessions {$/;"	s
arg	include/types/arg.h	/^	struct arg *arg;          \/* pointer to the arg, NULL on list head *\/$/;"	m	struct:arg_list	typeref:struct:arg_list::arg
arg	include/types/arg.h	/^struct arg {$/;"	s
arg	include/types/listener.h	/^	char *arg;                 \/* argument passed to "bind" for better error reporting *\/$/;"	m	struct:bind_conf
arg	include/types/log.h	/^	char *arg;     \/\/ text for LOG_FMT_TEXT, arg for others$/;"	m	struct:logformat_node
arg	include/types/proto_http.h	/^	} arg;                                 \/* arguments used by some actions *\/$/;"	m	struct:http_req_rule	typeref:union:http_req_rule::__anon67
arg	include/types/proto_http.h	/^	} arg;                                 \/* arguments used by some actions *\/$/;"	m	struct:http_res_rule	typeref:union:http_res_rule::__anon71
arg	include/types/signal.h	/^	int arg;                        \/* arg to pass to function, or signals*\/$/;"	m	struct:sig_handler
arg_data	include/types/arg.h	/^union arg_data {$/;"	u
arg_list	include/types/arg.h	/^struct arg_list {$/;"	s
arg_list_add	src/arg.c	/^struct arg_list *arg_list_add(struct arg_list *orig, struct arg *arg, int pos)$/;"	f
arg_list_clone	src/arg.c	/^struct arg_list *arg_list_clone(const struct arg_list *orig)$/;"	f
arg_mask	include/types/sample.h	/^	unsigned int arg_mask;                    \/* arguments (ARG*()) *\/$/;"	m	struct:sample_conv
arg_mask	include/types/sample.h	/^	unsigned int arg_mask;                    \/* arguments (ARG*()) *\/$/;"	m	struct:sample_fetch
arg_p	include/types/sample.h	/^	struct arg *arg_p;                        \/* optional arguments *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::arg
arg_p	include/types/sample.h	/^	struct arg *arg_p;                        \/* optional pointer to arguments to fetch function *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::arg
arg_pos	include/types/arg.h	/^	int arg_pos;              \/* argument position *\/$/;"	m	struct:arg_list
arg_type	include/types/stick_table.h	/^	int arg_type;     \/* type of optional argument, ARG_T_* *\/$/;"	m	struct:stktable_data_type
arg_type_names	src/arg.c	/^static const char *arg_type_names[ARGT_NBTYPES] = {$/;"	v	file:
args	include/types/proxy.h	/^		struct arg_list args;           \/* sample arg list that need to be resolved *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::arg_list
as_hash_for_each_entry_safe	include/common/sessionhash.h	58;"	d
assign_server	src/backend.c	/^int assign_server(struct session *s)$/;"	f
assign_server_address	src/backend.c	/^int assign_server_address(struct session *s)$/;"	f
assign_server_and_queue	src/backend.c	/^int assign_server_and_queue(struct session *s)$/;"	f
assign_tproxy_address	src/backend.c	/^static void assign_tproxy_address(struct session *s)$/;"	f	file:
atomic_dec	src/shctx.c	/^static inline unsigned char atomic_dec(unsigned int *ptr)$/;"	f	file:
auth	include/types/proto_http.h	/^		} auth;                        \/* arg used by "auth" *\/$/;"	m	union:http_req_rule::__anon67	typeref:struct:http_req_rule::__anon67::__anon68
auth	include/types/proto_http.h	/^	struct http_auth_data auth;	\/* HTTP auth data *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_auth_data
auth_find_userlist	src/auth.c	/^auth_find_userlist(char *name)$/;"	f
auth_groups	include/types/auth.h	/^struct auth_groups {$/;"	s
auth_groups_list	include/types/auth.h	/^struct auth_groups_list {$/;"	s
auth_realm	include/common/uri_auth.h	/^	char *auth_realm;		\/* the realm reported to the client *\/$/;"	m	struct:uri_auth
auth_users	include/types/auth.h	/^struct auth_users {$/;"	s
avail	include/types/port_range.h	/^	int avail;			\/* number of available ports left *\/$/;"	m	struct:port_range
b	ebtree/ebtree.h	/^	eb_troot_t    *b[EB_NODE_BRANCHES]; \/* left and right branches *\/$/;"	m	struct:eb_root
b64tos30	src/base64.c	/^int b64tos30(const char *in)$/;"	f
b:current_syntax	examples/haproxy.vim	/^let b:current_syntax = "haproxy"$/;"	v
b_adv	include/common/buffer.h	/^static inline void b_adv(struct buffer *b, unsigned int adv)$/;"	f
b_flags	include/types/proxy.h	/^	unsigned int b_flags;		\/* buffer flags *\/$/;"	m	struct:error_snapshot
b_out	include/types/proxy.h	/^	unsigned int b_out;		\/* pending output bytes *\/$/;"	m	struct:error_snapshot
b_ptr	include/common/buffer.h	61;"	d
b_rew	include/common/buffer.h	/^static inline void b_rew(struct buffer *b, unsigned int adv)$/;"	f
b_tot	include/types/proxy.h	/^	unsigned long long b_tot;	\/* total bytes transferred via this buffer *\/$/;"	m	struct:error_snapshot
b_wrap	include/types/proxy.h	/^	unsigned int b_wrap;		\/* position where the buffer is expected to wrap *\/$/;"	m	struct:error_snapshot
back_ebx	src/i386-linux-vsys.c	/^static __attribute__((used)) unsigned int back_ebx;$/;"	v	file:
back_refs	include/types/session.h	/^	struct list back_refs;			\/* list of users tracking this session *\/$/;"	m	struct:session	typeref:struct:session::list
backend	include/types/proxy.h	/^		struct proxy *backend;		\/* target backend *\/$/;"	m	union:switching_rule::__anon20	typeref:struct:switching_rule::__anon20::proxy
backend_lb_algo_str	src/backend.c	/^const char *backend_lb_algo_str(int algo) {$/;"	f
backend_parse_balance	src/backend.c	/^int backend_parse_balance(const char **args, char **err, struct proxy *curproxy)$/;"	f
backlog	include/types/listener.h	/^	unsigned int backlog;		\/* if set, listen backlog *\/$/;"	m	struct:listener
backlog	include/types/proxy.h	/^	unsigned int backlog;			\/* force the frontend's listen backlog *\/$/;"	m	struct:proxy
base	contrib/base64/base64rev-gen.c	18;"	d	file:
base64dec	src/base64.c	/^int base64dec(const char *in, size_t ilen, char *out, size_t olen) {$/;"	f
base64rev	contrib/base64/base64rev-gen.c	/^char base64rev[128];$/;"	v
base64rev	src/base64.c	/^const char base64rev[]="b###cXYZ[\\\\]^_`a###d###$%&'()*+,-.\/0123456789:;<=######>?@ABCDEFGHIJKLMNOPQRSTUVW";$/;"	v
base64tab	contrib/base64/base64rev-gen.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
base64tab	src/base64.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
bck	include/types/lb_chash.h	/^	struct eb_root bck;	\/* weighted chash entries of backup servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root
bck	include/types/lb_fas.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fas	typeref:struct:lb_fas::eb_root
bck	include/types/lb_fwlc.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root
bck	include/types/lb_fwrr.h	/^	struct fwrr_group bck;	\/* weighted round robin on the backup servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group
be	include/types/proxy.h	/^		struct proxy *be;		\/* default backend, or NULL if none set *\/$/;"	m	union:proxy::__anon15	typeref:struct:proxy::__anon15::proxy
be	include/types/proxy.h	/^	} be;$/;"	m	struct:switching_rule	typeref:union:switching_rule::__anon20
be	include/types/session.h	/^	struct proxy *be;			\/* the proxy this session depends on for the server side *\/$/;"	m	struct:session	typeref:struct:session::proxy
be_counters	include/types/proxy.h	/^	struct pxcounters be_counters;		\/* backend statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters
be_downtime	src/backend.c	/^int be_downtime(struct proxy *px) {$/;"	f
be_lastsession	src/backend.c	/^int be_lastsession(const struct proxy *be)$/;"	f
be_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
be_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
be_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr be_sess_per_sec;	\/* sessions per second on the backend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
be_set_sess_last	include/proto/backend.h	/^static void inline be_set_sess_last(struct proxy *be)$/;"	f
beconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy
before_poll	src/time.c	/^struct timeval before_poll;     \/* system date before calling poll() *\/$/;"	v	typeref:struct:timeval
bernstein	tests/test_hashes.c	/^ub4 bernstein(ub1 *key, ub4 len, ub4 level){$/;"	f
bi	include/types/checks.h	/^	struct buffer *bi, *bo;			\/* input and output buffers to send\/recv check *\/$/;"	m	struct:check	typeref:struct:check::buffer
bi_avail	include/proto/channel.h	/^static inline int bi_avail(const struct channel *chn)$/;"	f
bi_contig_data	include/common/buffer.h	/^static inline int bi_contig_data(const struct buffer *b)$/;"	f
bi_end	include/common/buffer.h	/^static inline char *bi_end(const struct buffer *b)$/;"	f
bi_erase	include/proto/channel.h	/^static inline void bi_erase(struct channel *chn)$/;"	f
bi_fast_delete	include/common/buffer.h	/^static inline void bi_fast_delete(struct buffer *buf, int n)$/;"	f
bi_ptr	include/common/buffer.h	/^static inline char *bi_ptr(const struct buffer *b)$/;"	f
bi_putblk	src/channel.c	/^int bi_putblk(struct channel *chn, const char *blk, int len)$/;"	f
bi_putchk	include/proto/channel.h	/^static inline int bi_putchk(struct channel *chn, struct chunk *chunk)$/;"	f
bi_putchr	src/channel.c	/^int bi_putchr(struct channel *chn, char c)$/;"	f
bi_putstr	include/proto/channel.h	/^static inline int bi_putstr(struct channel *chn, const char *str)$/;"	f
bind	include/types/protocol.h	/^	int (*bind)(struct listener *l, char *errmsg, int errlen); \/* bind a listener *\/$/;"	m	struct:protocol
bind	include/types/proxy.h	/^		struct list bind;		\/* list of bind settings *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::list
bind_all	include/types/protocol.h	/^	int (*bind_all)(struct protocol *proto, char *errmsg, int errlen); \/* bind all unbound listeners *\/$/;"	m	struct:protocol
bind_conf	include/types/listener.h	/^	struct bind_conf *bind_conf;	\/* "bind" line settings, include SSL settings among other things *\/$/;"	m	struct:listener	typeref:struct:listener::bind_conf
bind_conf	include/types/listener.h	/^struct bind_conf {$/;"	s
bind_conf_alloc	include/proto/listener.h	/^static inline struct bind_conf *bind_conf_alloc(struct list *lh, const char *file, int line, const char *arg)$/;"	f
bind_dump_kws	src/listener.c	/^void bind_dump_kws(char **out)$/;"	f
bind_find_kw	src/listener.c	/^struct bind_kw *bind_find_kw(const char *kw)$/;"	f
bind_hdr_len	include/types/connection.h	/^	int bind_hdr_len;                    \/* length of the name of the header above *\/$/;"	m	struct:conn_src
bind_hdr_name	include/types/connection.h	/^	char *bind_hdr_name;                 \/* bind to this header name if defined *\/$/;"	m	struct:conn_src
bind_hdr_occ	include/types/connection.h	/^	int bind_hdr_occ;                    \/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:conn_src
bind_keywords	src/listener.c	/^static struct bind_kw_list bind_keywords = {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kw	include/types/listener.h	/^struct bind_kw {$/;"	s
bind_kw_list	include/types/listener.h	/^struct bind_kw_list {$/;"	s
bind_kws	src/dumpstats.c	/^static struct bind_kw_list bind_kws = { "STAT", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	src/listener.c	/^static struct bind_kw_list bind_kws = { "ALL", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	src/proto_tcp.c	/^static struct bind_kw_list bind_kws = { "TCP", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	src/proto_uxst.c	/^static struct bind_kw_list bind_kws = { "UNIX", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	src/ssl_sock.c	/^static struct bind_kw_list bind_kws = { "SSL", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_parse_accept_proxy	src/listener.c	/^static int bind_parse_accept_proxy(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_alpn	src/ssl_sock.c	/^static int bind_parse_alpn(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_backlog	src/listener.c	/^static int bind_parse_backlog(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ca_file	src/ssl_sock.c	/^static int bind_parse_ca_file(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ciphers	src/ssl_sock.c	/^static int bind_parse_ciphers(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_crl_file	src/ssl_sock.c	/^static int bind_parse_crl_file(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_crt	src/ssl_sock.c	/^static int bind_parse_crt(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_crt_list	src/ssl_sock.c	/^static int bind_parse_crt_list(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_defer_accept	src/proto_tcp.c	/^static int bind_parse_defer_accept(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ecdhe	src/ssl_sock.c	/^static int bind_parse_ecdhe(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_sslv3	src/ssl_sock.c	/^static int bind_parse_force_sslv3(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_tlsv10	src/ssl_sock.c	/^static int bind_parse_force_tlsv10(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_tlsv11	src/ssl_sock.c	/^static int bind_parse_force_tlsv11(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_tlsv12	src/ssl_sock.c	/^static int bind_parse_force_tlsv12(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_gid	src/proto_uxst.c	/^static int bind_parse_gid(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_group	src/proto_uxst.c	/^static int bind_parse_group(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_id	src/listener.c	/^static int bind_parse_id(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ignore_err	src/ssl_sock.c	/^static int bind_parse_ignore_err(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_interface	src/proto_tcp.c	/^static int bind_parse_interface(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_level	src/dumpstats.c	/^static int bind_parse_level(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_maxconn	src/listener.c	/^static int bind_parse_maxconn(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_mode	src/proto_uxst.c	/^static int bind_parse_mode(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_mss	src/proto_tcp.c	/^static int bind_parse_mss(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_name	src/listener.c	/^static int bind_parse_name(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_nice	src/listener.c	/^static int bind_parse_nice(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_sslv3	src/ssl_sock.c	/^static int bind_parse_no_sslv3(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tls_tickets	src/ssl_sock.c	/^static int bind_parse_no_tls_tickets(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tlsv10	src/ssl_sock.c	/^static int bind_parse_no_tlsv10(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tlsv11	src/ssl_sock.c	/^static int bind_parse_no_tlsv11(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tlsv12	src/ssl_sock.c	/^static int bind_parse_no_tlsv12(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_npn	src/ssl_sock.c	/^static int bind_parse_npn(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_process	src/listener.c	/^static int bind_parse_process(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ssl	src/ssl_sock.c	/^static int bind_parse_ssl(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_strict_sni	src/ssl_sock.c	/^static int bind_parse_strict_sni(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_tfo	src/proto_tcp.c	/^static int bind_parse_tfo(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_transparent	src/proto_tcp.c	/^static int bind_parse_transparent(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_uid	src/proto_uxst.c	/^static int bind_parse_uid(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_user	src/proto_uxst.c	/^static int bind_parse_user(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_v4v6	src/proto_tcp.c	/^static int bind_parse_v4v6(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_v6only	src/proto_tcp.c	/^static int bind_parse_v6only(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_verify	src/ssl_sock.c	/^static int bind_parse_verify(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_proc	include/types/listener.h	/^	unsigned long bind_proc;   \/* bitmask of processes allowed to use these listeners *\/$/;"	m	struct:bind_conf
bind_proc	include/types/proxy.h	/^	unsigned long bind_proc;		\/* bitmask of processes using this proxy *\/$/;"	m	struct:proxy
bind_register_keywords	src/listener.c	/^void bind_register_keywords(struct bind_kw_list *kwl)$/;"	f
bit	ebtree/ebtree.h	/^	short int      bit;     \/* link's bit position. *\/$/;"	m	struct:eb_node
block_rules	include/types/proxy.h	/^	struct list block_rules;                \/* http-request block rules to be inserted before other ones *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
blocked_sig	src/signal.c	/^sigset_t blocked_sig;$/;"	v
bo	include/types/checks.h	/^	struct buffer *bi, *bo;			\/* input and output buffers to send\/recv check *\/$/;"	m	struct:check	typeref:struct:check::
bo_contig_data	include/common/buffer.h	/^static inline int bo_contig_data(const struct buffer *b)$/;"	f
bo_end	include/common/buffer.h	/^static inline char *bo_end(const struct buffer *b)$/;"	f
bo_getblk	src/channel.c	/^int bo_getblk(struct channel *chn, char *blk, int len, int offset)$/;"	f
bo_getchr	include/proto/channel.h	/^static inline int bo_getchr(struct channel *chn)$/;"	f
bo_getline	src/channel.c	/^int bo_getline(struct channel *chn, char *str, int len)$/;"	f
bo_inject	src/channel.c	/^int bo_inject(struct channel *chn, const char *msg, int len)$/;"	f
bo_ptr	include/common/buffer.h	/^static inline char *bo_ptr(const struct buffer *b)$/;"	f
bo_putblk	include/common/buffer.h	/^static inline void bo_putblk(struct buffer *b, const char *blk, int len)$/;"	f
bo_putchk	include/common/buffer.h	/^static inline void bo_putchk(struct buffer *b, const struct chunk *chk)$/;"	f
bo_putchr	include/common/buffer.h	/^static inline void bo_putchr(struct buffer *b, char c)$/;"	f
bo_putstr	include/common/buffer.h	/^static inline void bo_putstr(struct buffer *b, const char *str)$/;"	f
bo_skip	include/proto/channel.h	/^static inline void bo_skip(struct channel *chn, int len)$/;"	f
body_len	include/types/proto_http.h	/^	unsigned long long body_len;           \/* total known length of the body, excluding encoding *\/$/;"	m	struct:http_msg
bol	include/types/stream_interface.h	/^			int bol;		\/* pointer to beginning of current line *\/$/;"	m	struct:appctx::__anon43::__anon46
branches	ebtree/ebtree.h	/^	struct eb_root branches; \/* branches, must be at the beginning *\/$/;"	m	struct:eb_node	typeref:struct:eb_node::eb_root
bref	include/common/mini-clist.h	/^struct bref {$/;"	s
bref	include/types/stream_interface.h	/^			struct bref bref;	\/* back-reference from the session being dumped *\/$/;"	m	struct:appctx::__anon43::__anon45	typeref:struct:appctx::__anon43::__anon45::bref
buf	include/types/channel.h	/^	struct buffer *buf;		\/* buffer attached to the channel, always present but may move *\/$/;"	m	struct:channel	typeref:struct:channel::buffer
buf	include/types/proxy.h	/^	char buf[BUFSIZE];		\/* copy of the beginning of the message *\/$/;"	m	struct:error_snapshot
buf	include/types/stick_table.h	/^	char buf[0];              \/* dynamically allocated, used to store a null terminated string key or a buffer of data *\/$/;"	m	union:stktable_key_data
buf	include/types/stream_interface.h	/^			unsigned int buf;	\/* buffer being dumped, 0 = req, 1 = rep *\/$/;"	m	struct:appctx::__anon43::__anon46
buf2ip	src/standard.c	/^int buf2ip(const char *buf, size_t len, struct in_addr *dst)$/;"	f
buf2ip6	src/standard.c	/^int buf2ip6(const char *buf, size_t len, struct in6_addr *dst)$/;"	f
buffer	include/common/buffer.h	/^struct buffer {$/;"	s
buffer_almost_full	include/common/buffer.h	/^static inline int buffer_almost_full(const struct buffer *buf)$/;"	f
buffer_bounce_realign	src/buffer.c	/^void buffer_bounce_realign(struct buffer *buf)$/;"	f
buffer_contig_area	include/common/buffer.h	/^static inline int buffer_contig_area(const struct buffer *buf, const char *start, int count)$/;"	f
buffer_contig_space	include/common/buffer.h	/^static inline int buffer_contig_space(const struct buffer *buf)$/;"	f
buffer_count	include/common/buffer.h	/^static inline int buffer_count(const struct buffer *buf, const char *from, const char *to)$/;"	f
buffer_dump	src/buffer.c	/^void buffer_dump(FILE *o, struct buffer *b, int from, int to)$/;"	f
buffer_empty	include/common/buffer.h	/^static inline int buffer_empty(const struct buffer *buf)$/;"	f
buffer_flush	include/common/buffer.h	/^static inline void buffer_flush(struct buffer *buf)$/;"	f
buffer_full	include/common/buffer.h	/^static inline int buffer_full(const struct buffer *b, unsigned int reserve)$/;"	f
buffer_insert_line2	src/buffer.c	/^int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len)$/;"	f
buffer_len	include/common/buffer.h	/^static inline int buffer_len(const struct buffer *buf)$/;"	f
buffer_max_len	include/proto/channel.h	/^static inline int buffer_max_len(const struct channel *chn)$/;"	f
buffer_not_empty	include/common/buffer.h	/^static inline int buffer_not_empty(const struct buffer *buf)$/;"	f
buffer_pending	include/common/buffer.h	/^static inline int buffer_pending(const struct buffer *buf)$/;"	f
buffer_pointer	include/common/buffer.h	/^static inline const char *buffer_pointer(const struct buffer *buf, const char *ptr)$/;"	f
buffer_realign	include/common/buffer.h	/^static inline int buffer_realign(struct buffer *buf)$/;"	f
buffer_replace	include/common/buffer.h	/^static inline int buffer_replace(struct buffer *b, char *pos, char *end, const char *str)$/;"	f
buffer_replace2	src/buffer.c	/^int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len)$/;"	f
buffer_reserved	include/proto/channel.h	/^static inline int buffer_reserved(const struct channel *chn)$/;"	f
buffer_slow_realign	src/buffer.c	/^void buffer_slow_realign(struct buffer *buf)$/;"	f
buffer_total_space	include/common/buffer.h	/^static inline int buffer_total_space(const struct buffer *buf)$/;"	f
buffer_work_area	include/common/buffer.h	/^static inline int buffer_work_area(const struct buffer *buf, const char *end)$/;"	f
buffer_wrap_add	include/common/buffer.h	/^static inline char *buffer_wrap_add(const struct buffer *buf, char *ptr)$/;"	f
buffer_wrap_sub	include/common/buffer.h	/^static inline char *buffer_wrap_sub(const struct buffer *buf, char *ptr)$/;"	f
bufsize	include/types/global.h	/^		int bufsize;       \/* buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon95
build_acl_cond	src/acl.c	/^struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args, char **err)$/;"	f
build_logline	src/log.c	/^int build_logline(struct session *s, char *dst, size_t maxsize, struct list *list_format)$/;"	f
by_bind	include/types/listener.h	/^	struct list by_bind;            \/* chaining in bind_conf's list of listeners *\/$/;"	m	struct:listener	typeref:struct:listener::list
by_fe	include/types/listener.h	/^	struct list by_fe;              \/* chaining in frontend's list of listeners *\/$/;"	m	struct:listener	typeref:struct:listener::list
by_fe	include/types/listener.h	/^	struct list by_fe;         \/* next binding for the same frontend, or NULL *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::list
by_name	include/types/proxy.h	/^		struct ebpt_node by_name;       \/* proxies are stored sorted by name here *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::ebpt_node
by_srv	include/types/session.h	/^	struct list by_srv;			\/* position in server session list *\/$/;"	m	struct:session	typeref:struct:session::list
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:licounters
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:srvcounters
bytes_in	include/types/counters.h	/^	long long bytes_in;                     \/* number of bytes transferred from the client to the server *\/$/;"	m	struct:pxcounters
bytes_in	include/types/session.h	/^		long long bytes_in;		\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:session::__anon55
bytes_in_cnt	include/types/stick_table.h	/^	unsigned long long bytes_in_cnt;$/;"	m	union:stktable_data
bytes_in_rate	include/types/stick_table.h	/^	struct freq_ctr_period bytes_in_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:licounters
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:srvcounters
bytes_out	include/types/counters.h	/^	long long bytes_out;                    \/* number of bytes transferred from the server to the client *\/$/;"	m	struct:pxcounters
bytes_out	include/types/session.h	/^		long long bytes_out;		\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:session::__anon55
bytes_out_cnt	include/types/stick_table.h	/^	unsigned long long bytes_out_cnt;$/;"	m	union:stktable_data
bytes_out_rate	include/types/stick_table.h	/^	struct freq_ctr_period bytes_out_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
c	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon64::__anon66
c_bin2str	src/sample.c	/^static int c_bin2str(struct sample *smp)$/;"	f	file:
c_int2ip	src/sample.c	/^static int c_int2ip(struct sample *smp)$/;"	f	file:
c_int2str	src/sample.c	/^static int c_int2str(struct sample *smp)$/;"	f	file:
c_ip2int	src/sample.c	/^static int c_ip2int(struct sample *smp)$/;"	f	file:
c_ip2ipv6	src/sample.c	/^static int c_ip2ipv6(struct sample *smp)$/;"	f	file:
c_ip2str	src/sample.c	/^static int c_ip2str(struct sample *smp)$/;"	f	file:
c_ipv62str	src/sample.c	/^static int c_ipv62str(struct sample *smp)$/;"	f	file:
c_l	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon64::__anon66
c_meth2str	src/sample.c	/^static int c_meth2str(struct sample *smp)$/;"	f	file:
c_none	src/sample.c	/^int c_none(struct sample *smp)$/;"	f
c_str2addr	src/sample.c	/^static int c_str2addr(struct sample *smp)$/;"	f	file:
c_str2int	src/sample.c	/^static int c_str2int(struct sample *smp)$/;"	f	file:
c_str2ip	src/sample.c	/^static int c_str2ip(struct sample *smp)$/;"	f	file:
c_str2ipv6	src/sample.c	/^static int c_str2ipv6(struct sample *smp)$/;"	f	file:
c_str2meth	src/sample.c	/^static int c_str2meth(struct sample *smp)$/;"	f	file:
c_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
c_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
ca_base	include/types/global.h	/^	char *ca_base;              \/* base directory path for CAs and CRLs *\/$/;"	m	struct:global
ca_file	include/types/listener.h	/^	char *ca_file;             \/* CAfile to use on verify *\/$/;"	m	struct:bind_conf
ca_file	include/types/server.h	/^		char *ca_file;			\/* CAfile to use on verify *\/$/;"	m	struct:server::__anon99
ca_ignerr	include/types/listener.h	/^	unsigned long long ca_ignerr;  \/* ignored verify errors in handshake if depth > 0 *\/$/;"	m	struct:bind_conf
cache	include/types/fd.h	/^	unsigned int  cache;                 \/* position+1 in the FD cache. 0=not in cache. *\/$/;"	m	struct:fdtab
cache_idx	include/types/acl.h	/^	int cache_idx;              \/* ACL index in cache *\/$/;"	m	struct:acl
caddr_clr_flags	include/common/standard.h	/^static inline unsigned long caddr_clr_flags(unsigned long caddr, unsigned int data)$/;"	f
caddr_from_ptr	include/common/standard.h	/^static inline unsigned long caddr_from_ptr(void *ptr, unsigned int data)$/;"	f
caddr_set_flags	include/common/standard.h	/^static inline unsigned long caddr_set_flags(unsigned long caddr, unsigned int data)$/;"	f
caddr_to_data	include/common/standard.h	/^static inline unsigned int caddr_to_data(unsigned long caddr)$/;"	f
caddr_to_ptr	include/common/standard.h	/^static inline void *caddr_to_ptr(unsigned long caddr)$/;"	f
calls	include/types/task.h	/^	unsigned int calls;		\/* number of times ->process() was called *\/$/;"	m	struct:task
cap	include/types/proto_http.h	/^	char **cap;                            \/* array of captured headers (may be NULL) *\/$/;"	m	struct:http_msg
cap	include/types/proto_tcp.h	/^		struct capture_prm cap;$/;"	m	union:tcp_rule::__anon2	typeref:struct:tcp_rule::__anon2::capture_prm
cap	include/types/proxy.h	/^	char cap;                               \/* supported capabilities (PR_CAP_*) *\/$/;"	m	struct:proxy
cap	src/cfgparse.c	/^	unsigned int cap;$/;"	m	struct:cfg_opt	file:
cap_hdr	include/types/capture.h	/^struct cap_hdr {$/;"	s
capture_headers	src/proto_http.c	/^void capture_headers(char *som, struct hdr_idx *idx,$/;"	f
capture_len	include/types/proxy.h	/^	int  capture_len;			\/* length of the string to be captured *\/$/;"	m	struct:proxy
capture_name	include/types/proxy.h	/^	char *capture_name;			\/* beginning of the name of the cookie to capture *\/$/;"	m	struct:proxy
capture_namelen	include/types/proxy.h	/^	int  capture_namelen;			\/* length of the cookie name to match *\/$/;"	m	struct:proxy
capture_prm	include/types/proto_tcp.h	/^struct capture_prm {$/;"	s
cert_ocsp_tree	src/ssl_sock.c	/^static struct eb_root cert_ocsp_tree;$/;"	v	typeref:struct:eb_root	file:
certificate_ocsp	src/ssl_sock.c	/^struct certificate_ocsp {$/;"	s	file:
cfg_cfgfiles	src/haproxy.c	/^static struct list cfg_cfgfiles = LIST_HEAD_INIT(cfg_cfgfiles);$/;"	v	typeref:struct:list	file:
cfg_keyword	include/common/cfgparse.h	/^struct cfg_keyword {$/;"	s
cfg_keywords	src/cfgparse.c	/^static struct cfg_kw_list cfg_keywords = {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kw_list	include/common/cfgparse.h	/^struct cfg_kw_list {$/;"	s
cfg_kws	src/dumpstats.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	src/proto_tcp.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	src/proxy.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_maxconn	src/cfgparse.c	/^int cfg_maxconn = 0;			\/* # of simultaneous connections, (-n) *\/$/;"	v
cfg_maxpconn	src/cfgparse.c	/^int cfg_maxpconn = DEFAULT_MAXCONN;	\/* # of simultaneous connections per proxy (-N) *\/$/;"	v
cfg_opt	src/cfgparse.c	/^struct cfg_opt {$/;"	s	file:
cfg_opts	src/cfgparse.c	/^static const struct cfg_opt cfg_opts[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_opts2	src/cfgparse.c	/^static const struct cfg_opt cfg_opts2[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_parse_global	src/cfgparse.c	/^int cfg_parse_global(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_listen	src/cfgparse.c	/^int cfg_parse_listen(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_peers	src/cfgparse.c	/^int cfg_parse_peers(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_users	src/cfgparse.c	/^cfg_parse_users(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_register_keywords	src/cfgparse.c	/^void cfg_register_keywords(struct cfg_kw_list *kwl)$/;"	f
cfg_register_section	src/cfgparse.c	/^int cfg_register_section(char *section_name,$/;"	f
cfg_section	src/cfgparse.c	/^struct cfg_section {$/;"	s	file:
cfg_unregister_keywords	src/cfgparse.c	/^void cfg_unregister_keywords(struct cfg_kw_list *kwl)$/;"	f
chain_regex	src/regex.c	/^const char *chain_regex(struct hdr_exp **head, struct my_regex *preg,$/;"	f
channel	include/types/channel.h	/^struct channel {$/;"	s
channel_abort	include/proto/channel.h	/^static inline void channel_abort(struct channel *chn)$/;"	f
channel_auto_close	include/proto/channel.h	/^static inline void channel_auto_close(struct channel *chn)$/;"	f
channel_auto_connect	include/proto/channel.h	/^static inline void channel_auto_connect(struct channel *chn)$/;"	f
channel_auto_read	include/proto/channel.h	/^static inline void channel_auto_read(struct channel *chn)$/;"	f
channel_check_timeouts	include/proto/channel.h	/^static inline void channel_check_timeouts(struct channel *chn)$/;"	f
channel_dont_close	include/proto/channel.h	/^static inline void channel_dont_close(struct channel *chn)$/;"	f
channel_dont_connect	include/proto/channel.h	/^static inline void channel_dont_connect(struct channel *chn)$/;"	f
channel_dont_read	include/proto/channel.h	/^static inline void channel_dont_read(struct channel *chn)$/;"	f
channel_erase	include/proto/channel.h	/^static inline void channel_erase(struct channel *chn)$/;"	f
channel_forward	include/proto/channel.h	/^static inline unsigned long long channel_forward(struct channel *chn, unsigned long long bytes)$/;"	f
channel_full	include/proto/channel.h	/^static inline int channel_full(const struct channel *chn)$/;"	f
channel_init	include/proto/channel.h	/^static inline void channel_init(struct channel *chn)$/;"	f
channel_input_closed	include/proto/channel.h	/^static inline int channel_input_closed(struct channel *chn)$/;"	f
channel_is_empty	include/proto/channel.h	/^static inline unsigned int channel_is_empty(struct channel *c)$/;"	f
channel_output_closed	include/proto/channel.h	/^static inline int channel_output_closed(struct channel *chn)$/;"	f
channel_reserved	include/proto/channel.h	/^static inline int channel_reserved(const struct channel *chn)$/;"	f
channel_shutr_now	include/proto/channel.h	/^static inline void channel_shutr_now(struct channel *chn)$/;"	f
channel_shutw_now	include/proto/channel.h	/^static inline void channel_shutw_now(struct channel *chn)$/;"	f
chash	include/types/backend.h	/^	struct lb_chash chash;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_chash
chash_dequeue_srv	src/lb_chash.c	/^static inline void chash_dequeue_srv(struct server *s)$/;"	f	file:
chash_get_next_server	src/lb_chash.c	/^struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
chash_get_server_hash	src/lb_chash.c	/^struct server *chash_get_server_hash(struct proxy *p, unsigned int hash)$/;"	f
chash_init_server_tree	src/lb_chash.c	/^void chash_init_server_tree(struct proxy *p)$/;"	f
chash_queue_dequeue_srv	src/lb_chash.c	/^static inline void chash_queue_dequeue_srv(struct server *s)$/;"	f	file:
chash_set_server_status_down	src/lb_chash.c	/^static void chash_set_server_status_down(struct server *srv)$/;"	f	file:
chash_set_server_status_up	src/lb_chash.c	/^static void chash_set_server_status_up(struct server *srv)$/;"	f	file:
chash_skip_node	src/lb_chash.c	/^static inline struct eb32_node *chash_skip_node(struct eb_root *root, struct eb32_node *node)$/;"	f	file:
chash_update_server_weight	src/lb_chash.c	/^static void chash_update_server_weight(struct server *srv)$/;"	f	file:
check	include/types/checks.h	/^struct check {$/;"	s
check	include/types/proxy.h	/^		int check;                      \/* maximum time for complete check *\/$/;"	m	struct:proxy::__anon18
check	include/types/server.h	/^	struct check check;                     \/* health-check specific configuration *\/$/;"	m	struct:server	typeref:struct:server::check
check_bits	ebtree/ebtree.h	/^static forceinline int check_bits(const unsigned char *a,$/;"	f
check_common	include/types/server.h	/^	} check_common;$/;"	m	struct:server	typeref:struct:server::__anon98
check_config_validity	src/cfgparse.c	/^int check_config_validity()$/;"	f
check_conn_cb	src/checks.c	/^struct data_cb check_conn_cb = {$/;"	v	typeref:struct:data_cb
check_cttproxy_version	src/cttproxy.c	/^int check_cttproxy_version() {$/;"	f
check_group	src/auth.c	/^int check_group(struct userlist *ul, char *name)$/;"	f
check_len	include/types/proxy.h	/^	int check_len;				\/* Length of the HTTP or SSL3 request *\/$/;"	m	struct:proxy
check_notify_failure	src/checks.c	/^static void check_notify_failure(struct check *check)$/;"	f	file:
check_notify_stopping	src/checks.c	/^static void check_notify_stopping(struct check *check)$/;"	f	file:
check_notify_success	src/checks.c	/^static void check_notify_success(struct check *check)$/;"	f	file:
check_reason_string	src/checks.c	/^static const char *check_reason_string(struct check *check)$/;"	f	file:
check_replace_string	src/regex.c	/^const char *check_replace_string(const char *str)$/;"	f
check_req	include/types/proxy.h	/^	char *check_req;			\/* HTTP or SSL request to use for PR_O_HTTP_CHK|PR_O_SSL3_CHK *\/$/;"	m	struct:proxy
check_response_for_cacheability	src/proto_http.c	/^void check_response_for_cacheability(struct session *s, struct channel *rtr)$/;"	f
check_status	include/types/checks.h	/^struct check_status {$/;"	s
check_statuses	src/checks.c	/^static const struct check_status check_statuses[HCHK_STATUS_SIZE] = {$/;"	v	typeref:struct:check_status	file:
check_user	src/auth.c	/^check_user(struct userlist *ul, const char *user, const char *pass)$/;"	f
checks	src/cfgparse.c	/^	unsigned int checks;$/;"	m	struct:cfg_opt	file:
chk_rcv	include/types/stream_interface.h	/^	void (*chk_rcv)(struct stream_interface *); \/* chk_rcv function *\/$/;"	m	struct:si_ops
chk_report_conn_err	src/checks.c	/^static void chk_report_conn_err(struct connection *conn, int errno_bck, int expired)$/;"	f	file:
chk_result	include/types/checks.h	/^enum chk_result {$/;"	g
chk_snd	include/types/stream_interface.h	/^	void (*chk_snd)(struct stream_interface *); \/* chk_snd function *\/$/;"	m	struct:si_ops
chksize	include/types/global.h	/^		int chksize;       \/* check buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon95
chn	include/types/proto_http.h	/^	struct channel *chn;                   \/* pointer to the channel transporting the message *\/$/;"	m	struct:http_msg	typeref:struct:http_msg::channel
chroot	include/types/global.h	/^	char *chroot;$/;"	m	struct:global
chunk	include/common/chunk.h	/^struct chunk {$/;"	s
chunk	include/types/stream_interface.h	/^			struct chunk chunk;$/;"	m	struct:appctx::__anon43::__anon50	typeref:struct:appctx::__anon43::__anon50::chunk
chunk_appendf	src/chunk.c	/^int chunk_appendf(struct chunk *chk, const char *fmt, ...)$/;"	f
chunk_asciiencode	src/chunk.c	/^int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc)$/;"	f
chunk_destroy	include/common/chunk.h	/^static inline void chunk_destroy(struct chunk *chk)$/;"	f
chunk_drop	include/common/chunk.h	/^static inline void chunk_drop(struct chunk *chk)$/;"	f
chunk_dup	include/common/chunk.h	/^static inline char *chunk_dup(struct chunk *dst, const struct chunk *src)$/;"	f
chunk_htmlencode	src/chunk.c	/^int chunk_htmlencode(struct chunk *dst, struct chunk *src)$/;"	f
chunk_init	include/common/chunk.h	/^static inline void chunk_init(struct chunk *chk, char *str, size_t size)$/;"	f
chunk_initlen	include/common/chunk.h	/^static inline int chunk_initlen(struct chunk *chk, char *str, size_t size, int len)$/;"	f
chunk_initstr	include/common/chunk.h	/^static inline void chunk_initstr(struct chunk *chk, char *str)$/;"	f
chunk_len	include/types/proto_http.h	/^	unsigned long long chunk_len;          \/* cache for last chunk size or content-length header value *\/$/;"	m	struct:http_msg
chunk_printf	src/chunk.c	/^int chunk_printf(struct chunk *chk, const char *fmt, ...)$/;"	f
chunk_reset	include/common/chunk.h	/^static inline void chunk_reset(struct chunk *chk)$/;"	f
chunk_strcasecmp	src/chunk.c	/^int chunk_strcasecmp(const struct chunk *chk, const char *str)$/;"	f
chunk_strcmp	src/chunk.c	/^int chunk_strcmp(const struct chunk *chk, const char *str)$/;"	f
chunk_strcpy	include/common/chunk.h	/^static inline int chunk_strcpy(struct chunk *chk, const char *str)$/;"	f
cidr2dotted	src/standard.c	/^int cidr2dotted(int cidr, struct in_addr *mask) {$/;"	f
ciphers	include/types/listener.h	/^	char *ciphers;             \/* cipher suite to use if non-null *\/$/;"	m	struct:bind_conf
ciphers	include/types/server.h	/^		char *ciphers;			\/* cipher suite to use if non-null *\/$/;"	m	struct:server::__anon99
ck_opts	include/types/proxy.h	/^	unsigned int ck_opts;			\/* PR_CK_* (cookie options) *\/$/;"	m	struct:proxy
cklen	include/types/server.h	/^	int cklen;				\/* the len of the cookie, to speed up checks *\/$/;"	m	struct:server
clear_addr	include/common/standard.h	/^static inline void clear_addr(struct sockaddr_storage *addr)$/;"	f
clf_http_log_format	src/log.c	/^char clf_http_log_format[] = "%{+Q}o %{-Q}ci - - [%T] %r %ST %B \\"\\" \\"\\" %cp %ms %ft %b %s %Tq %Tw %Tc %Tr %Tt %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl";$/;"	v
cli	include/types/stream_interface.h	/^		} cli;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon48
cli_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters
cli_aborts	include/types/counters.h	/^	long long cli_aborts;                   \/* aborted responses during DATA phase caused by the client *\/$/;"	m	struct:pxcounters
cli_applet	src/dumpstats.c	/^static struct si_applet cli_applet = {$/;"	v	typeref:struct:si_applet	file:
cli_applet	src/dumpstats.c	/^static struct si_applet cli_applet;$/;"	v	typeref:struct:si_applet	file:
cli_cookie	include/types/proto_http.h	/^	char *cli_cookie;               \/* cookie presented by the client, in capture mode *\/$/;"	m	struct:http_txn
cli_io_handler	src/dumpstats.c	/^static void cli_io_handler(struct stream_interface *si)$/;"	f	file:
cli_release_handler	src/dumpstats.c	/^static void cli_release_handler(struct stream_interface *si)$/;"	f	file:
client	include/types/connection.h	/^	uint8_t client;$/;"	m	struct:tlv_ssl
client	include/types/proxy.h	/^		int client;                     \/* client I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon18
client_crt	include/types/server.h	/^		char *client_crt;		\/* client certificate to send *\/$/;"	m	struct:server::__anon99
client_rcvbuf	include/types/global.h	/^		int client_rcvbuf; \/* set client rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon95
client_sndbuf	include/types/global.h	/^		int client_sndbuf; \/* set client sndbuf to this value if not null *\/$/;"	m	struct:global::__anon95
clientfin	include/types/proxy.h	/^		int clientfin;                  \/* timeout to apply to client half-closed connections *\/$/;"	m	struct:proxy::__anon18
clo	include/types/fd.h	/^	void REGPRM1   (*clo)(const int fd);                 \/* mark <fd> as closed *\/$/;"	m	struct:poller
cloned	include/types/fd.h	/^	unsigned char cloned:1;              \/* 1 if a cloned socket, requires EPOLL_CTL_DEL on close *\/$/;"	m	struct:fdtab
close	include/types/connection.h	/^	void (*close)(struct connection *);         \/* close the transport layer *\/$/;"	m	struct:xprt_ops
cmp_bits	ebtree/ebtree.h	/^static forceinline int cmp_bits(const unsigned char *a, const unsigned char *b, unsigned int pos)$/;"	f
cmpxchg	src/shctx.c	/^static inline unsigned int cmpxchg(unsigned int *ptr, unsigned int old, unsigned int new)$/;"	f	file:
code	include/types/checks.h	/^	short status, code;			\/* check result, check code *\/$/;"	m	struct:check
code	include/types/proxy.h	/^	int code;$/;"	m	struct:redirect_rule
comp	include/types/compression.h	/^struct comp {$/;"	s
comp	include/types/proxy.h	/^	struct comp *comp;			\/* http compression *\/$/;"	m	struct:proxy	typeref:struct:proxy::comp
comp_algo	include/types/compression.h	/^struct comp_algo {$/;"	s
comp_algo	include/types/session.h	/^	struct comp_algo *comp_algo;		\/* HTTP compression algorithm if not NULL *\/$/;"	m	struct:session	typeref:struct:session::comp_algo
comp_algos	src/compression.c	/^const struct comp_algo comp_algos[] =$/;"	v	typeref:struct:comp_algo
comp_append_algo	src/compression.c	/^int comp_append_algo(struct comp *comp, const char *algo)$/;"	f
comp_append_type	src/compression.c	/^int comp_append_type(struct comp *comp, const char *type)$/;"	f
comp_bps_in	include/types/global.h	/^	struct freq_ctr comp_bps_in;	\/* bytes per second, before http compression *\/$/;"	m	struct:global	typeref:struct:global::freq_ctr
comp_bps_out	include/types/global.h	/^	struct freq_ctr comp_bps_out;	\/* bytes per second, after http compression *\/$/;"	m	struct:global	typeref:struct:global::freq_ctr
comp_byp	include/types/counters.h	/^	long long comp_byp;                     \/* input bytes that bypassed the compressor (cpu\/ram\/bw limitation) *\/$/;"	m	struct:pxcounters
comp_ctx	include/types/compression.h	/^struct comp_ctx {$/;"	s
comp_ctx	include/types/session.h	/^	struct comp_ctx *comp_ctx;		\/* HTTP compression context *\/$/;"	m	struct:session	typeref:struct:session::comp_ctx
comp_in	include/types/counters.h	/^	long long comp_in;                      \/* input bytes fed to the compressor *\/$/;"	m	struct:pxcounters
comp_maxlevel	include/types/global.h	/^		int comp_maxlevel;    \/* max HTTP compression level *\/$/;"	m	struct:global::__anon95
comp_out	include/types/counters.h	/^	long long comp_out;                     \/* output bytes emitted by the compressor *\/$/;"	m	struct:pxcounters
comp_rate_lim	include/types/global.h	/^	int comp_rate_lim;           \/* HTTP compression rate limit *\/$/;"	m	struct:global
comp_rsp	include/types/counters.h	/^			long long comp_rsp;     \/* number of compressed responses *\/$/;"	m	struct:pxcounters::__anon3::__anon4
comp_type	include/types/compression.h	/^struct comp_type {$/;"	s
compress_min_idle	src/compression.c	/^unsigned int compress_min_idle = 0;$/;"	v
cond	include/common/mini-clist.h	/^	void *cond;$/;"	m	struct:cond_wordlist
cond	include/common/regex.h	/^    void *cond;				\/* a possible condition or NULL *\/$/;"	m	struct:hdr_exp
cond	include/common/uri_auth.h	/^	struct acl_cond *cond;	\/* acl condition to meet *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::acl_cond
cond	include/types/proto_http.h	/^	struct acl_cond *cond;                 \/* acl condition to meet *\/$/;"	m	struct:http_req_rule	typeref:struct:http_req_rule::acl_cond
cond	include/types/proto_http.h	/^	struct acl_cond *cond;                 \/* acl condition to meet *\/$/;"	m	struct:http_res_rule	typeref:struct:http_res_rule::acl_cond
cond	include/types/proto_tcp.h	/^	struct acl_cond *cond;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:server_rule	typeref:struct:server_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::acl_cond
cond_wordlist	include/common/mini-clist.h	/^struct cond_wordlist {$/;"	s
conf	include/types/listener.h	/^	} conf;				\/* config information *\/$/;"	m	struct:listener	typeref:struct:listener::__anon52
conf	include/types/peers.h	/^	} conf;				 \/* config information *\/$/;"	m	struct:peers	typeref:struct:peers::__anon24
conf	include/types/peers.h	/^	} conf;		  	  \/* config information *\/$/;"	m	struct:peer	typeref:struct:peer::__anon23
conf	include/types/proxy.h	/^	} conf;					\/* config information *\/$/;"	m	struct:proxy	typeref:struct:proxy::__anon19
conf	include/types/server.h	/^	} conf;					\/* config information *\/$/;"	m	struct:server	typeref:struct:server::__anon100
config_callback	src/log.c	/^	int (*config_callback)(struct logformat_node *node, struct proxy *curproxy);$/;"	m	struct:logformat_type	file:
confirm	include/types/peers.h	/^	unsigned int confirm;	      \/* confirm message counter *\/$/;"	m	struct:peer_session
conn	include/types/checks.h	/^	struct connection *conn;		\/* connection state for health checks *\/$/;"	m	struct:check	typeref:struct:check::connection
conn_attach	include/proto/connection.h	/^static inline void conn_attach(struct connection *conn, void *owner, const struct data_cb *data)$/;"	f
conn_cnt	include/types/stick_table.h	/^	unsigned int conn_cnt;$/;"	m	union:stktable_data
conn_cond_update_data_polling	include/proto/connection.h	/^static inline void conn_cond_update_data_polling(struct connection *c)$/;"	f
conn_cond_update_polling	include/proto/connection.h	/^static inline void conn_cond_update_polling(struct connection *c)$/;"	f
conn_cond_update_sock_polling	include/proto/connection.h	/^static inline void conn_cond_update_sock_polling(struct connection *c)$/;"	f
conn_ctrl_close	include/proto/connection.h	/^static inline void conn_ctrl_close(struct connection *conn)$/;"	f
conn_ctrl_init	include/proto/connection.h	/^static inline void conn_ctrl_init(struct connection *conn)$/;"	f
conn_ctrl_ready	include/proto/connection.h	/^static inline int conn_ctrl_ready(const struct connection *conn)$/;"	f
conn_cur	include/types/stick_table.h	/^	unsigned int conn_cur;$/;"	m	union:stktable_data
conn_data_polling_changes	include/proto/connection.h	/^static inline unsigned int conn_data_polling_changes(const struct connection *c)$/;"	f
conn_data_read0	include/proto/connection.h	/^static inline void conn_data_read0(struct connection *c)$/;"	f
conn_data_read0_pending	include/proto/connection.h	/^static inline int conn_data_read0_pending(struct connection *c)$/;"	f
conn_data_shutw	include/proto/connection.h	/^static inline void conn_data_shutw(struct connection *c)$/;"	f
conn_data_stop_both	include/proto/connection.h	/^static inline void conn_data_stop_both(struct connection *c)$/;"	f
conn_data_stop_recv	include/proto/connection.h	/^static inline void conn_data_stop_recv(struct connection *c)$/;"	f
conn_data_stop_send	include/proto/connection.h	/^static inline void conn_data_stop_send(struct connection *c)$/;"	f
conn_data_want_recv	include/proto/connection.h	/^static inline void conn_data_want_recv(struct connection *c)$/;"	f
conn_data_want_send	include/proto/connection.h	/^static inline void conn_data_want_send(struct connection *c)$/;"	f
conn_drain	include/proto/connection.h	/^static inline int conn_drain(struct connection *conn)$/;"	f
conn_err_code_str	include/proto/connection.h	/^static inline const char *conn_err_code_str(struct connection *c)$/;"	f
conn_fd_handler	src/connection.c	/^int conn_fd_handler(int fd)$/;"	f
conn_force_close	include/proto/connection.h	/^static inline void conn_force_close(struct connection *conn)$/;"	f
conn_free	include/proto/connection.h	/^static inline void conn_free(struct connection *conn)$/;"	f
conn_full_close	include/proto/connection.h	/^static inline void conn_full_close(struct connection *conn)$/;"	f
conn_get_from_addr	include/proto/connection.h	/^static inline void conn_get_from_addr(struct connection *conn)$/;"	f
conn_get_to_addr	include/proto/connection.h	/^static inline void conn_get_to_addr(struct connection *conn)$/;"	f
conn_init	include/proto/connection.h	/^static inline void conn_init(struct connection *conn)$/;"	f
conn_max	include/types/counters.h	/^	unsigned int conn_max;			\/* max # of active listener sessions *\/$/;"	m	struct:licounters
conn_max	include/types/counters.h	/^	unsigned int conn_max;                  \/* max # of active sessions *\/$/;"	m	struct:pxcounters
conn_new	include/proto/connection.h	/^static inline struct connection *conn_new()$/;"	f
conn_opts	include/types/checks.h	/^	unsigned short conn_opts;               \/* options when setting up a new connection *\/$/;"	m	struct:tcpcheck_rule
conn_per_sec	include/types/global.h	/^	struct freq_ctr conn_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
conn_prepare	include/proto/connection.h	/^static inline void conn_prepare(struct connection *conn, const struct protocol *proto, const struct xprt_ops *xprt)$/;"	f
conn_rate	include/types/stick_table.h	/^	struct freq_ctr_period conn_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
conn_recv_proxy	src/connection.c	/^int conn_recv_proxy(struct connection *conn, int flag)$/;"	f
conn_refresh_polling_flags	include/proto/connection.h	/^static inline void conn_refresh_polling_flags(struct connection *conn)$/;"	f
conn_retries	include/types/proxy.h	/^	int conn_retries;			\/* maximum number of connect retries *\/$/;"	m	struct:proxy
conn_retries	include/types/stream_interface.h	/^	int conn_retries;	\/* number of connect retries left *\/$/;"	m	struct:stream_interface
conn_session_complete	src/session.c	/^static int conn_session_complete(struct connection *conn)$/;"	f	file:
conn_session_update	src/session.c	/^static int conn_session_update(struct connection *conn)$/;"	f	file:
conn_si_send_proxy	src/stream_interface.c	/^int conn_si_send_proxy(struct connection *conn, unsigned int flag)$/;"	f
conn_sock_polling_changes	include/proto/connection.h	/^static inline unsigned int conn_sock_polling_changes(const struct connection *c)$/;"	f
conn_sock_read0	include/proto/connection.h	/^static inline void conn_sock_read0(struct connection *c)$/;"	f
conn_sock_shutw	include/proto/connection.h	/^static inline void conn_sock_shutw(struct connection *c)$/;"	f
conn_sock_shutw_pending	include/proto/connection.h	/^static inline int conn_sock_shutw_pending(struct connection *c)$/;"	f
conn_sock_stop_both	include/proto/connection.h	/^static inline void conn_sock_stop_both(struct connection *c)$/;"	f
conn_sock_stop_recv	include/proto/connection.h	/^static inline void conn_sock_stop_recv(struct connection *c)$/;"	f
conn_sock_stop_send	include/proto/connection.h	/^static inline void conn_sock_stop_send(struct connection *c)$/;"	f
conn_sock_want_recv	include/proto/connection.h	/^static inline void conn_sock_want_recv(struct connection *c)$/;"	f
conn_sock_want_send	include/proto/connection.h	/^static inline void conn_sock_want_send(struct connection *c)$/;"	f
conn_src	include/types/connection.h	/^struct conn_src {$/;"	s
conn_src	include/types/proxy.h	/^	struct conn_src conn_src;               \/* connection source settings *\/$/;"	m	struct:proxy	typeref:struct:proxy::conn_src
conn_src	include/types/server.h	/^	struct conn_src conn_src;               \/* connection source settings *\/$/;"	m	struct:server	typeref:struct:server::conn_src
conn_stop_polling	include/proto/connection.h	/^static inline void conn_stop_polling(struct connection *c)$/;"	f
conn_update_data_polling	src/connection.c	/^void conn_update_data_polling(struct connection *c)$/;"	f
conn_update_sock_polling	src/connection.c	/^void conn_update_sock_polling(struct connection *c)$/;"	f
conn_xprt_close	include/proto/connection.h	/^static inline void conn_xprt_close(struct connection *conn)$/;"	f
conn_xprt_init	include/proto/connection.h	/^static inline int conn_xprt_init(struct connection *conn)$/;"	f
conn_xprt_ready	include/proto/connection.h	/^static inline int conn_xprt_ready(const struct connection *conn)$/;"	f
connect	include/types/protocol.h	/^	int (*connect)(struct connection *, int data, int delack);  \/* connect function if any *\/$/;"	m	struct:protocol
connect	include/types/proxy.h	/^		int connect;                    \/* connect timeout (in ticks) *\/$/;"	m	struct:proxy::__anon18
connect_chk	src/checks.c	/^static int connect_chk(struct task *t)$/;"	f	file:
connect_default_ciphers	include/types/global.h	/^	char *connect_default_ciphers;$/;"	m	struct:global
connect_server	src/backend.c	/^int connect_server(struct session *s)$/;"	f
connection	include/types/connection.h	/^struct connection {$/;"	s
cons	include/types/channel.h	/^	struct stream_interface *cons;  \/* consumer attached to this channel *\/$/;"	m	struct:channel	typeref:struct:channel::stream_interface
cons	include/types/pipe.h	/^	int cons;	\/* FD the consumer must read from ; -1 if none *\/$/;"	m	struct:pipe
consecutive_errors	include/types/server.h	/^	int consecutive_errors;			\/* current number of consecutive errors *\/$/;"	m	struct:server
consecutive_errors_limit	include/types/server.h	/^	int consecutive_errors_limit;		\/* number of consecutive errors that triggers an event *\/$/;"	m	struct:server
container_of	ebtree/ebtree.h	321;"	d
container_of	include/common/rbtree.h	118;"	d
container_of_safe	ebtree/ebtree.h	328;"	d
context	include/types/task.h	/^	void *context;			\/* the task's context *\/$/;"	m	struct:task
conv	include/types/arg.h	/^	const char *conv;         \/* conv keyword when in conv, otherwise NULL *\/$/;"	m	struct:arg_list
conv	include/types/map.h	/^	struct sample_conv *conv;      \/* original converter descriptor *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::sample_conv
conv	include/types/sample.h	/^	struct sample_conv *conv;                 \/* sample conversion used *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::sample_conv
conv_exprs	include/types/sample.h	/^	struct list conv_exprs;                   \/* list of conversion expression to apply *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::list
convert_date	contrib/halog/halog.c	/^int convert_date(const char *field)$/;"	f
convert_date_to_timestamp	contrib/halog/halog.c	/^int convert_date_to_timestamp(const char *field)$/;"	f
convert_range	contrib/ip6range/ip6range.c	/^static void convert_range(struct in6_addr *low, struct in6_addr *high, const char *eol, const char *pfx)$/;"	f	file:
convert_range	contrib/iprange/iprange.c	/^static void convert_range(unsigned int low, unsigned int high, const char *eol, const char *pfx)$/;"	f	file:
cookie	include/types/server.h	/^	char *cookie;				\/* the id set in the cookie *\/$/;"	m	struct:server
cookie_domain	include/types/proxy.h	/^	char *cookie_domain;			\/* domain used to insert the cookie *\/$/;"	m	struct:proxy
cookie_first_date	include/types/proto_http.h	/^	int cookie_first_date;          \/* if non-zero, first date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn
cookie_last_date	include/types/proto_http.h	/^	int cookie_last_date;           \/* if non-zero, last date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn
cookie_len	include/types/global.h	/^		int cookie_len;    \/* max length of cookie captures *\/$/;"	m	struct:global::__anon95
cookie_len	include/types/proxy.h	/^	int  cookie_len;			\/* strlen(cookie_name), computed only once *\/$/;"	m	struct:proxy
cookie_len	include/types/proxy.h	/^	int cookie_len;$/;"	m	struct:redirect_rule
cookie_maxidle	include/types/proxy.h	/^	unsigned int cookie_maxidle;		\/* max idle time for this cookie *\/$/;"	m	struct:proxy
cookie_maxlife	include/types/proxy.h	/^	unsigned int cookie_maxlife;		\/* max life time for this cookie *\/$/;"	m	struct:proxy
cookie_name	include/types/proxy.h	/^	char *cookie_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy
cookie_str	include/types/proxy.h	/^	char *cookie_str;$/;"	m	struct:redirect_rule
count	contrib/halog/halog.c	/^	unsigned int count;$/;"	m	struct:timer	file:
count	include/types/peers.h	/^	int count;			 \/* total of peers *\/$/;"	m	struct:peers
count	include/types/signal.h	/^	int count;                      \/* number of times raised *\/$/;"	m	struct:signal_descriptor
count_hash_results	tests/ip-hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f
count_hash_results	tests/uri_hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f
counters	include/types/listener.h	/^	struct licounters *counters;	\/* statistics counters *\/$/;"	m	struct:listener	typeref:struct:listener::licounters
counters	include/types/server.h	/^	struct srvcounters counters;		\/* statistics counters *\/$/;"	m	struct:server	typeref:struct:server::srvcounters
counts_SuperFastHash	tests/uri_hash.c	/^int counts_SuperFastHash[NSERV][NSERV];$/;"	v
counts_SuperFastHash2	tests/uri_hash.c	/^int counts_SuperFastHash2[NSERV][NSERV];$/;"	v
counts_bj6	tests/ip-hash.c	/^int counts_bj6[NSERV][NSERV];$/;"	v
counts_bj6x	tests/ip-hash.c	/^int counts_bj6x[NSERV][NSERV];$/;"	v
counts_bj7	tests/ip-hash.c	/^int counts_bj7[NSERV][NSERV];$/;"	v
counts_bj7x	tests/ip-hash.c	/^int counts_bj7x[NSERV][NSERV];$/;"	v
counts_gd1	tests/uri_hash.c	/^int counts_gd1[NSERV][NSERV];$/;"	v
counts_gd2	tests/uri_hash.c	/^int counts_gd2[NSERV][NSERV];$/;"	v
counts_gd3	tests/uri_hash.c	/^int counts_gd3[NSERV][NSERV];$/;"	v
counts_gd4	tests/uri_hash.c	/^int counts_gd4[NSERV][NSERV];$/;"	v
counts_gd5	tests/uri_hash.c	/^int counts_gd5[NSERV][NSERV];$/;"	v
counts_gd6	tests/uri_hash.c	/^int counts_gd6[NSERV][NSERV];$/;"	v
counts_id	tests/ip-hash.c	/^int counts_id[NSERV][NSERV];$/;"	v
counts_srv	tests/uri_hash.c	/^int counts_srv[NSERV][NSERV];$/;"	v
counts_tw1	tests/ip-hash.c	/^int counts_tw1[NSERV][NSERV];$/;"	v
counts_tw2	tests/ip-hash.c	/^int counts_tw2[NSERV][NSERV];$/;"	v
counts_tw3	tests/ip-hash.c	/^int counts_tw3[NSERV][NSERV];$/;"	v
counts_wt1	tests/uri_hash.c	/^int counts_wt1[NSERV][NSERV];$/;"	v
counts_wt2	tests/uri_hash.c	/^int counts_wt2[NSERV][NSERV];$/;"	v
cps_lim	include/types/global.h	/^	int cps_lim, cps_max;$/;"	m	struct:global
cps_max	include/types/counters.h	/^	unsigned int cps_max;                   \/* maximum of new connections received per second *\/$/;"	m	struct:pxcounters
cps_max	include/types/global.h	/^	int cps_lim, cps_max;$/;"	m	struct:global
cpu_map	include/types/global.h	/^	unsigned long cpu_map[LONGBITS];  \/* list of CPU masks for the 32\/64 first processes *\/$/;"	m	struct:global
cr	include/types/hdr_idx.h	/^        unsigned cr   : 1; \/* CR present (1=CRLF, 0=LF). Total line size=len+cr+1. *\/$/;"	m	struct:hdr_idx_elem
create_cond_regex_rule	src/cfgparse.c	/^static int create_cond_regex_rule(const char *file, int line,$/;"	f	file:
create_pool	src/memory.c	/^struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags)$/;"	f
crl_file	include/types/listener.h	/^	char *crl_file;            \/* CRLfile to use on verify *\/$/;"	m	struct:bind_conf
crl_file	include/types/server.h	/^		char *crl_file;			\/* CRLfile to use on verify *\/$/;"	m	struct:server::__anon99
crt_base	include/types/global.h	/^	char *crt_base;             \/* base directory path for certificates *\/$/;"	m	struct:global
crt_ignerr	include/types/listener.h	/^	unsigned long long crt_ignerr; \/* ignored verify errors in handshake if depth == 0 *\/$/;"	m	struct:bind_conf
cstr	include/common/standard.h	/^static inline const char *cstr(const char *str)$/;"	f
ctrl	include/types/connection.h	/^	const struct protocol *ctrl;  \/* operations at the socket layer *\/$/;"	m	struct:connection	typeref:struct:connection::protocol
ctx	include/types/arg.h	/^	int ctx;                  \/* context where the arg is used (ARGC_*) *\/$/;"	m	struct:arg_list
ctx	include/types/sample.h	/^	union smp_ctx ctx;$/;"	m	struct:sample	typeref:union:sample::smp_ctx
ctx	include/types/server.h	/^		SSL_CTX *ctx;$/;"	m	struct:server::__anon99
ctx	include/types/ssl_sock.h	/^	SSL_CTX *ctx;             \/* context associated to the certificate *\/$/;"	m	struct:sni_ctx
ctx	include/types/stream_interface.h	/^	} ctx;					\/* used by stats I\/O handlers to dump the stats *\/$/;"	m	struct:appctx	typeref:union:appctx::__anon43
cum_conn	include/types/counters.h	/^	long long    cum_conn;                  \/* cumulated number of received connections *\/$/;"	m	struct:pxcounters
cum_conn	include/types/counters.h	/^	long long cum_conn;			\/* cumulated number of received connections *\/$/;"	m	struct:licounters
cum_ct	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:
cum_lbconn	include/types/counters.h	/^	long long  cum_lbconn;                  \/* cumulated number of sessions processed by load balancing (BE only) *\/$/;"	m	struct:pxcounters
cum_lbconn	include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions directed by load balancing *\/$/;"	m	struct:srvcounters
cum_req	include/types/counters.h	/^			long long cum_req;      \/* cumulated number of processed HTTP requests *\/$/;"	m	struct:pxcounters::__anon3::__anon4
cum_rt	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:
cum_sess	include/types/counters.h	/^	long long    cum_sess;                  \/* cumulated number of accepted connections *\/$/;"	m	struct:pxcounters
cum_sess	include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of accepted sessions *\/$/;"	m	struct:licounters
cum_sess	include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of sessions really sent to this server *\/$/;"	m	struct:srvcounters
cur_lvl	include/types/compression.h	/^	int cur_lvl;$/;"	m	struct:comp_ctx
cur_poller	src/fd.c	/^struct poller cur_poller;$/;"	v	typeref:struct:poller
cur_sess	include/types/server.h	/^	int cur_sess;				\/* number of currently active sessions (including syn_sent) *\/$/;"	m	struct:server
cur_sess_max	include/types/counters.h	/^	unsigned int cur_sess_max;		\/* max number of currently active sessions *\/$/;"	m	struct:srvcounters
curr	include/types/lb_fwrr.h	/^	struct eb_root curr;    \/* tree for servers in "current" time range *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
curr_ctr	include/types/freq_ctr.h	/^	unsigned int curr_ctr;  \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr_period
curr_ctr	include/types/freq_ctr.h	/^	unsigned int curr_ctr; \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr
curr_pos	include/types/lb_fwrr.h	/^	int curr_pos;           \/* current position in the tree *\/$/;"	m	struct:fwrr_group
curr_sec	include/types/freq_ctr.h	/^	unsigned int curr_sec; \/* start date of current period (seconds from now.tv_sec) *\/$/;"	m	struct:freq_ctr
curr_sec_ms	src/time.c	/^unsigned int   curr_sec_ms;     \/* millisecond of current second (0..999) *\/$/;"	v
curr_tick	include/types/freq_ctr.h	/^	unsigned int curr_tick; \/* start date of current period (wrapping ticks) *\/$/;"	m	struct:freq_ctr_period
curr_weight	include/types/lb_fwrr.h	/^	int curr_weight;        \/* total weight of the current time range *\/$/;"	m	struct:fwrr_group
current	include/types/stick_table.h	/^	unsigned int current;     \/* number of sticky sessions currently in table *\/$/;"	m	struct:stktable
current_step	include/types/checks.h	/^	struct tcpcheck_rule *current_step;     \/* current step when using tcpcheck *\/$/;"	m	struct:check	typeref:struct:check::tcpcheck_rule
cursection	src/cfgparse.c	/^static char *cursection = NULL;$/;"	v	file:
cut_crlf	include/common/standard.h	/^static inline char *cut_crlf(char *s) {$/;"	f
d	include/types/sample.h	/^	double d;       \/* any float or double *\/$/;"	m	union:smp_ctx
d_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
d_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
data	include/common/buffer.h	/^	char data[0];                   \/* <size> bytes *\/$/;"	m	struct:buffer
data	include/common/epoll.h	/^	} data;$/;"	m	struct:epoll_event	typeref:union:epoll_event::__anon104
data	include/types/arg.h	/^	union arg_data data;      \/* argument data *\/$/;"	m	struct:arg	typeref:union:arg::arg_data
data	include/types/connection.h	/^	const struct data_cb  *data;  \/* data layer callbacks. Must be set before xprt->init() *\/$/;"	m	struct:connection	typeref:struct:connection::data_cb
data	include/types/pipe.h	/^	int data;	\/* number of bytes present in the pipe  *\/$/;"	m	struct:pipe
data	include/types/proto_http.h	/^		void *data;                    \/* generic pointer for module or external rule *\/$/;"	m	union:http_req_rule::__anon67
data	include/types/proto_http.h	/^		void *data;                    \/* generic pointer for module or external rule *\/$/;"	m	union:http_res_rule::__anon71
data	include/types/sample.h	/^	} data;                        \/* sample data *\/$/;"	m	struct:sample	typeref:union:sample::__anon92
data	include/types/sample.h	/^	} data;                        \/* sample data *\/$/;"	m	struct:sample_storage	typeref:union:sample_storage::__anon93
data	include/types/stick_table.h	/^	union stktable_key_data data;   \/* data, must always be last *\/$/;"	m	struct:stktable_key	typeref:union:stktable_key::stktable_key_data
data	src/shctx.c	/^		unsigned char data[sizeof(struct shared_session)];$/;"	m	union:shared_block::__anon115	file:
data	src/shctx.c	/^	unsigned char data[0];$/;"	m	struct:shsess_packet	file:
data	src/shctx.c	/^	unsigned char data[SHSESS_BLOCK_MIN_SIZE];$/;"	m	struct:shared_session	file:
data	src/shctx.c	/^	unsigned char data[SHSESS_MAX_DATA_LEN];$/;"	m	struct:shared_context	file:
data	src/shctx.c	/^	} data;$/;"	m	struct:shared_block	typeref:union:shared_block::__anon115	file:
data_arg	include/types/stick_table.h	/^	} data_arg[STKTABLE_DATA_TYPES]; \/* optional argument of each data type *\/$/;"	m	struct:stktable	typeref:union:stktable::__anon30
data_cb	include/types/connection.h	/^struct data_cb {$/;"	s
data_len	src/shctx.c	/^	short int data_len;$/;"	m	struct:shared_block	file:
data_len	src/shctx.c	/^	short int data_len;$/;"	m	struct:shared_context	file:
data_ofs	include/types/stick_table.h	/^	int data_ofs[STKTABLE_DATA_TYPES]; \/* negative offsets of present data types, or 0 if absent *\/$/;"	m	struct:stktable
data_op	include/types/stream_interface.h	/^			signed char data_op;	\/* operator (STD_OP_*) when data_type set *\/$/;"	m	struct:appctx::__anon43::__anon47
data_size	include/types/stick_table.h	/^	int data_size;            \/* the size of the data that is prepended *before* stksess *\/$/;"	m	struct:stktable
data_type	include/types/stream_interface.h	/^			signed char data_type;	\/* type of data to compare, or -1 if none *\/$/;"	m	struct:appctx::__anon43::__anon47
date	src/time.c	/^struct timeval date;            \/* the real current date *\/$/;"	v	typeref:struct:timeval
date2str_log	src/standard.c	/^char *date2str_log(char *dst, struct tm *tm, struct timeval *date, size_t size)$/;"	f
debug_hdr	src/proto_http.c	/^void debug_hdr(const char *dir, struct session *s, const char *start, const char *end)$/;"	f
def	include/types/map.h	/^	struct sample_storage *def;    \/* contain the default value *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::sample_storage
default_acl_list	src/acl.c	/^} default_acl_list[] = {$/;"	v	typeref:struct:__anon114
default_ctx	include/types/listener.h	/^	SSL_CTX *default_ctx;      \/* SSL context of first\/default certificate *\/$/;"	m	struct:bind_conf
default_http_log_format	src/log.c	/^char default_http_log_format[] = "%ci:%cp [%t] %ft %b\/%s %Tq\/%Tw\/%Tc\/%Tr\/%Tt %ST %B %CC %CS %tsc %ac\/%fc\/%bc\/%sc\/%rc %sq\/%bq %hr %hs %{+Q}r"; \/\/ default format$/;"	v
default_ok	include/types/server.h	/^	int default_ok; \/* non-zero if kw is supported in default-server section *\/$/;"	m	struct:srv_kw
default_size	include/types/stick_table.h	/^	size_t default_size;      \/* default key size *\/$/;"	m	struct:stktable_type
default_srv_error	src/session.c	/^void default_srv_error(struct session *s, struct stream_interface *si)$/;"	f
default_tcp_log_format	src/log.c	/^char default_tcp_log_format[] = "%ci:%cp [%t] %ft %b\/%s %Tw\/%Tc\/%Tt %B %ts %ac\/%fc\/%bc\/%sc\/%rc %sq\/%bq";$/;"	v
default_value	include/types/map.h	/^	char *default_value;           \/* a copy of default value. This copy is$/;"	m	struct:map_descriptor
defbe	include/types/proxy.h	/^	} defbe;$/;"	m	struct:proxy	typeref:union:proxy::__anon15
deflate_add_data	src/compression.c	/^int deflate_add_data(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out)$/;"	f
deflate_end	src/compression.c	/^int deflate_end(struct comp_ctx **comp_ctx)$/;"	f
deflate_flush	src/compression.c	/^int deflate_flush(struct comp_ctx *comp_ctx, struct buffer *out, int flag)$/;"	f
deflate_init	src/compression.c	/^int deflate_init(struct comp_ctx **comp_ctx, int level)$/;"	f
deflate_reset	src/compression.c	/^int deflate_reset(struct comp_ctx *comp_ctx)$/;"	f
defproxy	src/cfgparse.c	/^static struct proxy defproxy;		\/* fake proxy used to assign default values on all instances *\/$/;"	v	typeref:struct:proxy	file:
defsrv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::
deinit	src/haproxy.c	/^void deinit(void)$/;"	f
deinit_acl_cond	src/haproxy.c	/^static void deinit_acl_cond(struct acl_cond *cond)$/;"	f	file:
deinit_comp_ctx	src/compression.c	/^static inline int deinit_comp_ctx(struct comp_ctx **comp_ctx)$/;"	f	file:
deinit_pollers	src/fd.c	/^void deinit_pollers() {$/;"	f
deinit_sample_arg	src/haproxy.c	/^static void deinit_sample_arg(struct arg *p)$/;"	f	file:
deinit_signals	src/signal.c	/^void deinit_signals()$/;"	f
deinit_stick_rules	src/haproxy.c	/^static void deinit_stick_rules(struct list *rules)$/;"	f	file:
deinit_tcp_rules	src/haproxy.c	/^static void deinit_tcp_rules(struct list *rules)$/;"	f	file:
del	include/types/proto_http.h	/^	int  del;  \/* relative to line *\/$/;"	m	struct:hdr_ctx
del_hdr_value	src/proto_http.c	/^int del_hdr_value(struct buffer *buf, char **from, char *next)$/;"	f
delete_listener	src/listener.c	/^void delete_listener(struct listener *listener)$/;"	f
denied_conn	include/types/counters.h	/^	long long denied_conn;			\/* denied connection requests (tcp-req rules) *\/$/;"	m	struct:licounters
denied_conn	include/types/counters.h	/^	long long denied_conn;                  \/* denied connection requests (tcp-req rules) *\/$/;"	m	struct:pxcounters
denied_req	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters
denied_req	include/types/counters.h	/^	long long denied_req;                   \/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters
denied_resp	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters
denied_resp	include/types/counters.h	/^	long long denied_resp;                  \/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters
dequeue_all_listeners	src/listener.c	/^void dequeue_all_listeners(struct list *list)$/;"	f
dequeue_srv	tests/filltab25.c	/^static inline void dequeue_srv(struct srv *s) {$/;"	f	file:
desc	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth
desc	include/types/checks.h	/^	char *desc;				\/* description *\/$/;"	m	struct:analyze_status
desc	include/types/checks.h	/^	char *desc;			\/* long description *\/$/;"	m	struct:check_status
desc	include/types/checks.h	/^	char desc[HCHK_DESC_LEN];		\/* health check descritpion *\/$/;"	m	struct:check
desc	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global
desc	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy
desc	include/types/stream_interface.h	/^			struct map_descriptor *desc;$/;"	m	struct:appctx::__anon43::__anon50	typeref:struct:appctx::__anon43::__anon50::map_descriptor
destroy	include/common/sessionhash.h	/^	void (*destroy)(appsess *);$/;"	m	struct:appsession_hash
destroy	src/appsession.c	/^void destroy(appsess *temp1) {$/;"	f
destroy_uxst_socket	src/proto_uxst.c	/^static void destroy_uxst_socket(const char *path)$/;"	f	file:
die	contrib/halog/halog.c	/^void die(const char *msg)$/;"	f
disable_all	include/types/protocol.h	/^	int (*disable_all)(struct protocol *proto);	\/* disable all bound listeners *\/$/;"	m	struct:protocol
disable_all_listeners	src/listener.c	/^int disable_all_listeners(struct protocol *proto)$/;"	f
disable_listener	src/listener.c	/^void disable_listener(struct listener *listener)$/;"	f
disable_poller	src/fd.c	/^void disable_poller(const char *poller_name)$/;"	f
disabled	src/trace.c	/^static int disabled;$/;"	v	file:
dispatch_addr	include/types/proxy.h	/^	struct sockaddr_storage dispatch_addr;	\/* the default address to connect to *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_storage
display	include/types/pattern.h	/^	char *display; \/* String displayed to identify the pattern origin. *\/$/;"	m	struct:pat_ref
display_build_opts	src/haproxy.c	/^void display_build_opts()$/;"	f
display_flags	include/types/stream_interface.h	/^			unsigned int display_flags;$/;"	m	struct:appctx::__anon43::__anon50
display_version	src/haproxy.c	/^void display_version()$/;"	f
div64_32	include/common/standard.h	/^static inline unsigned int div64_32(unsigned long long o1, unsigned int o2)$/;"	f
do_free	include/types/map.h	/^	int do_free;                   \/* set if <pat> is the orignal pat and must be freed *\/$/;"	m	struct:map_descriptor
do_free	include/types/pattern.h	/^	int do_free;$/;"	m	struct:pattern_expr_list
do_log	include/types/session.h	/^	void (*do_log)(struct session *s);	\/* the function to call in order to log (or NULL) *\/$/;"	m	struct:session
dow	include/types/pattern.h	/^	int dow:7;              \/* 1 bit per day of week: 0-6 *\/$/;"	m	struct:pat_time
down_time	include/types/proxy.h	/^	unsigned down_time;			\/* total time the proxy was down *\/$/;"	m	struct:proxy
down_time	include/types/server.h	/^	unsigned down_time;			\/* total time the server was down *\/$/;"	m	struct:server
down_trans	include/types/counters.h	/^	long long down_trans;			\/* up->down transitions *\/$/;"	m	struct:srvcounters
down_trans	include/types/proxy.h	/^	unsigned down_trans;			\/* up-down transitions *\/$/;"	m	struct:proxy
downinter	include/types/checks.h	/^	int inter, fastinter, downinter;        \/* checks: time in milliseconds *\/$/;"	m	struct:check
drain	include/types/protocol.h	/^	int (*drain)(int fd);                           \/* indicates whether we can safely close the fd *\/$/;"	m	struct:protocol
dst_addr	include/types/connection.h	/^			uint32_t dst_addr;$/;"	m	struct:proxy_hdr_v2::__anon81::__anon82
dst_addr	include/types/connection.h	/^			uint8_t  dst_addr[16];$/;"	m	struct:proxy_hdr_v2::__anon81::__anon83
dst_addr	include/types/connection.h	/^			uint8_t dst_addr[108];$/;"	m	struct:proxy_hdr_v2::__anon81::__anon84
dst_port	include/types/connection.h	/^			uint16_t dst_port;$/;"	m	struct:proxy_hdr_v2::__anon81::__anon82
dst_port	include/types/connection.h	/^			uint16_t dst_port;$/;"	m	struct:proxy_hdr_v2::__anon81::__anon83
dump	src/haproxy.c	/^void dump(struct sig_handler *sh)$/;"	f
dump_binary	src/dumpstats.c	/^static int dump_binary(struct chunk *out, const char *buf, int bsize)$/;"	f	file:
dump_hash_results	tests/ip-hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f
dump_hash_results	tests/uri_hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f
dump_pools	src/memory.c	/^void dump_pools(void)$/;"	f
dump_pools_to_trash	src/memory.c	/^void dump_pools_to_trash()$/;"	f
dump_text	src/dumpstats.c	/^static int dump_text(struct chunk *out, const char *buf, int bsize)$/;"	f	file:
dump_text_line	src/dumpstats.c	/^static int dump_text_line(struct chunk *out, const char *buf, int bsize, int len,$/;"	f	file:
duration	include/types/checks.h	/^	long duration;				\/* time in ms took to finish last health check *\/$/;"	m	struct:check
dynamic	include/types/proxy.h	/^	int dynamic;				\/* this is a dynamic rule using the logformat expression *\/$/;"	m	struct:switching_rule
eb32_delete	ebtree/eb32tree.h	/^static inline void eb32_delete(struct eb32_node *eb32)$/;"	f
eb32_entry	ebtree/eb32tree.h	28;"	d
eb32_first	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_first(struct eb_root *root)$/;"	f
eb32_insert	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new)$/;"	f
eb32_last	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_last(struct eb_root *root)$/;"	f
eb32_lookup	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x)$/;"	f
eb32_lookup_ge	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x)$/;"	f
eb32_lookup_le	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x)$/;"	f
eb32_next	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next(struct eb32_node *eb32)$/;"	f
eb32_next_dup	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next_dup(struct eb32_node *eb32)$/;"	f
eb32_next_unique	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next_unique(struct eb32_node *eb32)$/;"	f
eb32_node	ebtree/eb32tree.h	/^struct eb32_node {$/;"	s
eb32_prev	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev(struct eb32_node *eb32)$/;"	f
eb32_prev_dup	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev_dup(struct eb32_node *eb32)$/;"	f
eb32_prev_unique	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev_unique(struct eb32_node *eb32)$/;"	f
eb32i_insert	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new)$/;"	f
eb32i_lookup	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x)$/;"	f
eb64_delete	ebtree/eb64tree.h	/^static inline void eb64_delete(struct eb64_node *eb64)$/;"	f
eb64_entry	ebtree/eb64tree.h	28;"	d
eb64_first	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_first(struct eb_root *root)$/;"	f
eb64_insert	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new)$/;"	f
eb64_last	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_last(struct eb_root *root)$/;"	f
eb64_lookup	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x)$/;"	f
eb64_lookup_ge	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x)$/;"	f
eb64_lookup_le	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x)$/;"	f
eb64_next	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next(struct eb64_node *eb64)$/;"	f
eb64_next_dup	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next_dup(struct eb64_node *eb64)$/;"	f
eb64_next_unique	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next_unique(struct eb64_node *eb64)$/;"	f
eb64_node	ebtree/eb64tree.h	/^struct eb64_node {$/;"	s
eb64_prev	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev(struct eb64_node *eb64)$/;"	f
eb64_prev_dup	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev_dup(struct eb64_node *eb64)$/;"	f
eb64_prev_unique	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev_unique(struct eb64_node *eb64)$/;"	f
eb64i_insert	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new)$/;"	f
eb64i_lookup	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x)$/;"	f
eb_clrtag	ebtree/ebtree.h	/^static inline struct eb_root *eb_clrtag(const eb_troot_t *troot)$/;"	f
eb_delete	ebtree/ebtree.c	/^void eb_delete(struct eb_node *node)$/;"	f
eb_dotag	ebtree/ebtree.h	/^static inline eb_troot_t *eb_dotag(const struct eb_root *root, const int tag)$/;"	f
eb_entry	ebtree/ebtree.h	383;"	d
eb_first	ebtree/ebtree.h	/^static inline struct eb_node *eb_first(struct eb_root *root)$/;"	f
eb_gettag	ebtree/ebtree.h	/^static inline int eb_gettag(eb_troot_t *troot)$/;"	f
eb_insert_dup	ebtree/ebtree.c	/^REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f
eb_is_dup	ebtree/ebtree.h	/^static inline int eb_is_dup(struct eb_node *node)$/;"	f
eb_is_empty	ebtree/ebtree.h	/^static inline int eb_is_empty(struct eb_root *root)$/;"	f
eb_last	ebtree/ebtree.h	/^static inline struct eb_node *eb_last(struct eb_root *root)$/;"	f
eb_next	ebtree/ebtree.h	/^static inline struct eb_node *eb_next(struct eb_node *node)$/;"	f
eb_next_dup	ebtree/ebtree.h	/^static inline struct eb_node *eb_next_dup(struct eb_node *node)$/;"	f
eb_next_unique	ebtree/ebtree.h	/^static inline struct eb_node *eb_next_unique(struct eb_node *node)$/;"	f
eb_node	ebtree/ebtree.h	/^struct eb_node {$/;"	s
eb_prev	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev(struct eb_node *node)$/;"	f
eb_prev_dup	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev_dup(struct eb_node *node)$/;"	f
eb_prev_unique	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev_unique(struct eb_node *node)$/;"	f
eb_root	ebtree/ebtree.h	/^struct eb_root {$/;"	s
eb_root_to_node	ebtree/ebtree.h	/^static inline struct eb_node *eb_root_to_node(struct eb_root *root)$/;"	f
eb_troot_t	ebtree/ebtree.h	/^typedef void eb_troot_t;$/;"	t
eb_untag	ebtree/ebtree.h	/^static inline struct eb_root *eb_untag(const eb_troot_t *troot, const int tag)$/;"	f
eb_walk_down	ebtree/ebtree.h	/^static inline struct eb_node *eb_walk_down(eb_troot_t *start, unsigned int side)$/;"	f
ebim_insert	ebtree/ebimtree.c	/^ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f
ebim_lookup	ebtree/ebimtree.c	/^ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
ebis_insert	ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebis_lookup	ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x)$/;"	f
ebis_lookup_len	ebtree/ebistree.h	/^ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f
ebmb_delete	ebtree/ebmbtree.h	/^static forceinline void ebmb_delete(struct ebmb_node *ebmb)$/;"	f
ebmb_entry	ebtree/ebmbtree.h	28;"	d
ebmb_first	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_first(struct eb_root *root)$/;"	f
ebmb_insert	ebtree/ebmbtree.c	/^ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
ebmb_insert_prefix	ebtree/ebmbtree.c	/^ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
ebmb_last	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_last(struct eb_root *root)$/;"	f
ebmb_lookup	ebtree/ebmbtree.c	/^ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
ebmb_lookup_longest	ebtree/ebmbtree.c	/^ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f
ebmb_lookup_prefix	ebtree/ebmbtree.c	/^ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f
ebmb_next	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next(struct ebmb_node *ebmb)$/;"	f
ebmb_next_dup	ebtree/ebmbtree.h	/^static inline struct ebmb_node *ebmb_next_dup(struct ebmb_node *ebmb)$/;"	f
ebmb_next_unique	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next_unique(struct ebmb_node *ebmb)$/;"	f
ebmb_node	ebtree/ebmbtree.h	/^struct ebmb_node {$/;"	s
ebmb_prev	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev(struct ebmb_node *ebmb)$/;"	f
ebmb_prev_dup	ebtree/ebmbtree.h	/^static inline struct ebmb_node *ebmb_prev_dup(struct ebmb_node *ebmb)$/;"	f
ebmb_prev_unique	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev_unique(struct ebmb_node *ebmb)$/;"	f
ebpt_delete	ebtree/ebpttree.h	/^static forceinline void ebpt_delete(struct ebpt_node *ebpt)$/;"	f
ebpt_entry	ebtree/ebpttree.h	30;"	d
ebpt_first	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_first(struct eb_root *root)$/;"	f
ebpt_insert	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebpt_insert	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebpt_last	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_last(struct eb_root *root)$/;"	f
ebpt_lookup	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_lookup	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_ge	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_ge	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_le	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_le	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f
ebpt_next	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next(struct ebpt_node *ebpt)$/;"	f
ebpt_next_dup	ebtree/ebpttree.h	/^static inline struct ebpt_node *ebpt_next_dup(struct ebpt_node *ebpt)$/;"	f
ebpt_next_unique	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next_unique(struct ebpt_node *ebpt)$/;"	f
ebpt_node	ebtree/ebpttree.h	/^struct ebpt_node {$/;"	s
ebpt_prev	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev(struct ebpt_node *ebpt)$/;"	f
ebpt_prev_dup	ebtree/ebpttree.h	/^static inline struct ebpt_node *ebpt_prev_dup(struct ebpt_node *ebpt)$/;"	f
ebpt_prev_unique	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev_unique(struct ebpt_node *ebpt)$/;"	f
ebst_insert	ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f
ebst_lookup	ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x)$/;"	f
ebst_lookup_len	ebtree/ebsttree.h	/^ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f
ecdhe	include/types/listener.h	/^	char *ecdhe;               \/* named curve to use for ECDHE *\/$/;"	m	struct:bind_conf
elt	include/types/stream_interface.h	/^			struct pat_ref_elt *elt;$/;"	m	struct:appctx::__anon43::__anon50	typeref:struct:appctx::__anon43::__anon50::pat_ref_elt
emit_hex	src/trace.c	/^static char *emit_hex(unsigned long h, char *out)$/;"	f	file:
empty_arg_list	src/arg.c	/^struct arg empty_arg_list[8] = { };$/;"	v	typeref:struct:arg
enable_all	include/types/protocol.h	/^	int (*enable_all)(struct protocol *proto);	\/* enable all bound listeners *\/$/;"	m	struct:protocol
enable_all_listeners	src/listener.c	/^int enable_all_listeners(struct protocol *proto)$/;"	f
enable_listener	src/listener.c	/^void enable_listener(struct listener *listener)$/;"	f
encode_chunk	src/standard.c	/^char *encode_chunk(char *start, char *stop,$/;"	f
encode_string	src/standard.c	/^char *encode_string(char *start, char *stop,$/;"	f
end	include/types/compression.h	/^	int (*end)(struct comp_ctx **comp_ctx);$/;"	m	struct:comp_algo
end	include/types/stream_interface.h	/^	enum obj_type *end;     \/* points to the end point (connection or appctx) *\/$/;"	m	struct:stream_interface	typeref:enum:stream_interface::obj_type
entry	include/types/session.h	/^	unsigned long   entry;          \/* entry containing counters currently being tracked by this session  *\/$/;"	m	struct:stkctr
entry	include/types/stream_interface.h	/^			struct stksess *entry;	\/* last entry we were trying to dump (or first if NULL) *\/$/;"	m	struct:appctx::__anon43::__anon47	typeref:struct:appctx::__anon43::__anon47::stksess
env_expand	src/standard.c	/^char *env_expand(char *in)$/;"	f
eoh	include/types/proto_http.h	/^	unsigned int eoh;                      \/* End Of Headers, relative to buffer *\/$/;"	m	struct:http_msg
eol	include/types/proto_http.h	/^	unsigned int eol;                      \/* end of line *\/$/;"	m	struct:http_msg
eol	src/shctx.c	/^	unsigned int eol;$/;"	m	struct:shsess_packet_hdr	file:
epoll_event	include/common/epoll.h	/^struct epoll_event {$/;"	s
epoll_events	src/ev_epoll.c	/^static struct epoll_event *epoll_events;$/;"	v	typeref:struct:epoll_event	file:
epoll_fd	src/ev_epoll.c	/^static int epoll_fd;$/;"	v	file:
equal_bits	ebtree/ebtree.h	/^static forceinline int equal_bits(const unsigned char *a,$/;"	f
err	include/types/stream_interface.h	/^			char *err;        \/* pointer to a 'must free' message to be returned in PRINT_FREE state *\/$/;"	m	struct:appctx::__anon43::__anon48
err_code	include/types/connection.h	/^	unsigned char err_code;       \/* CO_ER_* *\/$/;"	m	struct:connection
err_pos	include/types/proto_http.h	/^	int err_pos;                           \/* err handling: -2=block, -1=pass, 0+=detected *\/$/;"	m	struct:http_msg
err_type	include/types/stream_interface.h	/^	unsigned int err_type;  \/* first error detected, one of SI_ET_* *\/$/;"	m	struct:stream_interface
errmsg	include/types/proxy.h	/^	struct chunk errmsg[HTTP_ERR_SIZE];	\/* default or customized error messages for known errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::chunk
error_snapshot	include/types/proxy.h	/^struct error_snapshot {$/;"	s
error_snapshot_id	src/proxy.c	/^unsigned int error_snapshot_id = 0;     \/* global ID assigned to each error then incremented *\/$/;"	v
errors	include/types/stream_interface.h	/^		} errors;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon46
ev	include/types/fd.h	/^	unsigned char ev;                    \/* event seen in return of poll() : FD_POLL_* *\/$/;"	m	struct:fdtab
ev	src/ev_epoll.c	/^static struct epoll_event ev;$/;"	v	typeref:struct:epoll_event	file:
ev_id	include/types/proxy.h	/^	unsigned int ev_id;		\/* event number (counter incremented for each capture) *\/$/;"	m	struct:error_snapshot
event_srv_chk_r	src/checks.c	/^static void event_srv_chk_r(struct connection *conn)$/;"	f	file:
event_srv_chk_w	src/checks.c	/^static void event_srv_chk_w(struct connection *conn)$/;"	f	file:
events	include/common/epoll.h	/^	uint32_t events;$/;"	m	struct:epoll_event
eweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
except_mask	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::
except_mask_to	include/types/proxy.h	/^	struct in_addr except_mask_to;		\/* the netmask for except_to. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
except_net	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
except_to	include/types/proxy.h	/^	struct in_addr except_to;		\/* don't x-original-to for this address. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
exp	include/types/stick_table.h	/^	struct eb32_node exp;     \/* ebtree node used to hold the session in expiration tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node
exp	include/types/stream_interface.h	/^	unsigned int exp;       \/* wake up time for connect, queue, turn-around, ... *\/$/;"	m	struct:stream_interface
exp_next	include/types/stick_table.h	/^	int exp_next;             \/* next expiration date (ticks) *\/$/;"	m	struct:stktable
exp_replace	src/regex.c	/^int exp_replace(char *dst, unsigned int dst_size, char *src, const char *str, const regmatch_t *matches)$/;"	f
exp_task	include/types/stick_table.h	/^	struct task *exp_task;    \/* expiration task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task
expect_frontend_admin	src/dumpstats.c	/^static struct proxy *expect_frontend_admin(struct session *s, struct stream_interface *si, const char *arg)$/;"	f	file:
expect_regex	include/types/checks.h	/^	struct my_regex *expect_regex;          \/* expected *\/$/;"	m	struct:tcpcheck_rule	typeref:struct:tcpcheck_rule::my_regex
expect_regex	include/types/proxy.h	/^	struct my_regex *expect_regex;		\/* http-check expected content *\/$/;"	m	struct:proxy	typeref:struct:proxy::my_regex
expect_server_admin	src/dumpstats.c	/^static struct server *expect_server_admin(struct session *s, struct stream_interface *si, char *arg)$/;"	f	file:
expect_str	include/types/proxy.h	/^	char *expect_str;			\/* http-check expected content : string or text version of the regex *\/$/;"	m	struct:proxy
expect_type	include/types/pattern.h	/^	int expect_type; \/* type of the expected sample (SMP_T_*) *\/$/;"	m	struct:pattern_head
expire	include/common/appsession.h	/^	int   expire;		\/* next expiration time for this application session (in tick) *\/$/;"	m	struct:appsessions
expire	include/types/stick_table.h	/^	int expire;               \/* time to live for sticky sessions (milliseconds) *\/$/;"	m	struct:stktable
expire	include/types/stick_table.h	/^	unsigned int expire;      \/* session expiration date *\/$/;"	m	struct:stksess
expire	include/types/task.h	/^	int expire;			\/* next expiration date for this task, in ticks *\/$/;"	m	struct:task
expire_mini_session	src/session.c	/^static struct task *expire_mini_session(struct task *t)$/;"	f	file:
expr	include/types/acl.h	/^	struct list expr;	    \/* list of acl_exprs *\/$/;"	m	struct:acl	typeref:struct:acl::list
expr	include/types/log.h	/^	void *expr;    \/\/ for use with LOG_FMT_EXPR$/;"	m	struct:logformat_node
expr	include/types/pattern.h	/^	struct pattern_expr *expr; \/* The used expr. *\/$/;"	m	struct:pattern_expr_list	typeref:struct:pattern_expr_list::pattern_expr
expr	include/types/proto_tcp.h	/^	struct sample_expr *expr;               \/* expression used as the key *\/$/;"	m	struct:capture_prm	typeref:struct:capture_prm::sample_expr
expr	include/types/proxy.h	/^		struct list expr;		\/* logformat expression to use for dynamic rules *\/$/;"	m	union:switching_rule::__anon20	typeref:struct:switching_rule::__anon20::list
expr	include/types/proxy.h	/^	struct sample_expr *expr;               \/* fetch expr to fetch key *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::sample_expr
expr	include/types/session.h	/^	struct sample_expr *expr;		\/* expression used as the key *\/$/;"	m	struct:track_ctr_prm	typeref:struct:track_ctr_prm::sample_expr
expr	include/types/stream_interface.h	/^			struct pattern_expr *expr;$/;"	m	struct:appctx::__anon43::__anon50	typeref:struct:appctx::__anon43::__anon50::pattern_expr
expr	src/acl.c	/^	const char *expr[4]; \/* put enough for longest expression *\/$/;"	m	struct:__anon114	file:
exps	include/types/stick_table.h	/^	struct eb_root exps;      \/* head of sticky session expiration tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
extra	include/common/regex.h	/^	pcre_extra *extra;$/;"	m	struct:my_regex
extract_cookie_value	src/proto_http.c	/^extract_cookie_value(char *hdr, const char *hdr_end,$/;"	f	file:
facility	include/types/log.h	/^	int facility;$/;"	m	struct:logsrv
faddr	include/import/ip_tproxy.h	/^	struct in_addr	faddr;$/;"	m	struct:in_tproxy_addr	typeref:struct:in_tproxy_addr::in_addr
failed_checks	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters
failed_conns	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters
failed_conns	include/types/counters.h	/^	long long failed_conns;                 \/* failed connect() attempts (BE only) *\/$/;"	m	struct:pxcounters
failed_hana	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters
failed_req	include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:licounters
failed_req	include/types/counters.h	/^	long long failed_req;                   \/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:pxcounters
failed_resp	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters
failed_resp	include/types/counters.h	/^	long long failed_resp;                  \/* failed responses (BE only) *\/$/;"	m	struct:pxcounters
failed_secu	include/types/counters.h	/^	long long failed_secu;			\/* blocked responses because of security concerns *\/$/;"	m	struct:srvcounters
fall	include/types/checks.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:check
fam	include/types/connection.h	/^	uint8_t fam;       \/* protocol family and transport *\/$/;"	m	struct:proxy_hdr_v2
fas	include/types/backend.h	/^	struct lb_fas fas;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fas
fas_dequeue_srv	src/lb_fas.c	/^static inline void fas_dequeue_srv(struct server *s)$/;"	f	file:
fas_get_next_server	src/lb_fas.c	/^struct server *fas_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fas_init_server_tree	src/lb_fas.c	/^void fas_init_server_tree(struct proxy *p)$/;"	f
fas_queue_srv	src/lb_fas.c	/^static inline void fas_queue_srv(struct server *s)$/;"	f	file:
fas_remove_from_tree	src/lb_fas.c	/^static inline void fas_remove_from_tree(struct server *s)$/;"	f	file:
fas_set_server_status_down	src/lb_fas.c	/^static void fas_set_server_status_down(struct server *srv)$/;"	f	file:
fas_set_server_status_up	src/lb_fas.c	/^static void fas_set_server_status_up(struct server *srv)$/;"	f	file:
fas_srv_reposition	src/lb_fas.c	/^static void fas_srv_reposition(struct server *s)$/;"	f	file:
fas_update_server_weight	src/lb_fas.c	/^static void fas_update_server_weight(struct server *srv)$/;"	f	file:
fast_time	src/trace.c	/^static int fast_time;$/;"	v	file:
fastinter	include/types/checks.h	/^	int inter, fastinter, downinter;        \/* checks: time in milliseconds *\/$/;"	m	struct:check
fbck	include/types/backend.h	/^	struct server *fbck;		\/* first backup server when !PR_O_USE_ALL_BK, or NULL *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::server
fct	include/types/stream_interface.h	/^	void (*fct)(struct stream_interface *);      \/* internal I\/O handler, may never be NULL *\/$/;"	m	struct:si_applet
fd	include/common/epoll.h	/^		int fd;$/;"	m	union:epoll_event::__anon104
fd	include/types/connection.h	/^			int fd;       \/* file descriptor for a stream driver when known *\/$/;"	m	struct:connection::__anon78::__anon79
fd	include/types/listener.h	/^	int fd;				\/* the listen socket *\/$/;"	m	struct:listener
fd_alloc_cache_entry	include/proto/fd.h	/^static inline void fd_alloc_cache_entry(const int fd)$/;"	f
fd_alloc_or_release_cache_entry	include/proto/fd.h	/^static inline void fd_alloc_or_release_cache_entry(int fd, int new_state)$/;"	f
fd_cache	src/fd.c	/^unsigned int *fd_cache = NULL; \/\/ FD events cache$/;"	v
fd_cache_num	src/fd.c	/^int fd_cache_num = 0;          \/\/ number of events in the cache$/;"	v
fd_cant_recv	include/proto/fd.h	/^static inline void fd_cant_recv(const int fd)$/;"	f
fd_cant_send	include/proto/fd.h	/^static inline void fd_cant_send(const int fd)$/;"	f
fd_compute_new_polled_status	include/proto/fd.h	/^static inline int fd_compute_new_polled_status(int state)$/;"	f
fd_delete	src/fd.c	/^void fd_delete(int fd)$/;"	f
fd_done_recv	include/proto/fd.h	/^static inline void fd_done_recv(const int fd)$/;"	f
fd_evts	src/ev_poll.c	/^static unsigned int *fd_evts[2];$/;"	v	file:
fd_evts	src/ev_select.c	/^static fd_set *fd_evts[2];$/;"	v	file:
fd_insert	include/proto/fd.h	/^static inline void fd_insert(int fd)$/;"	f
fd_may_recv	include/proto/fd.h	/^static inline void fd_may_recv(const int fd)$/;"	f
fd_may_send	include/proto/fd.h	/^static inline void fd_may_send(const int fd)$/;"	f
fd_nbupdt	src/fd.c	/^int fd_nbupdt = 0;             \/\/ number of updates in the list$/;"	v
fd_process_cached_events	src/fd.c	/^void fd_process_cached_events()$/;"	f
fd_process_polled_events	src/fd.c	/^void fd_process_polled_events(int fd)$/;"	f
fd_recv_active	include/proto/fd.h	/^static inline int fd_recv_active(const int fd)$/;"	f
fd_recv_polled	include/proto/fd.h	/^static inline int fd_recv_polled(const int fd)$/;"	f
fd_recv_ready	include/proto/fd.h	/^static inline int fd_recv_ready(const int fd)$/;"	f
fd_recv_state	include/proto/fd.h	/^static inline int fd_recv_state(const int fd)$/;"	f
fd_release_cache_entry	include/proto/fd.h	/^static inline void fd_release_cache_entry(int fd)$/;"	f
fd_send_active	include/proto/fd.h	/^static inline int fd_send_active(const int fd)$/;"	f
fd_send_polled	include/proto/fd.h	/^static inline int fd_send_polled(const int fd)$/;"	f
fd_send_ready	include/proto/fd.h	/^static inline int fd_send_ready(const int fd)$/;"	f
fd_send_state	include/proto/fd.h	/^static inline int fd_send_state(const int fd)$/;"	f
fd_states	include/types/fd.h	/^enum fd_states {$/;"	g
fd_stop_both	include/proto/fd.h	/^static inline void fd_stop_both(int fd)$/;"	f
fd_stop_recv	include/proto/fd.h	/^static inline void fd_stop_recv(int fd)$/;"	f
fd_stop_send	include/proto/fd.h	/^static inline void fd_stop_send(int fd)$/;"	f
fd_updt	src/fd.c	/^unsigned int *fd_updt = NULL;  \/\/ FD updates list$/;"	v
fd_want_recv	include/proto/fd.h	/^static inline void fd_want_recv(int fd)$/;"	f
fd_want_send	include/proto/fd.h	/^static inline void fd_want_send(int fd)$/;"	f
fddebug	include/common/standard.h	849;"	d
fdinfo	include/types/fd.h	/^struct fdinfo {$/;"	s
fdinfo	src/fd.c	/^struct fdinfo *fdinfo = NULL;   \/* less-often used infos for file descriptors *\/$/;"	v	typeref:struct:fdinfo
fdtab	include/types/fd.h	/^struct fdtab {$/;"	s
fdtab	src/fd.c	/^struct fdtab *fdtab = NULL;     \/* array of all the file descriptors *\/$/;"	v	typeref:struct:fdtab
fe	include/types/session.h	/^	struct proxy *fe;			\/* the proxy this session depends on for the client side *\/$/;"	m	struct:session	typeref:struct:session::proxy
fe_conn_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_conn_per_sec;	\/* received connections per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_counters	include/types/proxy.h	/^	struct pxcounters fe_counters;		\/* frontend statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters
fe_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
fe_req_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_req_per_sec;		\/* HTTP requests per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
fe_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_sess_per_sec;	\/* accepted sessions per second on the frontend (after tcp rules) *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_sps_lim	include/types/proxy.h	/^	unsigned int fe_sps_lim;		\/* limit on new sessions per second on the frontend *\/$/;"	m	struct:proxy
feconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy
fetch	include/types/sample.h	/^	struct sample_fetch *fetch;               \/* sample fetch method *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::sample_fetch
fetch_cap	src/sample.c	/^const unsigned int fetch_cap[SMP_SRC_ENTRIES] = {$/;"	v
fetch_ckp_names	src/sample.c	/^static const char *fetch_ckp_names[SMP_CKP_ENTRIES] = {$/;"	v	file:
fetch_kw	include/types/acl.h	/^	char *fetch_kw;$/;"	m	struct:acl_keyword
fetch_rdp_cookie_name	src/payload.c	/^fetch_rdp_cookie_name(struct session *s, struct sample *smp, const char *cname, int clen)$/;"	f
fetch_src_names	src/sample.c	/^static const char *fetch_src_names[SMP_SRC_ENTRIES] = {$/;"	v	file:
fgets2	contrib/halog/fgets2.c	/^const char *fgets2(FILE *stream)$/;"	f
field_start	contrib/halog/halog.c	/^const char *field_start(const char *p, int field)$/;"	f
field_stop	contrib/halog/halog.c	/^const char *field_stop(const char *p)$/;"	f
field_stop	contrib/halog/halog.c	/^static inline const char *field_stop(const char *p)$/;"	f	file:
file	include/types/acl.h	/^	const char *file;           \/* config file where the condition is declared *\/$/;"	m	struct:acl_cond
file	include/types/arg.h	/^	const char *file;         \/* file name where the args are referenced *\/$/;"	m	struct:arg_list
file	include/types/listener.h	/^	char *file;                \/* file where the section appears *\/$/;"	m	struct:bind_conf
file	include/types/peers.h	/^		const char *file;	 \/* file where the section appears *\/$/;"	m	struct:peers::__anon24
file	include/types/peers.h	/^		const char *file; \/* file where the section appears *\/$/;"	m	struct:peer::__anon23
file	include/types/proxy.h	/^		char *file;			\/* file where the section appears *\/$/;"	m	struct:proxy::__anon19
file	include/types/server.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:server::__anon100
filter	contrib/halog/halog.c	/^unsigned int filter = 0;$/;"	v
filter2	contrib/halog/halog.c	/^unsigned int filter2 = 0;$/;"	v
filter_accept_holes	contrib/halog/halog.c	/^void filter_accept_holes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_cook_codes	contrib/halog/halog.c	/^void filter_count_cook_codes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_ip	contrib/halog/halog.c	/^void filter_count_ip(const char *source_field, const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_srv_status	contrib/halog/halog.c	/^void filter_count_srv_status(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_status	contrib/halog/halog.c	/^void filter_count_status(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_term_codes	contrib/halog/halog.c	/^void filter_count_term_codes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_url	contrib/halog/halog.c	/^void filter_count_url(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_graphs	contrib/halog/halog.c	/^void filter_graphs(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_invert	contrib/halog/halog.c	/^unsigned int filter_invert = 0;$/;"	v
filter_output_line	contrib/halog/halog.c	/^void filter_output_line(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
final	src/shctx.c	/^	unsigned char final:1;$/;"	m	struct:shsess_packet_hdr	file:
final	tests/test_hashes.c	389;"	d	file:
find_acl_by_name	src/acl.c	/^struct acl *find_acl_by_name(const char *name, struct list *head)$/;"	f
find_acl_default	src/acl.c	/^static struct acl *find_acl_default(const char *acl_name, struct list *known_acl,$/;"	f	file:
find_acl_kw	src/acl.c	/^struct acl_keyword *find_acl_kw(const char *kw)$/;"	f
find_cookie_value_end	src/proto_http.c	/^char *find_cookie_value_end(char *s, const char *e)$/;"	f
find_hdr_value_end	src/proto_http.c	/^char *find_hdr_value_end(char *s, const char *e)$/;"	f
find_http_meth	src/proto_http.c	/^enum http_meth_t find_http_meth(const char *str, const int len)$/;"	f
find_lf	contrib/halog/fgets2.c	/^static char *find_lf(char *next, char *end)$/;"	f	file:
find_next_stat_id	contrib/netsnmp-perl/haproxy.pl	/^sub find_next_stat_id {$/;"	s
find_param_list	src/proto_http.c	/^static inline char *find_param_list(char *path, size_t path_l, char delim)$/;"	f	file:
find_sample_conv	src/sample.c	/^struct sample_conv *find_sample_conv(const char *kw, int len)$/;"	f
find_sample_fetch	src/sample.c	/^struct sample_fetch *find_sample_fetch(const char *kw, int len)$/;"	f
find_stktable	src/stick_table.c	/^struct proxy *find_stktable(const char *name)$/;"	f
find_url_param_pos	src/proto_http.c	/^find_url_param_pos(char* query_string, size_t query_string_l,$/;"	f	file:
find_url_param_value	src/proto_http.c	/^find_url_param_value(char* path, size_t path_l,$/;"	f	file:
findproxy	src/proxy.c	/^struct proxy *findproxy(const char *name, int cap) {$/;"	f
findproxy_mode	src/proxy.c	/^struct proxy *findproxy_mode(const char *name, int mode, int cap) {$/;"	f
findserver	src/proxy.c	/^struct server *findserver(const struct proxy *px, const char *name) {$/;"	f
flags	include/common/memory.h	/^	unsigned int flags;	\/* MEM_F_* *\/$/;"	m	struct:pool_head
flags	include/common/uri_auth.h	/^	int flags;			\/* some flags describing the statistics page *\/$/;"	m	struct:uri_auth
flags	include/import/ip_tproxy.h	/^		u_int32_t		flags;$/;"	m	union:in_tproxy::_in_args
flags	include/types/auth.h	/^	unsigned int flags;$/;"	m	struct:auth_users
flags	include/types/channel.h	/^	unsigned int flags;             \/* CF_* *\/$/;"	m	struct:channel
flags	include/types/connection.h	/^	unsigned int flags;           \/* CO_FL_* *\/$/;"	m	struct:connection
flags	include/types/pattern.h	/^	unsigned int flags; \/* flags PAT_REF_*. *\/$/;"	m	struct:pat_ref
flags	include/types/peers.h	/^	unsigned int flags;		    \/* current table resync state *\/$/;"	m	struct:shared_table
flags	include/types/peers.h	/^	unsigned int flags; 	      \/* peer session flags *\/$/;"	m	struct:peer_session
flags	include/types/proto_http.h	/^	unsigned char flags;                   \/* flags describing the message (HTTP version, ...) *\/$/;"	m	struct:http_msg
flags	include/types/proto_http.h	/^	unsigned int flags;             \/* transaction flags *\/$/;"	m	struct:http_txn
flags	include/types/proxy.h	/^	int flags;                              \/* STK_* *\/$/;"	m	struct:sticking_rule
flags	include/types/proxy.h	/^	unsigned int flags;$/;"	m	struct:redirect_rule
flags	include/types/sample.h	/^	unsigned int flags;       \/* SMP_F_* *\/$/;"	m	struct:sample
flags	include/types/server.h	/^	unsigned char flags;                    \/* server flags (SRV_F_*) *\/$/;"	m	struct:server
flags	include/types/session.h	/^	int flags;				\/* some flags describing the session *\/$/;"	m	struct:session
flags	include/types/signal.h	/^	int flags;                      \/* SIG_F_* *\/$/;"	m	struct:sig_handler
flags	include/types/stick_table.h	/^	int flags;                \/* type flags *\/$/;"	m	struct:stktable_type
flags	include/types/stream_interface.h	/^			unsigned int flags;	\/* STAT_* *\/$/;"	m	struct:appctx::__anon43::__anon44
flags	include/types/stream_interface.h	/^	unsigned short flags;    \/* SI_FL_* *\/$/;"	m	struct:stream_interface
fls64	ebtree/ebtree.h	/^static inline int fls64(unsigned long long x)$/;"	f
fls_auto	ebtree/ebtree.h	315;"	d
flsnz	ebtree/ebtree.h	/^static inline int flsnz(int x)$/;"	f
flsnz	ebtree/ebtree.h	283;"	d
flsnz8	ebtree/ebtree.h	/^static inline int flsnz8(unsigned char x)$/;"	f
flsnz8	ebtree/ebtree.h	/^static inline int flsnz8(unsigned int x)$/;"	f
flsnz8_generic	ebtree/ebtree.h	/^static inline int flsnz8_generic(unsigned int x)$/;"	f
flush	include/types/compression.h	/^	int (*flush)(struct comp_ctx *comp_ctx, struct buffer *out, int flag);$/;"	m	struct:comp_algo
fmt	include/types/proto_http.h	/^			struct list fmt;       \/* log-format compatible expression *\/$/;"	m	struct:http_req_rule::__anon67::__anon69	typeref:struct:http_req_rule::__anon67::__anon69::list
fmt	include/types/proto_http.h	/^			struct list fmt;       \/* log-format compatible expression *\/$/;"	m	struct:http_res_rule::__anon71::__anon72	typeref:struct:http_res_rule::__anon71::__anon72::list
fmt_directive	src/log.c	/^static inline const char *fmt_directive(const struct proxy *curproxy)$/;"	f	file:
fnv_32a_str	tests/test_hashes.c	/^fnv_32a_str(char *str, Fnv32_t hval)$/;"	f
fnv_hash	tests/test_hashes.c	/^unsigned fnv_hash ( void *key, int len )$/;"	f
forceinline	include/common/compiler.h	74;"	d
forceinline	include/common/compiler.h	76;"	d
foreach_dlist_item	include/common/mini-clist.h	100;"	d
foreach_dlist_item_cst	include/common/mini-clist.h	94;"	d
fork	include/types/fd.h	/^	int  REGPRM1   (*fork)(struct poller *p);            \/* post-fork re-opening *\/$/;"	m	struct:poller
fork_poller	src/fd.c	/^int fork_poller()$/;"	f
format_unique_id	include/types/proxy.h	/^	struct list format_unique_id;		\/* unique-id format *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
fport	include/import/ip_tproxy.h	/^	u_int16_t	fport;$/;"	m	struct:in_tproxy_addr
free	src/shctx.c	/^	struct shared_block free;$/;"	m	struct:shared_context	typeref:struct:shared_context::shared_block	file:
free_func	src/compression.c	22;"	d	file:
free_func	src/compression.c	24;"	d	file:
free_http_req_rules	src/proto_http.c	/^void free_http_req_rules(struct list *r)$/;"	f
free_http_res_rules	src/proto_http.c	/^void free_http_res_rules(struct list *r)$/;"	f
free_list	include/common/memory.h	/^	void **free_list;$/;"	m	struct:pool_head
free_pattern_tree	src/pattern.c	/^void free_pattern_tree(struct eb_root *root)$/;"	f
free_zlib	src/compression.c	/^static void free_zlib(void *opaque, void *ptr)$/;"	f	file:
freq_ctr	include/types/freq_ctr.h	/^struct freq_ctr {$/;"	s
freq_ctr_period	include/types/freq_ctr.h	/^struct freq_ctr_period {$/;"	s
freq_ctr_remain	src/freq_ctr.c	/^unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f
freq_ctr_remain_period	src/freq_ctr.c	/^unsigned int freq_ctr_remain_period(struct freq_ctr_period *ctr, unsigned int period,$/;"	f
from	include/types/connection.h	/^		struct sockaddr_storage from;	\/* client address, or address to spoof when connecting to the server *\/$/;"	m	struct:connection::__anon80	typeref:struct:connection::__anon80::sockaddr_storage
frontend	include/types/listener.h	/^	struct proxy *frontend;		\/* the frontend this listener belongs to, or NULL *\/$/;"	m	struct:listener	typeref:struct:listener::proxy
frontend_accept	src/frontend.c	/^int frontend_accept(struct session *s)$/;"	f
full_hash	src/standard.c	/^unsigned int full_hash(unsigned int a)$/;"	f
fullconn	include/types/proxy.h	/^	unsigned int fullconn;			\/* #conns on backend above which servers are used at full load *\/$/;"	m	struct:proxy
fwdfor_hdr_len	include/types/proxy.h	/^	int fwdfor_hdr_len;			\/* length of "x-forwarded-for" header *\/$/;"	m	struct:proxy
fwdfor_hdr_name	include/types/proxy.h	/^	char *fwdfor_hdr_name;			\/* header to use - default: "x-forwarded-for" *\/$/;"	m	struct:proxy
fwlc	include/types/backend.h	/^	struct lb_fwlc fwlc;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwlc
fwlc_dequeue_srv	src/lb_fwlc.c	/^static inline void fwlc_dequeue_srv(struct server *s)$/;"	f	file:
fwlc_get_next_server	src/lb_fwlc.c	/^struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fwlc_init_server_tree	src/lb_fwlc.c	/^void fwlc_init_server_tree(struct proxy *p)$/;"	f
fwlc_queue_srv	src/lb_fwlc.c	/^static inline void fwlc_queue_srv(struct server *s)$/;"	f	file:
fwlc_remove_from_tree	src/lb_fwlc.c	/^static inline void fwlc_remove_from_tree(struct server *s)$/;"	f	file:
fwlc_set_server_status_down	src/lb_fwlc.c	/^static void fwlc_set_server_status_down(struct server *srv)$/;"	f	file:
fwlc_set_server_status_up	src/lb_fwlc.c	/^static void fwlc_set_server_status_up(struct server *srv)$/;"	f	file:
fwlc_srv_reposition	src/lb_fwlc.c	/^static void fwlc_srv_reposition(struct server *s)$/;"	f	file:
fwlc_update_server_weight	src/lb_fwlc.c	/^static void fwlc_update_server_weight(struct server *srv)$/;"	f	file:
fwrr	include/types/backend.h	/^	struct lb_fwrr fwrr;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwrr
fwrr_dequeue_srv	src/lb_fwrr.c	/^static inline void fwrr_dequeue_srv(struct server *s)$/;"	f	file:
fwrr_get_next_server	src/lb_fwrr.c	/^struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fwrr_get_server_from_group	src/lb_fwrr.c	/^static struct server *fwrr_get_server_from_group(struct fwrr_group *grp)$/;"	f	file:
fwrr_get_srv	src/lb_fwrr.c	/^static void fwrr_get_srv(struct server *s)$/;"	f	file:
fwrr_get_srv_down	src/lb_fwrr.c	/^static inline void fwrr_get_srv_down(struct server *s)$/;"	f	file:
fwrr_get_srv_init	src/lb_fwrr.c	/^static inline void fwrr_get_srv_init(struct server *s)$/;"	f	file:
fwrr_get_srv_next	src/lb_fwrr.c	/^static inline void fwrr_get_srv_next(struct server *s)$/;"	f	file:
fwrr_group	include/types/lb_fwrr.h	/^struct fwrr_group {$/;"	s
fwrr_init_server_groups	src/lb_fwrr.c	/^void fwrr_init_server_groups(struct proxy *p)$/;"	f
fwrr_queue_by_weight	src/lb_fwrr.c	/^static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s)$/;"	f	file:
fwrr_queue_srv	src/lb_fwrr.c	/^static void fwrr_queue_srv(struct server *s)$/;"	f	file:
fwrr_remove_from_tree	src/lb_fwrr.c	/^static inline void fwrr_remove_from_tree(struct server *s)$/;"	f	file:
fwrr_set_server_status_down	src/lb_fwrr.c	/^static void fwrr_set_server_status_down(struct server *srv)$/;"	f	file:
fwrr_set_server_status_up	src/lb_fwrr.c	/^static void fwrr_set_server_status_up(struct server *srv)$/;"	f	file:
fwrr_switch_trees	src/lb_fwrr.c	/^static inline void fwrr_switch_trees(struct fwrr_group *grp)$/;"	f	file:
fwrr_update_position	src/lb_fwrr.c	/^static inline void fwrr_update_position(struct fwrr_group *grp, struct server *s)$/;"	f	file:
fwrr_update_server_weight	src/lb_fwrr.c	/^static void fwrr_update_server_weight(struct server *srv)$/;"	f	file:
gen_hash	src/backend.c	/^static unsigned long gen_hash(const struct proxy* px, const char* key, unsigned long len)$/;"	f	file:
get	examples/check	/^sub get$/;"	s
get	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
get16bits	tests/test_hashes.c	150;"	d	file:
get16bits	tests/test_hashes.c	153;"	d	file:
get16bits	tests/test_hashes.c	157;"	d	file:
get16bits	tests/uri_hash.c	184;"	d	file:
get16bits	tests/uri_hash.c	187;"	d	file:
get16bits	tests/uri_hash.c	191;"	d	file:
getRawStat	examples/stats_haproxy.sh	/^getRawStat ()$/;"	f
getStat	examples/stats_haproxy.sh	/^getStat ()$/;"	f
get_addr	contrib/ip6range/ip6range.c	/^static const char *get_addr(struct in6_addr *addr)$/;"	f	file:
get_addr_len	include/common/standard.h	/^static inline int get_addr_len(const struct sockaddr_storage *addr)$/;"	f
get_analyze_status	src/checks.c	/^const char *get_analyze_status(short analyze_status) {$/;"	f
get_backend_server	src/proxy.c	/^int get_backend_server(const char *bk_name, const char *sv_name,$/;"	f
get_bit	ebtree/ebtree.h	/^static forceinline int get_bit(const unsigned char *a, unsigned int pos)$/;"	f
get_check_status_description	src/checks.c	/^const char *get_check_status_description(short check_status) {$/;"	f
get_check_status_info	src/checks.c	/^const char *get_check_status_info(short check_status) {$/;"	f
get_conn_ctrl_name	src/dumpstats.c	/^static inline const char *get_conn_ctrl_name(const struct connection *conn)$/;"	f	file:
get_conn_data_name	src/dumpstats.c	/^static inline const char *get_conn_data_name(const struct connection *conn)$/;"	f	file:
get_conn_xprt_name	src/dumpstats.c	/^static inline const char *get_conn_xprt_name(const struct connection *conn)$/;"	f	file:
get_dst	include/types/protocol.h	/^	int (*get_dst)(int fd, struct sockaddr *, socklen_t, int dir); \/* syscall used to retrieve dst addr *\/$/;"	m	struct:protocol
get_gmtime	include/common/standard.h	/^static inline void get_gmtime(const time_t now, struct tm *tm)$/;"	f
get_host_port	include/common/standard.h	/^static inline int get_host_port(struct sockaddr_storage *addr)$/;"	f
get_http_auth	src/proto_http.c	/^get_http_auth(struct session *s)$/;"	f
get_http_auth_buff	src/proto_http.c	/^char *get_http_auth_buff;$/;"	v
get_ipv4_addr	contrib/iprange/iprange.c	/^static const char *get_ipv4_addr(unsigned int addr)$/;"	f	file:
get_ipv6_addr	contrib/ip6range/ip6range.c	/^static const char *get_ipv6_addr(struct in6_addr *addr)$/;"	f	file:
get_localtime	include/common/standard.h	/^static inline void get_localtime(const time_t now, struct tm *tm)$/;"	f
get_log_facility	src/log.c	/^int get_log_facility(const char *fac)$/;"	f
get_log_level	src/log.c	/^int get_log_level(const char *lev)$/;"	f
get_net_port	include/common/standard.h	/^static inline int get_net_port(struct sockaddr_storage *addr)$/;"	f
get_next_id	src/standard.c	/^unsigned int get_next_id(struct eb_root *root, unsigned int key)$/;"	f
get_next_server	tests/filltab25.c	/^struct srv *get_next_server() {$/;"	f
get_pipe	src/pipe.c	/^struct pipe *get_pipe()$/;"	f
get_server_hh	src/backend.c	/^struct server *get_server_hh(struct session *s)$/;"	f
get_server_ph	src/backend.c	/^struct server *get_server_ph(struct proxy *px, const char *uri, int uri_len)$/;"	f
get_server_ph_post	src/backend.c	/^struct server *get_server_ph_post(struct session *s)$/;"	f
get_server_rch	src/backend.c	/^struct server *get_server_rch(struct session *s)$/;"	f
get_server_sh	src/backend.c	/^struct server *get_server_sh(struct proxy *px, const char *addr, int len)$/;"	f
get_server_uh	src/backend.c	/^struct server *get_server_uh(struct proxy *px, char *uri, int uri_len)$/;"	f
get_src	include/types/protocol.h	/^	int (*get_src)(int fd, struct sockaddr *, socklen_t, int dir); \/* syscall used to retrieve src addr *\/$/;"	m	struct:protocol
get_srv	tests/filltab25.c	/^void get_srv(struct srv *s) {$/;"	f
get_srv_down	tests/filltab25.c	/^static inline void get_srv_down(struct srv *s) {$/;"	f	file:
get_srv_from_appsession	src/proto_http.c	/^void get_srv_from_appsession(struct session *s, const char *begin, int len)$/;"	f
get_srv_init	tests/filltab25.c	/^static inline void get_srv_init(struct srv *s) {$/;"	f	file:
get_srv_next	tests/filltab25.c	/^static inline void get_srv_next(struct srv *s) {$/;"	f	file:
get_std_op	src/standard.c	/^int get_std_op(const char *str)$/;"	f
get_trash_chunk	src/chunk.c	/^struct chunk *get_trash_chunk(void)$/;"	f
getptr	contrib/trace/trace.awk	/^function getptr(ptr)$/;"	f
gid	include/types/global.h	/^			gid_t gid;      \/* -1 to leave unchanged *\/$/;"	m	struct:global::__anon96::__anon97
gid	include/types/global.h	/^	int gid;$/;"	m	struct:global
gid	include/types/listener.h	/^		gid_t gid;         \/* -1 to leave unchanged *\/$/;"	m	struct:bind_conf::__anon51
global	include/types/global.h	/^struct global {$/;"	s
global	src/haproxy.c	/^struct global global = {$/;"	v	typeref:struct:global
global_listener_queue	src/haproxy.c	/^struct list global_listener_queue = LIST_HEAD_INIT(global_listener_queue);$/;"	v	typeref:struct:list
global_listener_queue_task	src/haproxy.c	/^struct task *global_listener_queue_task;$/;"	v	typeref:struct:task
gmt2str_log	src/standard.c	/^char *gmt2str_log(char *dst, struct tm *tm, size_t size)$/;"	f
gpc0	include/types/stick_table.h	/^	unsigned int gpc0;$/;"	m	union:stktable_data
gpc0_rate	include/types/stick_table.h	/^	struct freq_ctr_period gpc0_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
grace	include/types/proxy.h	/^	int grace;				\/* grace time after stop request *\/$/;"	m	struct:proxy
group	include/types/auth.h	/^	struct auth_groups *group;$/;"	m	struct:auth_groups_list	typeref:struct:auth_groups_list::auth_groups
groups	include/types/auth.h	/^		struct auth_groups_list *groups;$/;"	m	union:auth_users::__anon31	typeref:struct:auth_users::__anon31::auth_groups_list
groups	include/types/auth.h	/^	struct auth_groups *groups;$/;"	m	struct:userlist	typeref:struct:userlist::auth_groups
groups_names	include/types/auth.h	/^		char *groups_names; \/* Just used during the configuration parsing. *\/$/;"	m	union:auth_users::__anon31
groupusers	include/types/auth.h	/^	char *groupusers; \/* Just used during the configuration parsing. *\/$/;"	m	struct:auth_groups
gzip_init	src/compression.c	/^int gzip_init(struct comp_ctx **comp_ctx, int level)$/;"	f
h1	include/types/pattern.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:pat_time
h2	include/types/pattern.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:pat_time
handler	include/types/listener.h	/^	struct task * (*handler)(struct task *t); \/* protocol handler. It is a task *\/$/;"	m	struct:listener	typeref:struct:listener::handler
handler	include/types/signal.h	/^	void *handler;                  \/* function to call or task to wake up *\/$/;"	m	struct:sig_handler
handlers	include/types/signal.h	/^	struct list handlers;           \/* sig_handler *\/$/;"	m	struct:signal_descriptor	typeref:struct:signal_descriptor::list
hap_fd_clr	src/ev_poll.c	/^static inline void hap_fd_clr(int fd, unsigned int *evts)$/;"	f	file:
hap_fd_isset	src/ev_poll.c	/^static inline unsigned int hap_fd_isset(int fd, unsigned int *evts)$/;"	f	file:
hap_fd_set	src/ev_poll.c	/^static inline void hap_fd_set(int fd, unsigned int *evts)$/;"	f	file:
haproxy_info	contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_info {$/;"	s
haproxy_server_hash	tests/test_hashes.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f
haproxy_server_hash	tests/uri_hash.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f
haproxy_stat	contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_stat {$/;"	s
haproxy_uri_hash	tests/test_hashes.c	/^unsigned long haproxy_uri_hash(char *uri, int uri_len){$/;"	f
hardmaxconn	include/types/global.h	/^	int maxconn, hardmaxconn;$/;"	m	struct:global
has_zero	contrib/halog/fgets2.c	/^static inline unsigned long has_zero(unsigned long x)$/;"	f	file:
has_zero32	contrib/halog/fgets2.c	/^static inline unsigned int has_zero32(unsigned int x)$/;"	f	file:
has_zero64	contrib/halog/fgets2.c	/^static inline unsigned long long has_zero64(unsigned long long x)$/;"	f	file:
hash_bj6	tests/ip-hash.c	/^uint32_t hash_bj6(uint32_t a)$/;"	f
hash_bj7	tests/ip-hash.c	/^uint32_t hash_bj7(uint32_t a)$/;"	f
hash_djb2	src/hash.c	/^unsigned long hash_djb2(const char *key, int len)$/;"	f
hash_djbx33	tests/test_hashes.c	/^hash_djbx33($/;"	f	file:
hash_gd1	tests/uri_hash.c	/^static unsigned long hash_gd1(char *uri)$/;"	f	file:
hash_gd2	tests/uri_hash.c	/^static unsigned long hash_gd2(char *uri)$/;"	f	file:
hash_gd3	tests/uri_hash.c	/^static unsigned long hash_gd3(char *uri)$/;"	f	file:
hash_gd4	tests/uri_hash.c	/^static unsigned long hash_gd4(char *uri)$/;"	f	file:
hash_gd5	tests/uri_hash.c	/^static unsigned long hash_gd5(char *uri)$/;"	f	file:
hash_gd6	tests/uri_hash.c	/^static unsigned long hash_gd6(char *uri)$/;"	f	file:
hash_id	tests/ip-hash.c	/^uint32_t hash_id( uint32_t a)$/;"	f
hash_list	include/common/appsession.h	/^	struct list hash_list;$/;"	m	struct:appsessions	typeref:struct:appsessions::list
hash_sdbm	src/hash.c	/^unsigned long hash_sdbm(const char *key, int len)$/;"	f
hash_tw1	tests/ip-hash.c	/^uint32_t hash_tw1(uint32_t a)$/;"	f
hash_tw2	tests/ip-hash.c	/^uint32_t hash_tw2(uint32_t a)$/;"	f
hash_tw3	tests/ip-hash.c	/^uint32_t hash_tw3(uint32_t a)$/;"	f
hash_wt1	tests/uri_hash.c	/^static unsigned long hash_wt1(int hsize, char *string) {$/;"	f	file:
hash_wt2	tests/uri_hash.c	/^int hash_wt2(const char *src, int len) {$/;"	f
hash_wt6	src/hash.c	/^unsigned long hash_wt6(const char *key, int len)$/;"	f
hashpjw	tests/test_hashes.c	/^int hashpjw(const void *key) {$/;"	f
hashword	tests/test_hashes.c	/^uint32_t hashword($/;"	f
have_appsession	src/appsession.c	/^int have_appsession;$/;"	v
hdr	include/types/proto_tcp.h	/^	struct cap_hdr *hdr;                    \/* the capture storage *\/$/;"	m	struct:capture_prm	typeref:struct:capture_prm::cap_hdr
hdr	src/shctx.c	/^	struct shsess_packet_hdr hdr;$/;"	m	struct:shsess_packet	typeref:struct:shsess_packet::shsess_packet_hdr	file:
hdr_add	include/types/proto_http.h	/^		} hdr_add;                     \/* args used by "add-header" and "set-header" *\/$/;"	m	union:http_req_rule::__anon67	typeref:struct:http_req_rule::__anon67::__anon69
hdr_add	include/types/proto_http.h	/^		} hdr_add;                     \/* args used by "add-header" and "set-header" *\/$/;"	m	union:http_res_rule::__anon71	typeref:struct:http_res_rule::__anon71::__anon72
hdr_ctx	include/types/proto_http.h	/^struct hdr_ctx {$/;"	s
hdr_encode_map	src/proto_http.c	/^fd_set hdr_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
hdr_exp	include/common/regex.h	/^struct hdr_exp {$/;"	s
hdr_idx	include/types/hdr_idx.h	/^struct hdr_idx {$/;"	s
hdr_idx	include/types/proto_http.h	/^	struct hdr_idx hdr_idx;         \/* array of header indexes (max: global.tune.max_http_hdr) *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::hdr_idx
hdr_idx_add	src/hdr_idx.c	/^int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after)$/;"	f
hdr_idx_elem	include/types/hdr_idx.h	/^struct hdr_idx_elem {$/;"	s
hdr_idx_first_idx	include/proto/hdr_idx.h	/^static inline int hdr_idx_first_idx(struct hdr_idx *list)$/;"	f
hdr_idx_first_pos	include/proto/hdr_idx.h	/^static inline int hdr_idx_first_pos(struct hdr_idx *list)$/;"	f
hdr_idx_init	include/proto/hdr_idx.h	/^static inline void hdr_idx_init(struct hdr_idx *list)$/;"	f
hdr_idx_set_start	include/proto/hdr_idx.h	/^static inline void hdr_idx_set_start(struct hdr_idx *list, int len, int cr)$/;"	f
head	include/types/pattern.h	/^	struct list head; \/* The head of the list of struct pat_ref_elt. *\/$/;"	m	struct:pat_ref	typeref:struct:pat_ref::list
head	include/types/pattern.h	/^	struct list head; \/* This is a list of struct pattern_expr_list. *\/$/;"	m	struct:pattern_head	typeref:struct:pattern_head::list
header_unique_id	include/types/proxy.h	/^	char *header_unique_id; 		\/* unique-id header *\/$/;"	m	struct:proxy
health	include/types/checks.h	/^	int health;				\/* 0 to rise-1 = bad;$/;"	m	struct:check
health_adjust	include/proto/checks.h	/^static inline void health_adjust(struct server *s, short status)$/;"	f
help	contrib/halog/halog.c	/^void help()$/;"	f
hex2i	include/common/standard.h	/^static inline int hex2i(int c)$/;"	f
hextab	src/standard.c	/^const char hextab[16] = "0123456789ABCDEF";$/;"	v
hh_len	include/types/proxy.h	/^	int  hh_len;				\/* strlen(hh_name), computed only once *\/$/;"	m	struct:proxy
hh_match_domain	include/types/proxy.h	/^	int  hh_match_domain;			\/* toggle use of special match function *\/$/;"	m	struct:proxy
hh_name	include/types/proxy.h	/^	char *hh_name;				\/* name of the header parameter used for hashing *\/$/;"	m	struct:proxy
hmask	contrib/ip6range/ip6range.c	/^static inline struct in6_addr *hmask(unsigned int b, struct in6_addr *r)$/;"	f	file:
host	include/common/standard.h	/^	const char *host;$/;"	m	struct:split_url
host_len	include/common/standard.h	/^	int host_len;$/;"	m	struct:split_url
hostname	src/haproxy.c	/^char hostname[MAX_HOSTNAME_LEN];$/;"	v
ht_auth_m	include/types/proto_http.h	/^enum ht_auth_m {$/;"	g
ht_state	include/types/proto_http.h	/^enum ht_state {$/;"	g
htbl_proxy	include/types/proxy.h	/^	struct appsession_hash htbl_proxy;	\/* Per Proxy hashtable *\/$/;"	m	struct:proxy	typeref:struct:proxy::appsession_hash
http	include/types/counters.h	/^		} http;$/;"	m	union:pxcounters::__anon3	typeref:struct:pxcounters::__anon3::__anon4
http	include/types/counters.h	/^		} http;$/;"	m	union:srvcounters::__anon5	typeref:struct:srvcounters::__anon5::__anon6
http_100_chunk	src/proto_http.c	/^const struct chunk http_100_chunk = {$/;"	v	typeref:struct:chunk
http_apply_redirect_rule	src/proto_http.c	/^static int http_apply_redirect_rule(struct redirect_rule *rule, struct session *s, struct http_txn *txn)$/;"	f	file:
http_auth_data	include/types/proto_http.h	/^struct http_auth_data {$/;"	s
http_body_bytes	include/proto/proto_http.h	/^static inline int http_body_bytes(const struct http_msg *msg)$/;"	f
http_body_rewind	include/proto/proto_http.h	/^static inline int http_body_rewind(const struct http_msg *msg)$/;"	f
http_capture_bad_message	src/proto_http.c	/^void http_capture_bad_message(struct error_snapshot *es, struct session *s,$/;"	f
http_change_connection_header	src/proto_http.c	/^void http_change_connection_header(struct http_txn *txn, struct http_msg *msg, int wanted)$/;"	f
http_compression_buffer_add_data	src/compression.c	/^int http_compression_buffer_add_data(struct session *s, struct buffer *in, struct buffer *out)$/;"	f
http_compression_buffer_end	src/compression.c	/^int http_compression_buffer_end(struct session *s, struct buffer **in, struct buffer **out, int end)$/;"	f
http_compression_buffer_init	src/compression.c	/^int http_compression_buffer_init(struct session *s, struct buffer *in, struct buffer *out)$/;"	f
http_data_rewind	include/proto/proto_http.h	/^static inline int http_data_rewind(const struct http_msg *msg)$/;"	f
http_emit_chunk_size	src/compression.c	/^int http_emit_chunk_size(char *out, unsigned int chksz, int add_crlf)$/;"	f
http_encode_map	src/proto_http.c	/^fd_set http_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
http_end_txn	src/proto_http.c	/^void http_end_txn(struct session *s)$/;"	f
http_end_txn_clean_session	src/proto_http.c	/^void http_end_txn_clean_session(struct session *s)$/;"	f
http_err_chunks	src/proto_http.c	/^struct chunk http_err_chunks[HTTP_ERR_SIZE];$/;"	v	typeref:struct:chunk
http_err_cnt	include/types/stick_table.h	/^	unsigned int http_err_cnt;$/;"	m	union:stktable_data
http_err_codes	src/proto_http.c	/^const int http_err_codes[HTTP_ERR_SIZE] = {$/;"	v
http_err_msgs	src/proto_http.c	/^static const char *http_err_msgs[HTTP_ERR_SIZE] = {$/;"	v	file:
http_err_rate	include/types/stick_table.h	/^	struct freq_ctr_period http_err_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
http_error_message	src/proto_http.c	/^struct chunk *http_error_message(struct session *s, int msgnum)$/;"	f
http_find_full_header2	src/proto_http.c	/^int http_find_full_header2(const char *name, int len,$/;"	f
http_find_header	src/proto_http.c	/^int http_find_header(const char *name,$/;"	f
http_find_header2	src/proto_http.c	/^int http_find_header2(const char *name, int len,$/;"	f
http_forward_trailers	src/proto_http.c	/^static int http_forward_trailers(struct http_msg *msg)$/;"	f	file:
http_get_fhdr	src/proto_http.c	/^unsigned int http_get_fhdr(const struct http_msg *msg, const char *hname, int hlen,$/;"	f
http_get_hdr	src/proto_http.c	/^unsigned int http_get_hdr(const struct http_msg *msg, const char *hname, int hlen,$/;"	f
http_get_path	src/proto_http.c	/^http_get_path(struct http_txn *txn)$/;"	f	file:
http_get_path_from_string	src/proto_http.c	/^http_get_path_from_string(char *str)$/;"	f	file:
http_handle_stats	src/proto_http.c	/^int http_handle_stats(struct session *s, struct channel *req)$/;"	f
http_hdr_rewind	include/proto/proto_http.h	/^static inline int http_hdr_rewind(const struct http_msg *msg)$/;"	f
http_header_add_tail	src/proto_http.c	/^int http_header_add_tail(struct http_msg *msg, struct hdr_idx *hdr_idx, const char *text)$/;"	f
http_header_add_tail2	src/proto_http.c	/^int http_header_add_tail2(struct http_msg *msg,$/;"	f
http_header_match2	src/proto_http.c	/^int http_header_match2(const char *hdr, const char *end,$/;"	f
http_init_txn	src/proto_http.c	/^void http_init_txn(struct session *s)$/;"	f
http_is_crlf	src/proto_http.c	/^const char http_is_crlf[256] = {$/;"	v
http_is_ctl	src/proto_http.c	/^const char http_is_ctl[256] = {$/;"	v
http_is_lws	src/proto_http.c	/^const char http_is_lws[256] = {$/;"	v
http_is_sep	src/proto_http.c	/^const char http_is_sep[256] = {$/;"	v
http_is_spht	src/proto_http.c	/^const char http_is_spht[256] = {$/;"	v
http_is_token	src/proto_http.c	/^const char http_is_token[256] = {$/;"	v
http_is_ver_token	src/proto_http.c	/^const char http_is_ver_token[256] = {$/;"	v
http_known_methods	src/proto_http.c	/^const struct http_method_name http_known_methods[HTTP_METH_OTHER] = {$/;"	v	typeref:struct:http_method_name
http_meth_t	include/types/proto_http.h	/^enum http_meth_t {$/;"	g
http_method_desc	src/proto_http.c	/^struct http_method_desc {$/;"	s	file:
http_method_name	include/types/proto_http.h	/^struct http_method_name {$/;"	s
http_methods	src/proto_http.c	/^const struct http_method_desc http_methods[26][3] = {$/;"	v	typeref:struct:http_method_desc
http_msg	include/types/proto_http.h	/^struct http_msg {$/;"	s
http_msg_analyzer	src/proto_http.c	/^void http_msg_analyzer(struct http_msg *msg, struct hdr_idx *idx)$/;"	f
http_msg_move_end	include/proto/proto_http.h	143;"	d
http_msg_state_str	include/proto/proto_http.h	/^static inline const char *http_msg_state_str(int msg_state)$/;"	f
http_needed	include/types/proxy.h	/^	unsigned int http_needed;               \/* non-null if HTTP analyser may be used *\/$/;"	m	struct:proxy
http_parse_chunk_size	src/proto_http.c	/^static inline int http_parse_chunk_size(struct http_msg *msg)$/;"	f	file:
http_parse_connection_header	src/proto_http.c	/^void http_parse_connection_header(struct http_txn *txn, struct http_msg *msg, int to_del)$/;"	f
http_parse_redirect_rule	src/proto_http.c	/^struct redirect_rule *http_parse_redirect_rule(const char *file, int linenum, struct proxy *curproxy,$/;"	f
http_parse_reqline	src/proto_http.c	/^const char *http_parse_reqline(struct http_msg *msg,$/;"	f
http_parse_stsline	src/proto_http.c	/^const char *http_parse_stsline(struct http_msg *msg,$/;"	f
http_perform_server_redirect	src/proto_http.c	/^void http_perform_server_redirect(struct session *s, struct stream_interface *si)$/;"	f
http_process_req_common	src/proto_http.c	/^int http_process_req_common(struct session *s, struct channel *req, int an_bit, struct proxy *px)$/;"	f
http_process_request	src/proto_http.c	/^int http_process_request(struct session *s, struct channel *req, int an_bit)$/;"	f
http_process_res_common	src/proto_http.c	/^int http_process_res_common(struct session *s, struct channel *rep, int an_bit, struct proxy *px)$/;"	f
http_process_tarpit	src/proto_http.c	/^int http_process_tarpit(struct session *s, struct channel *req, int an_bit)$/;"	f
http_remove_header2	src/proto_http.c	/^int http_remove_header2(struct http_msg *msg, struct hdr_idx *idx, struct hdr_ctx *ctx)$/;"	f
http_replace_header	src/proto_http.c	/^static int http_replace_header(struct my_regex *re, char *dst, uint dst_size, char *val, int len,$/;"	f	file:
http_replace_value	src/proto_http.c	/^static int http_replace_value(struct my_regex *re, char *dst, uint dst_size, char *val, int len, char delim,$/;"	f	file:
http_req_action_kw	include/types/proto_http.h	/^struct http_req_action_kw {$/;"	s
http_req_action_kw_list	include/types/proto_http.h	/^struct http_req_action_kw_list {$/;"	s
http_req_cnt	include/types/stick_table.h	/^	unsigned int http_req_cnt;$/;"	m	union:stktable_data
http_req_get_intercept_rule	src/proto_http.c	/^http_req_get_intercept_rule(struct proxy *px, struct list *rules, struct session *s, struct http_txn *txn)$/;"	f
http_req_keywords	src/proto_http.c	/^struct http_req_action_kw_list http_req_keywords = {$/;"	v	typeref:struct:http_req_action_kw_list
http_req_keywords_register	include/proto/proto_http.h	/^static inline void http_req_keywords_register(struct http_req_action_kw_list *kw_list)$/;"	f
http_req_rate	include/types/stick_table.h	/^	struct freq_ctr_period http_req_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
http_req_rule	include/types/proto_http.h	/^struct http_req_rule {$/;"	s
http_req_rules	include/common/uri_auth.h	/^	struct list http_req_rules;	\/* stats http-request rules : allow\/deny\/auth *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list
http_req_rules	include/types/proxy.h	/^	struct list http_req_rules;		\/* HTTP request rules: allow\/deny\/... *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
http_request_forward_body	src/proto_http.c	/^int http_request_forward_body(struct session *s, struct channel *req, int an_bit)$/;"	f
http_res_action_kw	include/types/proto_http.h	/^struct http_res_action_kw {$/;"	s
http_res_action_kw_list	include/types/proto_http.h	/^struct http_res_action_kw_list {$/;"	s
http_res_get_intercept_rule	src/proto_http.c	/^http_res_get_intercept_rule(struct proxy *px, struct list *rules, struct session *s, struct http_txn *txn)$/;"	f	file:
http_res_keywords	src/proto_http.c	/^struct http_res_action_kw_list http_res_keywords = {$/;"	v	typeref:struct:http_res_action_kw_list
http_res_keywords_register	include/proto/proto_http.h	/^static inline void http_res_keywords_register(struct http_res_action_kw_list *kw_list)$/;"	f
http_res_rule	include/types/proto_http.h	/^struct http_res_rule {$/;"	s
http_res_rules	include/types/proxy.h	/^	struct list http_res_rules;		\/* HTTP response rules: allow\/deny\/... *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
http_reset_txn	src/proto_http.c	/^void http_reset_txn(struct session *s)$/;"	f
http_response_forward_body	src/proto_http.c	/^int http_response_forward_body(struct session *s, struct channel *res, int an_bit)$/;"	f
http_resync_states	src/proto_http.c	/^int http_resync_states(struct session *s)$/;"	f
http_return_srv_error	src/proto_http.c	/^void http_return_srv_error(struct session *s, struct stream_interface *si)$/;"	f
http_scheme	include/common/standard.h	/^enum http_scheme {$/;"	g
http_send_name_header	src/proto_http.c	/^int http_send_name_header(struct http_txn *txn, struct proxy* be, const char* srv_name) {$/;"	f
http_server_error	src/proto_http.c	/^static void http_server_error(struct session *s, struct stream_interface *si,$/;"	f	file:
http_skip_chunk_crlf	src/proto_http.c	/^static inline int http_skip_chunk_crlf(struct http_msg *msg)$/;"	f	file:
http_stats_applet	src/dumpstats.c	/^struct si_applet http_stats_applet = {$/;"	v	typeref:struct:si_applet
http_stats_io_handler	src/dumpstats.c	/^static void http_stats_io_handler(struct stream_interface *si)$/;"	f	file:
http_sync_req_state	src/proto_http.c	/^int http_sync_req_state(struct session *s)$/;"	f
http_sync_res_state	src/proto_http.c	/^int http_sync_res_state(struct session *s)$/;"	f
http_transform_header	src/proto_http.c	/^static int http_transform_header(struct session* s, struct http_msg *msg, const char* name, uint name_len,$/;"	f	file:
http_txn	include/types/proto_http.h	/^struct http_txn {$/;"	s
http_upgrade_v09_to_v10	src/proto_http.c	/^static int http_upgrade_v09_to_v10(struct http_txn *txn)$/;"	f	file:
http_uri_rewind	include/proto/proto_http.h	/^static inline int http_uri_rewind(const struct http_msg *msg)$/;"	f
http_wait_for_request	src/proto_http.c	/^int http_wait_for_request(struct session *s, struct channel *req, int an_bit)$/;"	f
http_wait_for_request_body	src/proto_http.c	/^int http_wait_for_request_body(struct session *s, struct channel *req, int an_bit)$/;"	f
http_wait_for_response	src/proto_http.c	/^int http_wait_for_response(struct session *s, struct channel *rep, int an_bit)$/;"	f
httpchk_build_status_header	src/checks.c	/^static int httpchk_build_status_header(struct server *s, char *buffer, int size)$/;"	f	file:
httpchk_expect	src/checks.c	/^static int httpchk_expect(struct server *s, int done)$/;"	f	file:
httpka	include/types/proxy.h	/^		int httpka;                     \/* maximum time for a new HTTP request when using keep-alive *\/$/;"	m	struct:proxy::__anon18
httpreq	include/types/proxy.h	/^		int httpreq;                    \/* maximum time for complete HTTP request *\/$/;"	m	struct:proxy::__anon18
human_time	src/standard.c	/^char *human_time(int t, short hz_div) {$/;"	f
i	include/common/buffer.h	/^	unsigned int i;                 \/* number of input bytes pending for analysis in the buffer *\/$/;"	m	struct:buffer
i	include/types/pattern.h	/^		int i;                          \/* integer value *\/$/;"	m	union:pattern::__anon10
i	include/types/sample.h	/^	int i;          \/* any integer *\/$/;"	m	union:smp_ctx
i	include/types/stick_table.h	/^		int i;$/;"	m	union:stktable::__anon30
ib	include/types/stream_interface.h	/^	struct channel *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::channel
id	include/types/listener.h	/^		struct eb32_node id;	\/* place in the tree of used IDs *\/$/;"	m	struct:listener::__anon52	typeref:struct:listener::__anon52::eb32_node
id	include/types/peers.h	/^	char *id;			 \/* peer section name *\/$/;"	m	struct:peers
id	include/types/peers.h	/^	char *id;$/;"	m	struct:peer
id	include/types/proxy.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::eb32_node
id	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy
id	include/types/server.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:server::__anon100	typeref:struct:server::__anon100::eb32_node
id	include/types/server.h	/^	char *id;				\/* just for identification *\/$/;"	m	struct:server
id	include/types/stick_table.h	/^	char *id;		  \/* table id name *\/$/;"	m	struct:stktable
id	src/shctx.c	/^	unsigned char id[SSL_MAX_SSL_SESSION_ID_LENGTH];$/;"	m	struct:shsess_packet_hdr	file:
identity_add_data	src/compression.c	/^int identity_add_data(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out)$/;"	f
identity_end	src/compression.c	/^int identity_end(struct comp_ctx **comp_ctx)$/;"	f
identity_flush	src/compression.c	/^int identity_flush(struct comp_ctx *comp_ctx, struct buffer *out, int flag)$/;"	f
identity_init	src/compression.c	/^int identity_init(struct comp_ctx **comp_ctx, int level)$/;"	f
identity_reset	src/compression.c	/^int identity_reset(struct comp_ctx *comp_ctx)$/;"	f
idle_pct	src/time.c	/^unsigned int   idle_pct;        \/* idle to total ratio over last sample (percent) *\/$/;"	v
idle_time	src/time.c	/^unsigned int   idle_time;       \/* total idle time over current sample *\/$/;"	v
idle_timer	include/types/global.h	/^		unsigned short idle_timer; \/* how long before an empty buffer is considered idle (ms) *\/$/;"	m	struct:global::__anon95
idx	include/types/proto_http.h	/^	int  idx;$/;"	m	struct:hdr_ctx
iface_len	include/types/connection.h	/^	int iface_len;                       \/* bind interface name length *\/$/;"	m	struct:conn_src
iface_name	include/types/connection.h	/^	char *iface_name;                    \/* bind interface name or NULL *\/$/;"	m	struct:conn_src
ignore_implicit	Makefile	/^ignore_implicit = $(patsubst %=implicit,,$(1)=$($(1)))$/;"	m
iid	include/types/stream_interface.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:appctx::__anon43::__anon44
iid	include/types/stream_interface.h	/^			int iid;		\/* if >= 0, ID of the proxy to filter on *\/$/;"	m	struct:appctx::__anon43::__anon46
in6_bswap	contrib/ip6range/ip6range.c	/^static inline void in6_bswap(struct in6_addr *a)$/;"	f	file:
in_net_ipv4	src/standard.c	/^int in_net_ipv4(struct in_addr *addr, struct in_addr *mask, struct in_addr *net)$/;"	f
in_net_ipv6	src/standard.c	/^int in_net_ipv6(struct in6_addr *addr, struct in6_addr *mask, struct in6_addr *net)$/;"	f
in_origaddrs	include/import/ip_tproxy.h	/^struct in_origaddrs {$/;"	s
in_tproxy	include/import/ip_tproxy.h	/^struct in_tproxy {$/;"	s
in_tproxy_addr	include/import/ip_tproxy.h	/^struct in_tproxy_addr{$/;"	s
in_type	include/types/sample.h	/^	unsigned int in_type;                     \/* expected input sample type *\/$/;"	m	struct:sample_conv
indent_msg	src/standard.c	/^char *indent_msg(char **out, int level)$/;"	f
index	include/types/acl.h	/^	int (*index)(struct pattern_expr *expr, struct pattern *pattern, char **err);$/;"	m	struct:acl_keyword
index	include/types/capture.h	/^    int index;				\/* index in the output array *\/$/;"	m	struct:cap_hdr
index	include/types/pattern.h	/^	int (*index)(struct pattern_expr *, struct pattern *, char **);$/;"	m	struct:pattern_head
inet_set_tos	src/proto_http.c	/^static inline void inet_set_tos(int fd, struct sockaddr_storage from, int tos)$/;"	f	file:
inetaddr_host	src/standard.c	/^unsigned int inetaddr_host(const char *text)$/;"	f
inetaddr_host_lim	src/standard.c	/^unsigned int inetaddr_host_lim(const char *text, const char *stop)$/;"	f
inetaddr_host_lim_ret	src/standard.c	/^unsigned int inetaddr_host_lim_ret(char *text, char *stop, char **ret)$/;"	f
info	include/types/checks.h	/^	char *info;			\/* human readable short info *\/$/;"	m	struct:check_status
init	include/types/compression.h	/^	int (*init)(struct comp_ctx **comp_ctx, int level);$/;"	m	struct:comp_algo
init	include/types/connection.h	/^	int  (*init)(struct connection *conn);      \/* initialize the transport layer *\/$/;"	m	struct:xprt_ops
init	include/types/connection.h	/^	int  (*init)(struct connection *conn);  \/* data-layer initialization *\/$/;"	m	struct:data_cb
init	include/types/fd.h	/^	int  REGPRM1   (*init)(struct poller *p);            \/* poller initialization *\/$/;"	m	struct:poller
init	include/types/lb_fwrr.h	/^	struct eb_root *init;   \/* servers waiting to be placed *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
init	src/haproxy-systemd-wrapper.c	/^static void init(int argc, char **argv)$/;"	f	file:
init	src/haproxy.c	/^void init(int argc, char **argv)$/;"	f
init_acl	src/acl.c	/^int init_acl()$/;"	f
init_buffer	src/buffer.c	/^int init_buffer()$/;"	f
init_channel	src/channel.c	/^int init_channel()$/;"	f
init_check	src/server.c	/^static int init_check(struct check *check, int type, const char * file, int linenum)$/;"	f	file:
init_comp_ctx	src/compression.c	/^static inline int init_comp_ctx(struct comp_ctx **comp_ctx)$/;"	f	file:
init_connection	src/connection.c	/^int init_connection()$/;"	f
init_default_instance	src/cfgparse.c	/^void init_default_instance()$/;"	f
init_new_proxy	src/proxy.c	/^void init_new_proxy(struct proxy *p)$/;"	f
init_pendconn	src/queue.c	/^int init_pendconn()$/;"	f
init_pipe	src/pipe.c	/^static void init_pipe()$/;"	f	file:
init_pollers	src/fd.c	/^int init_pollers()$/;"	f
init_proto_http	src/proto_http.c	/^void init_proto_http()$/;"	f
init_server_map	src/lb_map.c	/^void init_server_map(struct proxy *p)$/;"	f
init_session	src/session.c	/^int init_session()$/;"	f
init_task	src/task.c	/^int init_task()$/;"	f
init_tree	tests/filltab25.c	/^struct eb_root *init_tree; \/* receives positions 0..sw-1 *\/$/;"	v	typeref:struct:eb_root
insert_timer	contrib/halog/halog.c	/^struct timer *insert_timer(struct eb_root *r, struct timer **alloc, int v)$/;"	f
insert_value	contrib/halog/halog.c	/^struct timer *insert_value(struct eb_root *r, struct timer **alloc, int v)$/;"	f
inspect_delay	include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon16
inspect_delay	include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon17
inspect_rules	include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon16	typeref:struct:proxy::__anon16::list
inspect_rules	include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon17	typeref:struct:proxy::__anon17::list
integer	include/types/stick_table.h	/^	uint32_t integer;         \/* used to store an integer key *\/$/;"	m	union:stktable_key_data
inter	include/types/checks.h	/^	int inter, fastinter, downinter;        \/* checks: time in milliseconds *\/$/;"	m	struct:check
intercepted_req	include/types/counters.h	/^	long long intercepted_req;              \/* number of monitoring or stats requests intercepted by the frontend *\/$/;"	m	struct:pxcounters
interface	include/types/listener.h	/^	char *interface;		\/* interface name or NULL *\/$/;"	m	struct:listener
invalid_char	src/standard.c	/^const char *invalid_char(const char *name)$/;"	f
invalid_domainchar	src/standard.c	/^const char *invalid_domainchar(const char *name) {$/;"	f
invalid_rep	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::
invalid_req	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::error_snapshot
inverse	include/types/checks.h	/^	int inverse;                            \/* 0 = regular match, 1 = inverse match *\/$/;"	m	struct:tcpcheck_rule
ioa_dstaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_dstaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr
ioa_dstport	include/import/ip_tproxy.h	/^        unsigned short int ioa_dstport;$/;"	m	struct:in_origaddrs
ioa_srcaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_srcaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr
ioa_srcport	include/import/ip_tproxy.h	/^        unsigned short int ioa_srcport;$/;"	m	struct:in_origaddrs
iocb	include/types/fd.h	/^	int (*iocb)(int fd);                 \/* I\/O handler, returns FD_WAIT_* *\/$/;"	m	struct:fdtab
ip	include/types/stick_table.h	/^	struct in_addr ip;        \/* used to store an ipv4 key *\/$/;"	m	union:stktable_key_data	typeref:struct:stktable_key_data::in_addr
ip4	include/types/connection.h	/^		} ip4;$/;"	m	union:proxy_hdr_v2::__anon81	typeref:struct:proxy_hdr_v2::__anon81::__anon82
ip6	include/types/connection.h	/^		} ip6;$/;"	m	union:proxy_hdr_v2::__anon81	typeref:struct:proxy_hdr_v2::__anon81::__anon83
ipv4	include/types/arg.h	/^	struct in_addr ipv4;$/;"	m	union:arg_data	typeref:struct:arg_data::in_addr
ipv4	include/types/pattern.h	/^		} ipv4;                         \/* IPv4 address *\/$/;"	m	union:pattern::__anon10	typeref:struct:pattern::__anon10::__anon12
ipv4	include/types/sample.h	/^		struct in_addr  ipv4;  \/* used for ipv4 addresses *\/$/;"	m	union:sample::__anon92	typeref:struct:sample::__anon92::in_addr
ipv4	include/types/sample.h	/^		struct in_addr  ipv4;  \/* used for ipv4 addresses *\/$/;"	m	union:sample_storage::__anon93	typeref:struct:sample_storage::__anon93::in_addr
ipv6	include/types/arg.h	/^	struct in6_addr ipv6;$/;"	m	union:arg_data	typeref:struct:arg_data::in6_addr
ipv6	include/types/pattern.h	/^		} ipv6;                         \/* IPv6 address\/mask *\/$/;"	m	union:pattern::__anon10	typeref:struct:pattern::__anon10::__anon13
ipv6	include/types/sample.h	/^		struct in6_addr ipv6;  \/* used for ipv6 addresses *\/$/;"	m	union:sample::__anon92	typeref:struct:sample::__anon92::in6_addr
ipv6	include/types/sample.h	/^		struct in6_addr ipv6;  \/* used for ipv6 addresses *\/$/;"	m	union:sample_storage::__anon93	typeref:struct:sample_storage::__anon93::in6_addr
ipv6	include/types/stick_table.h	/^	struct in6_addr ipv6;     \/* used to store an ipv6 key *\/$/;"	m	union:stktable_key_data	typeref:struct:stktable_key_data::in6_addr
is_addr	include/common/standard.h	/^static inline int is_addr(const struct sockaddr_storage *addr)$/;"	f
is_delimiter	src/pattern.c	/^static inline unsigned int is_delimiter(unsigned char c, unsigned int mask)$/;"	f	file:
is_inet_addr	include/common/standard.h	/^static inline int is_inet_addr(const struct sockaddr_storage *addr)$/;"	f
is_param_delimiter	src/proto_http.c	/^static inline int is_param_delimiter(char c, char delim)$/;"	f	file:
is_set	contrib/ip6range/ip6range.c	/^int is_set(struct in6_addr *a)$/;"	f
is_ssl	include/types/listener.h	/^	int is_ssl;                \/* SSL is required for these listeners *\/$/;"	m	struct:bind_conf
ishex	src/standard.c	/^int ishex(char s)$/;"	f
itoa_idx	src/standard.c	/^int itoa_idx = 0; \/* index of next itoa_str to use *\/$/;"	v
itoa_str	src/standard.c	/^char itoa_str[NB_ITOA_STR][171];$/;"	v
iweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
jobs	src/haproxy.c	/^int jobs = 0;   \/* number of active jobs (conns, listeners, active tasks, ...) *\/$/;"	v
k_bin2str	src/stick_table.c	/^static void *k_bin2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_int2int	src/stick_table.c	/^static void *k_int2int(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_int2ip	src/stick_table.c	/^static void *k_int2ip(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_int2str	src/stick_table.c	/^static void *k_int2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2int	src/stick_table.c	/^static void *k_ip2int(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2ip	src/stick_table.c	/^static void *k_ip2ip(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2ipv6	src/stick_table.c	/^static void *k_ip2ipv6(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2str	src/stick_table.c	/^static void *k_ip2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2int	src/stick_table.c	/^static void *k_str2int(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2ip	src/stick_table.c	/^static void *k_str2ip(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2ipv6	src/stick_table.c	/^static void *k_str2ipv6(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2str	src/stick_table.c	/^static void *k_str2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
kev	src/ev_kqueue.c	/^static struct kevent *kev = NULL;$/;"	v	typeref:struct:kevent	file:
key	ebtree/eb32tree.h	/^	u32 key;$/;"	m	struct:eb32_node
key	ebtree/eb64tree.h	/^	u64 key;$/;"	m	struct:eb64_node
key	ebtree/ebmbtree.h	/^	unsigned char key[0]; \/* the key, its size depends on the application *\/$/;"	m	struct:ebmb_node
key	ebtree/ebpttree.h	/^	void *key;$/;"	m	struct:ebpt_node
key	include/types/proto_http.h	/^			struct list key;       \/* pattern to retrieve MAP or ACL key *\/$/;"	m	struct:http_req_rule::__anon67::__anon70	typeref:struct:http_req_rule::__anon67::__anon70::list
key	include/types/proto_http.h	/^			struct list key;       \/* pattern to retrieve MAP or ACL key *\/$/;"	m	struct:http_res_rule::__anon71::__anon73	typeref:struct:http_res_rule::__anon71::__anon73::list
key	include/types/stick_table.h	/^	struct ebmb_node key;     \/* ebtree node used to hold the session in table *\/$/;"	m	struct:stksess	typeref:struct:stksess::ebmb_node
key	include/types/stick_table.h	/^	void *key;                      \/* pointer on key buffer *\/$/;"	m	struct:stktable_key
key	src/shctx.c	/^	struct ebmb_node key;$/;"	m	struct:shared_session	typeref:struct:shared_session::ebmb_node	file:
key	src/ssl_sock.c	/^	struct ebmb_node key;$/;"	m	struct:certificate_ocsp	typeref:struct:certificate_ocsp::ebmb_node	file:
key_data	src/shctx.c	/^	unsigned char key_data[SSL_MAX_SSL_SESSION_ID_LENGTH];$/;"	m	struct:shared_session	file:
key_data	src/ssl_sock.c	/^	unsigned char key_data[OCSP_MAX_CERTID_ASN1_LENGTH];$/;"	m	struct:certificate_ocsp	file:
key_len	include/types/stick_table.h	/^	size_t key_len;                 \/* data len to read in buff in case of null terminated string *\/$/;"	m	struct:stktable_key
key_size	include/types/stick_table.h	/^	size_t key_size;          \/* size of a key, maximum size in case of string *\/$/;"	m	struct:stktable
keys	include/types/stick_table.h	/^	struct eb_root keys;      \/* head of sticky session tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
kill_mini_session	src/session.c	/^static void kill_mini_session(struct session *s)$/;"	f	file:
kill_pipe	src/pipe.c	/^void kill_pipe(struct pipe *p)$/;"	f
kqueue_fd	src/ev_kqueue.c	/^static int kqueue_fd;$/;"	v	file:
kr_hash	tests/test_hashes.c	/^unsigned kr_hash(char *s){$/;"	f
kw	include/common/cfgparse.h	/^	const char *kw;                         \/* the keyword itself *\/$/;"	m	struct:cfg_keyword
kw	include/common/cfgparse.h	/^	struct cfg_keyword kw[VAR_ARRAY];$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::cfg_keyword
kw	include/types/acl.h	/^	const char *kw;               \/* points to the ACL kw's name or fetch's name (must not free) *\/$/;"	m	struct:acl_expr
kw	include/types/acl.h	/^	const char *kw;$/;"	m	struct:acl_keyword
kw	include/types/acl.h	/^	struct acl_keyword kw[VAR_ARRAY];$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::acl_keyword
kw	include/types/arg.h	/^	const char *kw;           \/* keyword making use of these args *\/$/;"	m	struct:arg_list
kw	include/types/listener.h	/^	const char *kw;$/;"	m	struct:bind_kw
kw	include/types/listener.h	/^	struct bind_kw kw[VAR_ARRAY];$/;"	m	struct:bind_kw_list	typeref:struct:bind_kw_list::bind_kw
kw	include/types/proto_http.h	/^       const char *kw;$/;"	m	struct:http_req_action_kw
kw	include/types/proto_http.h	/^       const char *kw;$/;"	m	struct:http_res_action_kw
kw	include/types/proto_http.h	/^       struct http_req_action_kw kw[VAR_ARRAY];$/;"	m	struct:http_req_action_kw_list	typeref:struct:http_req_action_kw_list::http_req_action_kw
kw	include/types/proto_http.h	/^       struct http_res_action_kw kw[VAR_ARRAY];$/;"	m	struct:http_res_action_kw_list	typeref:struct:http_res_action_kw_list::http_res_action_kw
kw	include/types/sample.h	/^	const char *kw;                           \/* configuration keyword  *\/$/;"	m	struct:sample_conv
kw	include/types/sample.h	/^	const char *kw;                           \/* configuration keyword *\/$/;"	m	struct:sample_fetch
kw	include/types/sample.h	/^	struct sample_conv kw[VAR_ARRAY];         \/* array of sample conversion descriptors *\/$/;"	m	struct:sample_conv_kw_list	typeref:struct:sample_conv_kw_list::sample_conv
kw	include/types/sample.h	/^	struct sample_fetch kw[VAR_ARRAY];        \/* array of sample fetch descriptors *\/$/;"	m	struct:sample_fetch_kw_list	typeref:struct:sample_fetch_kw_list::sample_fetch
kw	include/types/server.h	/^	const char *kw;$/;"	m	struct:srv_kw
kw	include/types/server.h	/^	struct srv_kw kw[VAR_ARRAY];$/;"	m	struct:srv_kw_list	typeref:struct:srv_kw_list::srv_kw
kw	include/types/stick_table.h	/^	const char *kw;           \/* keyword string *\/$/;"	m	struct:stktable_type
kw_mod	src/cfgparse.c	/^enum kw_mod {$/;"	g	file:
l	include/types/proto_http.h	/^			int l;                 \/* request line length (not including CR) *\/$/;"	m	struct:http_msg::__anon64::__anon65
l	include/types/proto_http.h	/^			int l;                 \/* status line length (not including CR) *\/$/;"	m	struct:http_msg::__anon64::__anon66
l	include/types/stream_interface.h	/^			void *l;$/;"	m	struct:appctx::__anon43::__anon44
l3_addrlen	include/types/protocol.h	/^	int l3_addrlen;					\/* layer3 address length, used by hashes *\/$/;"	m	struct:protocol
l4_rules	include/types/proxy.h	/^		struct list l4_rules;           \/* layer4 rules *\/$/;"	m	struct:proxy::__anon16	typeref:struct:proxy::__anon16::list
language_range_match	src/proto_http.c	/^static inline int language_range_match(const char *range, int range_len,$/;"	f	file:
last	include/types/hdr_idx.h	/^	short last;                 \/* length of the allocated area (1..size) *\/$/;"	m	struct:hdr_idx
last	include/types/lb_chash.h	/^	struct eb32_node *last;	\/* last node found in case of round robin (or NULL) *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb32_node
last	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:
last_change	include/types/peers.h	/^	time_t last_change;$/;"	m	struct:peer
last_change	include/types/peers.h	/^	time_t last_change;$/;"	m	struct:peers
last_change	include/types/proxy.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:proxy
last_change	include/types/server.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:server
last_checks	include/types/global.h	/^	int last_checks;$/;"	m	struct:global
last_read	include/types/channel.h	/^	unsigned short last_read;       \/* 16 lower bits of last read date (max pause=65s) *\/$/;"	m	struct:channel
last_sess	include/types/counters.h	/^	unsigned long last_sess;                 \/* last session time *\/$/;"	m	struct:srvcounters
last_sess	include/types/counters.h	/^	unsigned long last_sess;                \/* last session time *\/$/;"	m	struct:pxcounters
last_started_step	include/types/checks.h	/^	struct tcpcheck_rule *last_started_step;\/* pointer to latest tcpcheck rule started *\/$/;"	m	struct:check	typeref:struct:check::tcpcheck_rule
last_timer	src/task.c	/^struct eb32_node *last_timer = NULL;  \/* optimization: last queued timer *\/$/;"	v	typeref:struct:eb32_node
lastack	include/types/peers.h	/^	unsigned int lastack;	      \/* last acked update *\/$/;"	m	struct:peer_session
lastpush	include/types/peers.h	/^	unsigned int lastpush;	      \/* last pushed update *\/$/;"	m	struct:peer_session
lb_chash	include/types/lb_chash.h	/^struct lb_chash {$/;"	s
lb_fas	include/types/lb_fas.h	/^struct lb_fas {$/;"	s
lb_fwlc	include/types/lb_fwlc.h	/^struct lb_fwlc {$/;"	s
lb_fwrr	include/types/lb_fwrr.h	/^struct lb_fwrr {$/;"	s
lb_map	include/types/lb_map.h	/^struct lb_map {$/;"	s
lb_node	include/types/server.h	/^	struct eb32_node lb_node;               \/* node used for tree-based load balancing *\/$/;"	m	struct:server	typeref:struct:server::eb32_node
lb_nodes	include/types/server.h	/^	struct tree_occ *lb_nodes;              \/* lb_nodes_tot * struct tree_occ *\/$/;"	m	struct:server	typeref:struct:server::tree_occ
lb_nodes_now	include/types/server.h	/^	unsigned lb_nodes_now;                  \/* number of lb_nodes placed in the tree (C-HASH) *\/$/;"	m	struct:server
lb_nodes_tot	include/types/server.h	/^	unsigned lb_nodes_tot;                  \/* number of allocated lb_nodes (C-HASH) *\/$/;"	m	struct:server
lb_tree	include/types/server.h	/^	struct eb_root *lb_tree;                \/* we want to know in what tree the server is *\/$/;"	m	struct:server	typeref:struct:server::eb_root
lbprm	include/types/backend.h	/^struct lbprm {$/;"	s
lbprm	include/types/proxy.h	/^	struct lbprm lbprm;			\/* load-balancing parameters *\/$/;"	m	struct:proxy	typeref:struct:proxy::lbprm
leaf_p	ebtree/ebtree.h	/^	eb_troot_t    *leaf_p;  \/* leaf node's parent *\/$/;"	m	struct:eb_node
len	include/common/chunk.h	/^	int len;	\/* current size of the string from first to last char. <0 = uninit. *\/$/;"	m	struct:chunk
len	include/types/capture.h	/^    int len;				\/* capture length, not including terminal zero *\/$/;"	m	struct:cap_hdr
len	include/types/connection.h	/^	uint16_t len;      \/* number of following bytes part of the header *\/$/;"	m	struct:proxy_hdr_v2
len	include/types/hdr_idx.h	/^        unsigned len  :16; \/* length of this header not counting CRLF. 0=unused entry. *\/$/;"	m	struct:hdr_idx_elem
len	include/types/pattern.h	/^	int len;                        \/* data length when required  *\/$/;"	m	struct:pattern
len	include/types/proto_http.h	/^	int len;$/;"	m	struct:http_method_name
len	include/types/proxy.h	/^	unsigned int len;		\/* original length of the last invalid request\/response *\/$/;"	m	struct:error_snapshot
len	src/proto_http.c	/^	int len;$/;"	m	struct:http_method_desc	file:
length_hi	include/types/connection.h	/^	uint8_t length_hi;$/;"	m	struct:tlv
length_lo	include/types/connection.h	/^	uint8_t length_lo;$/;"	m	struct:tlv
level	include/types/listener.h	/^	int level;                 \/* stats access level (ACCESS_LVL_*) *\/$/;"	m	struct:bind_conf
level	include/types/log.h	/^	int level;$/;"	m	struct:logsrv
level	include/types/session.h	/^		int level;			\/* log level to force + 1 if > 0, -1 = no log *\/$/;"	m	struct:session::__anon55
level	src/trace.c	/^static int level;$/;"	v	file:
lf_ip	src/log.c	/^char *lf_ip(char *dst, struct sockaddr *sockaddr, size_t size, struct logformat_node *node)$/;"	f
lf_port	src/log.c	/^char *lf_port(char *dst, struct sockaddr *sockaddr, size_t size, struct logformat_node *node)$/;"	f
lf_text	src/log.c	/^static inline char *lf_text(char *dst, const char *src, size_t size, struct logformat_node *node)$/;"	f	file:
lf_text_len	src/log.c	/^char *lf_text_len(char *dst, const char *src, size_t len, size_t size, struct logformat_node *node)$/;"	f
lfs_file	include/types/proxy.h	/^		char *lfs_file;                 \/* file name where the logformat string appears (strdup) *\/$/;"	m	struct:proxy::__anon19
lfs_line	include/types/proxy.h	/^		int   lfs_line;                 \/* file name where the logformat string appears *\/$/;"	m	struct:proxy::__anon19
li_state	include/types/listener.h	/^enum li_state {$/;"	g
licounters	include/types/counters.h	/^struct licounters {$/;"	s
likely	include/common/compiler.h	101;"	d
likely	include/common/compiler.h	90;"	d
likely	include/common/compiler.h	94;"	d
limit	include/common/memory.h	/^	unsigned int limit;	\/* hard limit on the number of chunks *\/$/;"	m	struct:pool_head
limit_listener	src/listener.c	/^void limit_listener(struct listener *l, struct list *list)$/;"	f
limit_r	src/standard.c	/^const char *limit_r(unsigned long n, char *buffer, int size, const char *alt)$/;"	f
line	contrib/halog/halog.c	/^const char *line;$/;"	v
line	include/types/acl.h	/^	int line;                   \/* line in the config file where the condition is declared *\/$/;"	m	struct:acl_cond
line	include/types/arg.h	/^	int line;                 \/* line number where the args are referenced *\/$/;"	m	struct:arg_list
line	include/types/listener.h	/^	int line;                  \/* line where the section appears *\/$/;"	m	struct:bind_conf
line	include/types/pattern.h	/^	int line;$/;"	m	struct:pat_ref_elt
line	include/types/peers.h	/^		int line;		 \/* line where the section appears *\/$/;"	m	struct:peers::__anon24
line	include/types/peers.h	/^		int line;	  \/* line where the section appears *\/$/;"	m	struct:peer::__anon23
line	include/types/proto_http.h	/^	char *line;$/;"	m	struct:hdr_ctx
line	include/types/proxy.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:proxy::__anon19
line	include/types/server.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:server::__anon100
line	src/trace.c	/^static char line[128]; \/* more than enough for a message (9+1+6+1+3+1+18+1+1+18+1+1) *\/$/;"	v	file:
line	tests/uri_hash.c	/^char line[MAXLINE];$/;"	v
linenum	contrib/halog/halog.c	/^int linenum = 0;$/;"	v
lines_max	contrib/halog/halog.c	/^int lines_max = -1;$/;"	v
lines_out	contrib/halog/halog.c	/^int lines_out = 0;$/;"	v
linger_risk	include/types/fd.h	/^	unsigned char linger_risk:1;         \/* 1 if we must kill lingering before closing *\/$/;"	m	struct:fdtab
list	include/common/cfgparse.h	/^	struct list list;$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::list
list	include/common/memory.h	/^	struct list list;	\/* list of all known pools *\/$/;"	m	struct:pool_head	typeref:struct:pool_head::list
list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:cond_wordlist	typeref:struct:cond_wordlist::list
list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:wordlist	typeref:struct:wordlist::list
list	include/common/mini-clist.h	/^struct list {$/;"	s
list	include/common/uri_auth.h	/^	struct list list;	\/* list linked to from the proxy *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::list
list	include/types/acl.h	/^	struct list list;             \/* chaining *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list
list	include/types/acl.h	/^	struct list list;           \/* Some specific tests may use multiple conditions *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl	typeref:struct:acl::list
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::list
list	include/types/acl.h	/^	struct list list;           \/* chaining of term suites *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list
list	include/types/acl.h	/^	struct list list;$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::list
list	include/types/arg.h	/^	struct list list;         \/* chaining with other arg_list, or list head *\/$/;"	m	struct:arg_list	typeref:struct:arg_list::list
list	include/types/checks.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:tcpcheck_rule	typeref:struct:tcpcheck_rule::list
list	include/types/listener.h	/^	struct list list;$/;"	m	struct:bind_kw_list	typeref:struct:bind_kw_list::list
list	include/types/log.h	/^	struct list list;$/;"	m	struct:logformat_node	typeref:struct:logformat_node::list
list	include/types/log.h	/^	struct list list;$/;"	m	struct:logsrv	typeref:struct:logsrv::list
list	include/types/map.h	/^	struct list list;              \/* used for listing *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::list
list	include/types/pattern.h	/^	struct list list; \/* Used for chaining pattern_expr in pat_ref. *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list
list	include/types/pattern.h	/^	struct list list; \/* Used for chaining pattern_expr in pattern_head. *\/$/;"	m	struct:pattern_expr_list	typeref:struct:pattern_expr_list::list
list	include/types/pattern.h	/^	struct list list; \/* Used to chain elements. *\/$/;"	m	struct:pat_ref_elt	typeref:struct:pat_ref_elt::list
list	include/types/pattern.h	/^	struct list list; \/* Used to chain refs. *\/$/;"	m	struct:pat_ref	typeref:struct:pat_ref::list
list	include/types/pattern.h	/^	struct list list;$/;"	m	struct:pattern_list	typeref:struct:pattern_list::list
list	include/types/proto_http.h	/^	struct list list;$/;"	m	struct:http_req_rule	typeref:struct:http_req_rule::list
list	include/types/proto_http.h	/^	struct list list;$/;"	m	struct:http_res_rule	typeref:struct:http_res_rule::list
list	include/types/proto_http.h	/^       struct list list;$/;"	m	struct:http_req_action_kw_list	typeref:struct:http_req_action_kw_list::list
list	include/types/proto_http.h	/^       struct list list;$/;"	m	struct:http_res_action_kw_list	typeref:struct:http_res_action_kw_list::list
list	include/types/proto_tcp.h	/^	struct list list;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::list
list	include/types/protocol.h	/^	struct list list;				\/* list of registered protocols *\/$/;"	m	struct:protocol	typeref:struct:protocol::list
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::list
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:server_rule	typeref:struct:server_rule::list
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::list
list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list
list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::list
list	include/types/queue.h	/^	struct list list;		\/* chaining ... *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::list
list	include/types/sample.h	/^	struct list list;                         \/* head of sample conversion keyword list *\/$/;"	m	struct:sample_conv_kw_list	typeref:struct:sample_conv_kw_list::list
list	include/types/sample.h	/^	struct list list;                         \/* head of sample fetch keyword list *\/$/;"	m	struct:sample_fetch_kw_list	typeref:struct:sample_fetch_kw_list::list
list	include/types/sample.h	/^	struct list list;                         \/* member of a sample_expr *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::list
list	include/types/sample.h	/^	struct list list;                         \/* member of list of sample, currently not used *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::list
list	include/types/server.h	/^	struct list list;$/;"	m	struct:srv_kw_list	typeref:struct:srv_kw_list::list
list	include/types/session.h	/^	struct list list;			\/* position in global sessions list *\/$/;"	m	struct:session	typeref:struct:session::list
list	include/types/signal.h	/^	struct list list;$/;"	m	struct:sig_handler	typeref:struct:sig_handler::list
list	src/cfgparse.c	/^	struct list list;$/;"	m	struct:cfg_section	typeref:struct:cfg_section::list	file:
list_for_each_entry	include/common/mini-clist.h	188;"	d
list_for_each_entry_safe	include/common/mini-clist.h	201;"	d
list_pollers	src/fd.c	/^int list_pollers(FILE *out)$/;"	f
listen_default_ciphers	include/types/global.h	/^	char *listen_default_ciphers;$/;"	m	struct:global
listener	include/types/listener.h	/^struct listener {$/;"	s
listener	include/types/session.h	/^	struct listener *listener;		\/* the listener by which the request arrived *\/$/;"	m	struct:session	typeref:struct:session::listener
listener_accept	src/listener.c	/^void listener_accept(int fd)$/;"	f
listener_full	src/listener.c	/^void listener_full(struct listener *l)$/;"	f
listener_queue	include/types/proxy.h	/^	struct list listener_queue;		\/* list of the temporarily limited listeners because of lack of a proxy resource *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
listeners	include/types/listener.h	/^	struct list listeners;     \/* list of listeners using this bind config *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::list
listeners	include/types/protocol.h	/^	struct list listeners;				\/* list of listeners using this protocol *\/$/;"	m	struct:protocol	typeref:struct:protocol::list
listeners	include/types/proxy.h	/^		struct list listeners;		\/* list of listeners belonging to this frontend *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::list
listeners	src/proxy.c	/^int listeners;	\/* # of proxy listeners, set by cfgparse *\/$/;"	v
ll	include/types/sample.h	/^	long long ll;   \/* any long long or smaller *\/$/;"	m	union:smp_ctx
lltoa	src/standard.c	/^char *lltoa(long long n, char *dst, size_t size)$/;"	f
local	include/types/peers.h	/^	int local;		  \/* proxy state *\/$/;"	m	struct:peer
local_port	include/types/fd.h	/^	int local_port;                      \/* optional local port *\/$/;"	m	struct:fdinfo
local_session	include/types/peers.h	/^	struct peer_session *local_session; \/* local peer session *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::peer_session
localdate2str_log	src/standard.c	/^char *localdate2str_log(char *dst, struct tm *tm, size_t size)$/;"	f
localpeer	src/haproxy.c	/^char localpeer[MAX_HOSTNAME_LEN];$/;"	v
localtimezone	include/common/standard.h	/^char localtimezone[6];$/;"	v
localupdate	include/types/stick_table.h	/^	unsigned int localupdate;$/;"	m	struct:stktable
locate_haproxy	src/haproxy-systemd-wrapper.c	/^static void locate_haproxy(char *buffer, size_t buffer_size)$/;"	f	file:
log	src/trace.c	/^static FILE *log;$/;"	v	file:
log_facilities	src/log.c	/^const char *log_facilities[NB_LOG_FACILITIES] = {$/;"	v
log_format	src/log.c	/^char *log_format = NULL;$/;"	v
log_levels	src/log.c	/^const char *log_levels[NB_LOG_LEVELS] = {$/;"	v
log_send_hostname	include/types/global.h	/^	char *log_send_hostname;   \/* set hostname in syslog header *\/$/;"	m	struct:global
log_tag	include/types/global.h	/^	char *log_tag;                  \/* name for syslog *\/$/;"	m	struct:global
logformat	include/types/proxy.h	/^	struct list logformat; 			\/* log_format linked list *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
logformat_keywords	src/log.c	/^static const struct logformat_type logformat_keywords[] = {$/;"	v	typeref:struct:logformat_type	file:
logformat_node	include/types/log.h	/^struct logformat_node {$/;"	s
logformat_string	include/types/proxy.h	/^		char *logformat_string;		\/* log format string *\/$/;"	m	struct:proxy::__anon19
logformat_type	src/log.c	/^struct logformat_type {$/;"	s	file:
logformat_var_args	src/log.c	/^struct logformat_var_args {$/;"	s	file:
loglevel	include/types/proto_http.h	/^		int loglevel;                  \/* log-level value for HTTP_REQ_ACT_SET_LOGL *\/$/;"	m	union:http_req_rule::__anon67
loglevel	include/types/proto_http.h	/^		int loglevel;                  \/* log-level value for HTTP_RES_ACT_SET_LOGL *\/$/;"	m	union:http_res_rule::__anon71
logline	src/log.c	/^static char logline[MAX_SYSLOG_LEN];$/;"	v	file:
logs	include/types/session.h	/^	} logs;$/;"	m	struct:session	typeref:struct:session::__anon55
logsrv	include/types/log.h	/^struct logsrv {$/;"	s
logsrvs	include/types/global.h	/^	struct list logsrvs;$/;"	m	struct:global	typeref:struct:global::list
logsrvs	include/types/proxy.h	/^	struct list logsrvs;$/;"	m	struct:proxy	typeref:struct:proxy::list
logwait	include/types/session.h	/^		int logwait;			\/* log fields waiting to be collected : LW_* *\/$/;"	m	struct:session::__anon55
lpos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server
lr	include/types/checks.h	/^	unsigned char lr[HANA_OBS_SIZE];	\/* result for l4\/l7: 0 = ignore, 1 - error, 2 - OK *\/$/;"	m	struct:analyze_status
ltoa_o	src/standard.c	/^char *ltoa_o(long int n, char *dst, size_t size)$/;"	f
ltrim	include/common/standard.h	/^static inline char *ltrim(char *s, char c) {$/;"	f
luid	include/types/listener.h	/^	int luid;			\/* listener universally unique ID, used for SNMP *\/$/;"	m	struct:listener
lw	src/log.c	/^	int lw; \/* logwait bitsfield *\/$/;"	m	struct:logformat_type	file:
m1	include/types/pattern.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:pat_time
m2	include/types/pattern.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:pat_time
m_blen	include/types/proxy.h	/^	unsigned long long m_blen;	\/* body len for this message *\/$/;"	m	struct:error_snapshot
m_clen	include/types/proxy.h	/^	unsigned long long m_clen;	\/* chunk len for this message *\/$/;"	m	struct:error_snapshot
m_flags	include/types/proxy.h	/^	unsigned int m_flags;		\/* message flags *\/$/;"	m	struct:error_snapshot
m_l	include/types/proto_http.h	/^			int m_l;               \/* METHOD length (method starts at buf->p) *\/$/;"	m	struct:http_msg::__anon64::__anon65
main	contrib/base64/base64rev-gen.c	/^int main() {$/;"	f
main	contrib/halog/fgets2.c	/^int main() {$/;"	f
main	contrib/halog/halog.c	/^int main(int argc, char **argv)$/;"	f
main	contrib/ip6range/ip6range.c	/^main(int argc, char **argv)$/;"	f
main	contrib/iprange/iprange.c	/^main(int argc, char **argv)$/;"	f
main	src/haproxy-systemd-wrapper.c	/^int main(int argc, char **argv)$/;"	f
main	src/haproxy.c	/^int main(int argc, char **argv)$/;"	f
main	tests/filltab25.c	/^main(int argc, char **argv) {$/;"	f
main	tests/ip-hash.c	/^int main() {$/;"	f
main	tests/reset.c	/^int main(int argc, char **argv) {$/;"	f
main	tests/sessionhash_test.c	/^int main(int argc, char *argv[])$/;"	f
main	tests/test-arg.c	/^int main(int argc, char **argv)$/;"	f
main	tests/test.c	/^main() {$/;"	f
main	tests/test_hashes.c	/^int main(){$/;"	f
main	tests/test_pools.c	/^int main(void)$/;"	f
main	tests/testinet.c	/^main() {$/;"	f
main	tests/uri_hash.c	/^int main() {$/;"	f
make_4delim	src/pattern.c	/^static inline unsigned int make_4delim(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4)$/;"	f	file:
make_arg_list	src/arg.c	/^int make_arg_list(const char *in, int len, unsigned int mask, struct arg **argp,$/;"	f
make_line	src/trace.c	/^static void make_line(void *from, void *to, int level, char dir)$/;"	f	file:
make_proxy_line	src/connection.c	/^int make_proxy_line(char *buf, int buf_len, struct server *srv, struct connection *remote)$/;"	f
make_proxy_line_v1	src/connection.c	/^int make_proxy_line_v1(char *buf, int buf_len, struct sockaddr_storage *src, struct sockaddr_storage *dst)$/;"	f
make_proxy_line_v2	src/connection.c	/^int make_proxy_line_v2(char *buf, int buf_len, struct server *srv, struct connection *remote)$/;"	f
make_tlv	src/connection.c	/^static int make_tlv(char *dest, int dest_len, char type, uint16_t length, char *value)$/;"	f	file:
manage_client_side_appsession	src/proto_http.c	/^void manage_client_side_appsession(struct session *s, const char *buf, int len) {$/;"	f
manage_client_side_cookies	src/proto_http.c	/^void manage_client_side_cookies(struct session *s, struct channel *req)$/;"	f
manage_global_listener_queue	src/haproxy.c	/^static struct task *manage_global_listener_queue(struct task *t)$/;"	f	file:
manage_proxy	src/proxy.c	/^struct task *manage_proxy(struct task *t)$/;"	f
manage_server_side_cookies	src/proto_http.c	/^void manage_server_side_cookies(struct session *s, struct channel *res)$/;"	f
map	include/types/arg.h	/^	struct map_descriptor *map;$/;"	m	union:arg_data	typeref:struct:arg_data::map_descriptor
map	include/types/backend.h	/^	struct lb_map map;		\/* LB parameters for map-based algorithms *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_map
map	include/types/proto_http.h	/^		} map;$/;"	m	union:http_req_rule::__anon67	typeref:struct:http_req_rule::__anon67::__anon70
map	include/types/proto_http.h	/^		} map;$/;"	m	union:http_res_rule::__anon71	typeref:struct:http_res_rule::__anon71::__anon73
map	include/types/stream_interface.h	/^		} map;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon50
map_create_descriptor	src/map.c	/^static struct map_descriptor *map_create_descriptor(struct sample_conv *conv)$/;"	f	file:
map_descriptor	include/types/map.h	/^struct map_descriptor {$/;"	s
map_get_server_hash	src/lb_map.c	/^struct server *map_get_server_hash(struct proxy *px, unsigned int hash)$/;"	f
map_get_server_rr	src/lb_map.c	/^struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid)$/;"	f
map_parse_int	src/map.c	/^int map_parse_int(const char *text, struct sample_storage *smp)$/;"	f
map_parse_ip	src/map.c	/^int map_parse_ip(const char *text, struct sample_storage *smp)$/;"	f
map_parse_ip6	src/map.c	/^int map_parse_ip6(const char *text, struct sample_storage *smp)$/;"	f
map_parse_str	src/map.c	/^int map_parse_str(const char *text, struct sample_storage *smp)$/;"	f
map_set_server_status_down	src/lb_map.c	/^static void map_set_server_status_down(struct server *srv)$/;"	f	file:
map_set_server_status_up	src/lb_map.c	/^static void map_set_server_status_up(struct server *srv)$/;"	f	file:
mark	include/types/proto_http.h	/^		int mark;                      \/* nfmark value for HTTP_REQ_ACT_SET_MARK *\/$/;"	m	union:http_req_rule::__anon67
mark	include/types/proto_http.h	/^		int mark;                      \/* nfmark value for HTTP_RES_ACT_SET_MARK *\/$/;"	m	union:http_res_rule::__anon71
mask	include/types/pattern.h	/^			struct in_addr mask;$/;"	m	struct:pattern::__anon10::__anon12	typeref:struct:pattern::__anon10::__anon12::in_addr
mask	include/types/pattern.h	/^			unsigned char mask;     \/* number of bits *\/$/;"	m	struct:pattern::__anon10::__anon13
mask	src/log.c	/^	int mask;$/;"	m	struct:logformat_var_args	file:
match	include/types/acl.h	/^	struct pattern *(*match)(struct sample *smp, struct pattern_expr *expr, int fill);$/;"	m	struct:acl_keyword	typeref:struct:acl_keyword::match
match	include/types/pattern.h	/^	struct pattern *(*match)(struct sample *, struct pattern_expr *, int);$/;"	m	struct:pattern_head	typeref:struct:pattern_head::match
match_str	src/appsession.c	/^int match_str(const void *key1, const void *key2)$/;"	f
match_type	include/types/acl.h	/^	int match_type; \/* Contain PAT_MATCH_* *\/$/;"	m	struct:acl_keyword
match_word	src/pattern.c	/^static int match_word(struct sample *smp, struct pattern *pattern, int mflags, unsigned int delimiters)$/;"	f	file:
max	include/types/pattern.h	/^			signed long long min, max;$/;"	m	struct:pattern::__anon10::__anon11
max_http_hdr	include/types/global.h	/^		int max_http_hdr;  \/* max number of HTTP headers, use MAX_HTTP_HDR if zero *\/$/;"	m	struct:global::__anon95
max_ka_queue	include/types/proxy.h	/^	int max_ka_queue;			\/* 1+maximum requests in queue accepted for reusing a K-A conn (0=none) *\/$/;"	m	struct:proxy
max_set	include/types/pattern.h	/^			int max_set :1;$/;"	m	struct:pattern::__anon10::__anon11
max_spread_checks	include/types/global.h	/^	int max_spread_checks;$/;"	m	struct:global
maxaccept	include/types/global.h	/^		int maxaccept;     \/* max number of consecutive accept() *\/$/;"	m	struct:global::__anon95
maxaccept	include/types/listener.h	/^	unsigned int maxaccept;         \/* if set, max number of connections accepted at once *\/$/;"	m	struct:listener
maxconn	include/types/global.h	/^	int maxconn, hardmaxconn;$/;"	m	struct:global
maxconn	include/types/listener.h	/^	int maxconn;			\/* maximum connections allowed on this listener *\/$/;"	m	struct:listener
maxconn	include/types/proxy.h	/^	unsigned int maxconn;                   \/* max # of active sessions on the frontend *\/$/;"	m	struct:proxy
maxconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server
maxfd	src/fd.c	/^int maxfd;                      \/* # of the highest fd + 1 *\/$/;"	v
maxpipes	include/types/global.h	/^	int maxpipes;		\/* max # of pipes *\/$/;"	m	struct:global
maxpollevents	include/types/global.h	/^		int maxpollevents; \/* max number of poll events at once *\/$/;"	m	struct:global::__anon95
maxqueue	include/types/server.h	/^	int maxqueue;				\/* maximum number of pending connections allowed *\/$/;"	m	struct:server
maxrewrite	include/types/global.h	/^		int maxrewrite;    \/* buffer max rewrite size in bytes, defaults to MAXREWRITE *\/$/;"	m	struct:global::__anon95
maxseg	include/types/listener.h	/^	int maxseg;			\/* for TCP, advertised MSS *\/$/;"	m	struct:listener
maxsock	include/types/global.h	/^	int maxsock;		\/* max # of sockets *\/$/;"	m	struct:global
maxsslconn	include/types/global.h	/^	int maxsslconn;$/;"	m	struct:global
maxzlibmem	include/types/global.h	/^	long maxzlibmem;        \/* max RAM for zlib in bytes *\/$/;"	m	struct:global
may_dequeue_tasks	include/proto/queue.h	/^static inline int may_dequeue_tasks(const struct server *s, const struct proxy *p) {$/;"	f
measure_idle	include/common/time.h	/^static inline void measure_idle()$/;"	f
mem_poison_byte	src/memory.c	/^char mem_poison_byte = 0;$/;"	v
memprintf	src/standard.c	/^char *memprintf(char **out, const char *format, ...)$/;"	f
meth	include/types/proto_http.h	/^	enum http_meth_t meth;          \/* HTTP method *\/$/;"	m	struct:http_txn	typeref:enum:http_txn::http_meth_t
meth	include/types/sample.h	/^		struct meth     meth;  \/* used for http method *\/$/;"	m	union:sample::__anon92	typeref:struct:sample::__anon92::meth
meth	include/types/sample.h	/^		struct meth     meth;  \/* used for http method *\/$/;"	m	union:sample_storage::__anon93	typeref:struct:sample_storage::__anon93::meth
meth	include/types/sample.h	/^	enum http_meth_t meth;$/;"	m	struct:meth	typeref:enum:meth::http_meth_t
meth	include/types/sample.h	/^struct meth {$/;"	s
meth	src/proto_http.c	/^	enum http_meth_t meth;$/;"	m	struct:http_method_desc	typeref:enum:http_method_desc::http_meth_t	file:
method	include/types/proto_http.h	/^	enum ht_auth_m method;                \/* one of HTTP_AUTH_* *\/$/;"	m	struct:http_auth_data	typeref:enum:http_auth_data::ht_auth_m
method_data	include/types/proto_http.h	/^	struct chunk method_data;             \/* points to the creditial part from 'Authorization:' header *\/$/;"	m	struct:http_auth_data	typeref:struct:http_auth_data::chunk
mflags	include/types/pattern.h	/^	int mflags;                     \/* flags relative to the parsing or matching method. *\/$/;"	m	struct:pattern_expr
min	include/types/pattern.h	/^			signed long long min, max;$/;"	m	struct:pattern::__anon10::__anon11
min_set	include/types/pattern.h	/^			int min_set :1;$/;"	m	struct:pattern::__anon10::__anon11
minavail	include/common/memory.h	/^	unsigned int minavail;	\/* how many chunks are expected to be used *\/$/;"	m	struct:pool_head
minconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server
minlvl	include/types/log.h	/^	int minlvl;$/;"	m	struct:logsrv
mix	tests/test_hashes.c	354;"	d	file:
mode	include/types/global.h	/^			mode_t mode;    \/* 0 to leave unchanged *\/$/;"	m	struct:global::__anon96::__anon97
mode	include/types/global.h	/^	int mode;$/;"	m	struct:global
mode	include/types/listener.h	/^		mode_t mode;       \/* 0 to leave unchanged *\/$/;"	m	struct:bind_conf::__anon51
mode	include/types/proxy.h	/^	enum pr_mode mode;                      \/* mode = PR_MODE_TCP, PR_MODE_HTTP or PR_MODE_HEALTH *\/$/;"	m	struct:proxy	typeref:enum:proxy::pr_mode
mode	src/cfgparse.c	/^	unsigned int mode;$/;"	m	struct:cfg_opt	file:
mode	src/log.c	/^	int mode;$/;"	m	struct:logformat_type	file:
mon_fail_cond	include/types/proxy.h	/^	struct list mon_fail_cond;              \/* list of conditions to fail monitoring requests (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
mon_mask	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::
mon_net	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
monitor_uri	include/types/proxy.h	/^	char *monitor_uri;			\/* a special URI to which we respond with HTTP\/200 OK *\/$/;"	m	struct:proxy
monitor_uri_len	include/types/proxy.h	/^	int monitor_uri_len;			\/* length of the string above. 0 if unused *\/$/;"	m	struct:proxy
monthname	src/standard.c	/^const char *monthname[12] = {$/;"	v
ms_left_scaled	src/time.c	/^unsigned int   ms_left_scaled;  \/* milliseconds left for current second (0..2^32-1) *\/$/;"	v
msg	include/types/stream_interface.h	/^			const char *msg;	\/* pointer to a persistent message to be returned in PRINT state *\/$/;"	m	struct:appctx::__anon43::__anon48
msg_state	include/types/proto_http.h	/^	enum ht_state msg_state;               \/* where we are in the current message parsing *\/$/;"	m	struct:http_msg	typeref:enum:http_msg::ht_state
mul32hi	include/common/standard.h	/^static inline unsigned int mul32hi(unsigned int a, unsigned int b)$/;"	f
mutex	src/shctx.c	/^	pthread_mutex_t mutex;$/;"	m	struct:shared_context	file:
my_memmem	src/standard.c	/^const void *my_memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen)$/;"	f
my_regex	include/common/regex.h	/^struct my_regex {$/;"	s
my_strndup	src/standard.c	/^char *my_strndup(const char *src, int n)$/;"	f
n	include/common/mini-clist.h	/^    struct list *n;	\/* next *\/$/;"	m	struct:list	typeref:struct:list::list
n	include/types/session.h	/^		char *n;			\/* or its name during parsing. *\/$/;"	m	union:track_ctr_prm::__anon56
n	src/shctx.c	/^	struct shared_block *n;$/;"	m	struct:shared_block	typeref:struct:shared_block::shared_block	file:
name	include/common/memory.h	/^	char name[12];		\/* name of the pool *\/$/;"	m	struct:pool_head
name	include/types/acl.h	/^	char *name;		    \/* acl name *\/$/;"	m	struct:acl
name	include/types/auth.h	/^	char *name;$/;"	m	struct:auth_groups
name	include/types/auth.h	/^	char *name;$/;"	m	struct:userlist
name	include/types/capture.h	/^    char *name;				\/* header name, case insensitive, NULL if not header *\/$/;"	m	struct:cap_hdr
name	include/types/compression.h	/^	char *name;$/;"	m	struct:comp_algo
name	include/types/compression.h	/^	char *name;$/;"	m	struct:comp_type
name	include/types/fd.h	/^	const char   *name;                                  \/* poller name *\/$/;"	m	struct:poller
name	include/types/listener.h	/^	char *name;			\/* listener's name *\/$/;"	m	struct:listener
name	include/types/proto_http.h	/^			char *name;            \/* header name *\/$/;"	m	struct:http_req_rule::__anon67::__anon69
name	include/types/proto_http.h	/^			char *name;            \/* header name *\/$/;"	m	struct:http_res_rule::__anon71::__anon72
name	include/types/proto_http.h	/^	char *name;$/;"	m	struct:http_method_name
name	include/types/protocol.h	/^	char name[PROTO_NAME_LEN];			\/* protocol name, zero-terminated *\/$/;"	m	struct:protocol
name	include/types/proxy.h	/^		char *name;			\/* default backend name during config parse *\/$/;"	m	union:proxy::__anon15
name	include/types/proxy.h	/^		char *name;			\/* target backend name during config parsing *\/$/;"	m	union:switching_rule::__anon20
name	include/types/proxy.h	/^		char *name;			\/* target server name during config parsing *\/$/;"	m	union:server_rule::__anon21
name	include/types/proxy.h	/^		char *name;                     \/* target table name during config parsing *\/$/;"	m	union:sticking_rule::__anon22
name	include/types/ssl_sock.h	/^	struct ebmb_node name;    \/* node holding the servername value *\/$/;"	m	struct:sni_ctx	typeref:struct:sni_ctx::ebmb_node
name	include/types/stick_table.h	/^		char *name;$/;"	m	union:stktable::__anon29
name	include/types/stick_table.h	/^	const char *name; \/* name of the data type *\/$/;"	m	struct:stktable_data_type
name	include/types/stream_interface.h	/^	char *name;                                  \/* applet's name to report in logs *\/$/;"	m	struct:si_applet
name	src/acl.c	/^	const char *name;$/;"	m	struct:__anon114	file:
name	src/cfgparse.c	/^	const char *name;$/;"	m	struct:cfg_opt	file:
name	src/log.c	/^	char *name;$/;"	m	struct:logformat_type	file:
name	src/log.c	/^	char *name;$/;"	m	struct:logformat_var_args	file:
name_len	include/types/compression.h	/^	int name_len;$/;"	m	struct:comp_algo
name_len	include/types/compression.h	/^	int name_len;$/;"	m	struct:comp_type
name_len	include/types/proto_http.h	/^			int name_len;          \/* header name's length *\/$/;"	m	struct:http_req_rule::__anon67::__anon69
name_len	include/types/proto_http.h	/^			int name_len;          \/* header name's length *\/$/;"	m	struct:http_res_rule::__anon71::__anon72
namelen	include/types/capture.h	/^    int namelen;			\/* length of the header name, to speed-up lookups, 0 if !name *\/$/;"	m	struct:cap_hdr
nb_ct	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_err	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:
nb_listeners	include/types/protocol.h	/^	int nb_listeners;				\/* number of listeners *\/$/;"	m	struct:protocol
nb_ok	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_oldpids	src/haproxy.c	/^int nb_oldpids = 0;$/;"	v
nb_req	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:
nb_req_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy
nb_rsp_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy
nb_rt	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_tasks	src/task.c	/^unsigned int nb_tasks = 0;$/;"	v
nb_tasks_cur	src/task.c	/^unsigned int nb_tasks_cur = 0;     \/* copy of the tasks count *\/$/;"	v
nbconn	include/types/listener.h	/^	int nbconn;			\/* current number of connections on this listener *\/$/;"	m	struct:listener
nbits	include/common/standard.h	/^static inline unsigned long nbits(int bits)$/;"	f
nbpend	include/types/proxy.h	/^	int nbpend;				\/* number of pending connections with no server assigned yet *\/$/;"	m	struct:proxy
nbpend	include/types/server.h	/^	int nbpend;				\/* number of pending connections *\/$/;"	m	struct:server
nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections reached *\/$/;"	m	struct:srvcounters
nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;                \/* max number of pending connections with no server assigned yet (BE only) *\/$/;"	m	struct:pxcounters
nbpollers	src/fd.c	/^int nbpollers = 0;$/;"	v
nbproc	include/types/global.h	/^	int nbproc;$/;"	m	struct:global
neg	include/types/acl.h	/^	int neg;                    \/* 1 if the ACL result must be negated *\/$/;"	m	struct:acl_term
neg	include/types/ssl_sock.h	/^	int neg;                  \/* reject if match *\/$/;"	m	struct:sni_ctx
next	include/common/regex.h	/^    struct hdr_exp *next;$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::hdr_exp
next	include/common/uri_auth.h	/^	struct stat_scope *next;	\/* next entry, NULL if none *\/$/;"	m	struct:stat_scope	typeref:struct:stat_scope::stat_scope
next	include/common/uri_auth.h	/^	struct uri_auth *next;		\/* Used at deinit() to build a list of unique elements *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::uri_auth
next	include/types/auth.h	/^	struct auth_groups *next;$/;"	m	struct:auth_groups	typeref:struct:auth_groups::auth_groups
next	include/types/auth.h	/^	struct auth_groups_list *next;$/;"	m	struct:auth_groups_list	typeref:struct:auth_groups_list::auth_groups_list
next	include/types/auth.h	/^	struct auth_users *next;$/;"	m	struct:auth_users	typeref:struct:auth_users::auth_users
next	include/types/auth.h	/^	struct userlist *next;$/;"	m	struct:userlist	typeref:struct:userlist::userlist
next	include/types/capture.h	/^    struct cap_hdr *next;$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::cap_hdr
next	include/types/compression.h	/^	struct comp_algo *next;$/;"	m	struct:comp_algo	typeref:struct:comp_algo::comp_algo
next	include/types/compression.h	/^	struct comp_type *next;$/;"	m	struct:comp_type	typeref:struct:comp_type::comp_type
next	include/types/hdr_idx.h	/^        unsigned next :15; \/* offset of next header if len>0. 0=end of list. *\/$/;"	m	struct:hdr_idx_elem
next	include/types/lb_fwrr.h	/^	struct eb_root *next;   \/* servers to be placed at next run *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
next	include/types/peers.h	/^	struct peer *next;	  \/* next peer in the list *\/$/;"	m	struct:peer	typeref:struct:peer::peer
next	include/types/peers.h	/^	struct peer_session *next;$/;"	m	struct:peer_session	typeref:struct:peer_session::peer_session
next	include/types/peers.h	/^	struct peers *next;		 \/* next peer section *\/$/;"	m	struct:peers	typeref:struct:peers::peers
next	include/types/peers.h	/^	struct shared_table *next;	    \/* next shared table in list *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::shared_table
next	include/types/pipe.h	/^	struct pipe *next;$/;"	m	struct:pipe	typeref:struct:pipe::pipe
next	include/types/proto_http.h	/^	unsigned int next;                     \/* pointer to next byte to parse, relative to buf->p *\/$/;"	m	struct:http_msg
next	include/types/proxy.h	/^	struct proxy *next;$/;"	m	struct:proxy	typeref:struct:proxy::proxy
next	include/types/server.h	/^	struct server *next;$/;"	m	struct:server	typeref:struct:server::server
next	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:
next_event_delay	src/freq_ctr.c	/^unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f
next_full	include/types/server.h	/^	struct server *next_full;               \/* next server in the temporary full list *\/$/;"	m	struct:server	typeref:struct:server::server
next_tree	tests/filltab25.c	/^struct eb_root *next_tree; \/* receives positions >= 2sw *\/$/;"	v	typeref:struct:eb_root
next_weight	include/types/lb_fwrr.h	/^	int next_weight;        \/* total weight of the next time range *\/$/;"	m	struct:fwrr_group
nice	include/types/listener.h	/^	short int nice;                 \/* nice value to assign to the instanciated tasks *\/$/;"	m	struct:listener
nice	include/types/proto_http.h	/^		int nice;                      \/* nice value for HTTP_REQ_ACT_SET_NICE *\/$/;"	m	union:http_req_rule::__anon67
nice	include/types/proto_http.h	/^		int nice;                      \/* nice value for HTTP_RES_ACT_SET_NICE *\/$/;"	m	union:http_res_rule::__anon71
nice	include/types/task.h	/^	short nice;			\/* the task's current nice value from -1024 to +1024 *\/$/;"	m	struct:task
niced_tasks	src/task.c	/^unsigned int niced_tasks = 0;      \/* number of niced tasks in the run queue *\/$/;"	v
no_options	include/types/proxy.h	/^	int no_options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy
no_options2	include/types/proxy.h	/^	int no_options2;			\/* PR_O2_* *\/$/;"	m	struct:proxy
node	contrib/halog/halog.c	/^	struct eb32_node node;$/;"	m	struct:timer	typeref:struct:timer::eb32_node	file:
node	contrib/halog/halog.c	/^	struct ebmb_node node;$/;"	m	struct:srv_st	typeref:struct:srv_st::ebmb_node	file:
node	contrib/halog/halog.c	/^	} node;$/;"	m	struct:url_stat	typeref:union:url_stat::__anon108	file:
node	ebtree/eb32tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb32_node	typeref:struct:eb32_node::eb_node
node	ebtree/eb64tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb64_node	typeref:struct:eb64_node::eb_node
node	ebtree/ebmbtree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebmb_node	typeref:struct:ebmb_node::eb_node
node	ebtree/ebpttree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebpt_node	typeref:struct:ebpt_node::eb_node
node	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth
node	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global
node	include/types/pattern.h	/^	struct ebmb_node node;$/;"	m	struct:pattern_tree	typeref:struct:pattern_tree::ebmb_node
node	include/types/server.h	/^	struct eb32_node node;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::eb32_node
node	tests/filltab25.c	/^	struct eb32_node node;$/;"	m	struct:srv	typeref:struct:srv::eb32_node	file:
node_p	ebtree/ebtree.h	/^	eb_troot_t    *node_p;  \/* link node's parent *\/$/;"	m	struct:eb_node
nolinger	src/haproxy.c	/^const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };$/;"	v	typeref:struct:linger
nopurge	include/types/stick_table.h	/^	int nopurge;              \/* if non-zero, don't purge sticky sessions when full *\/$/;"	m	struct:stktable
now	src/time.c	/^struct timeval now;             \/* internal date is a monotonic function of real clock *\/$/;"	v	typeref:struct:timeval
now_ms	src/time.c	/^unsigned int   now_ms;          \/* internal date in milliseconds (may wrap) *\/$/;"	v
now_ptr	src/trace.c	/^static struct timeval *now_ptr;$/;"	v	typeref:struct:timeval	file:
npn_len	include/types/listener.h	/^	int npn_len;               \/* NPN protocol string length *\/$/;"	m	struct:bind_conf
npn_str	include/types/listener.h	/^	char *npn_str;             \/* NPN protocol string *\/$/;"	m	struct:bind_conf
npos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server
nsrv	tests/filltab25.c	/^int nsrv;       \/* # of servers *\/$/;"	v
nsw	tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
num	tests/filltab25.c	/^	int num;$/;"	m	struct:srv	file:
o	include/common/buffer.h	/^	unsigned int o;                 \/* number of out bytes the sender can consume from this buffer *\/$/;"	m	struct:buffer
oat_hash	tests/test_hashes.c	/^unsigned oat_hash ( void *key, int len )$/;"	f
ob	include/types/stream_interface.h	/^	struct channel *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::
obj_base_ptr	include/proto/obj_type.h	/^static inline void *obj_base_ptr(enum obj_type *t)$/;"	f
obj_type	include/proto/obj_type.h	/^static inline enum obj_type obj_type(enum obj_type *t)$/;"	f
obj_type	include/types/connection.h	/^	enum obj_type obj_type;       \/* differentiates connection from applet context *\/$/;"	m	struct:connection	typeref:enum:connection::obj_type
obj_type	include/types/listener.h	/^	enum obj_type obj_type;         \/* object type = OBJ_TYPE_LISTENER *\/$/;"	m	struct:listener	typeref:enum:listener::obj_type
obj_type	include/types/obj_type.h	/^enum obj_type {$/;"	g
obj_type	include/types/proxy.h	/^	enum obj_type obj_type;                 \/* object type == OBJ_TYPE_PROXY *\/$/;"	m	struct:proxy	typeref:enum:proxy::obj_type
obj_type	include/types/server.h	/^	enum obj_type obj_type;                 \/* object type == OBJ_TYPE_SERVER *\/$/;"	m	struct:server	typeref:enum:server::obj_type
obj_type	include/types/stream_interface.h	/^	enum obj_type obj_type;                      \/* object type = OBJ_TYPE_APPLET *\/$/;"	m	struct:si_applet	typeref:enum:si_applet::obj_type
obj_type	include/types/stream_interface.h	/^	enum obj_type obj_type;    \/* OBJ_TYPE_APPCTX *\/$/;"	m	struct:appctx	typeref:enum:appctx::obj_type
obj_type_name	include/proto/obj_type.h	/^static inline const char *obj_type_name(enum obj_type *t)$/;"	f
objt_appctx	include/proto/obj_type.h	/^static inline struct appctx *objt_appctx(enum obj_type *t)$/;"	f
objt_applet	include/proto/obj_type.h	/^static inline struct si_applet *objt_applet(enum obj_type *t)$/;"	f
objt_conn	include/proto/obj_type.h	/^static inline struct connection *objt_conn(enum obj_type *t)$/;"	f
objt_listener	include/proto/obj_type.h	/^static inline struct listener *objt_listener(enum obj_type *t)$/;"	f
objt_proxy	include/proto/obj_type.h	/^static inline struct proxy *objt_proxy(enum obj_type *t)$/;"	f
objt_server	include/proto/obj_type.h	/^static inline struct server *objt_server(enum obj_type *t)$/;"	f
observe	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server
oe	include/types/proxy.h	/^	struct proxy *oe;		\/* other end = frontend or backend involved *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::proxy
offload	include/types/compression.h	/^	unsigned int offload;$/;"	m	struct:comp
offsetof	include/common/rbtree.h	121;"	d
oldpids	src/haproxy.c	/^static int *oldpids = NULL;$/;"	v	file:
oldpids_sig	src/haproxy.c	/^static int oldpids_sig; \/* use USR1 or TERM *\/$/;"	v	file:
one	contrib/ip6range/ip6range.c	/^static struct in6_addr one = { .in6_u.u6_addr32 = {0, 0, 0, 1} };$/;"	v	typeref:struct:in6_addr	file:
one	src/haproxy.c	/^const int one = 1;$/;"	v
one_ls_b	contrib/ip6range/ip6range.c	/^static inline struct in6_addr *one_ls_b(unsigned int b, struct in6_addr *r)$/;"	f	file:
onerror	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server
onmarkeddown	include/types/server.h	/^	short onmarkeddown;			\/* what to do when marked down: one of HANA_ONMARKEDDOWN_* *\/$/;"	m	struct:server
onmarkedup	include/types/server.h	/^	short onmarkedup;			\/* what to do when marked up: one of HANA_ONMARKEDUP_* *\/$/;"	m	struct:server
op	include/import/ip_tproxy.h	/^	u_int32_t op;$/;"	m	struct:in_tproxy
open_trace	src/trace.c	/^static int open_trace()$/;"	f	file:
ops	include/types/stream_interface.h	/^	struct si_ops *ops;     \/* general operations at the stream interface layer *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::si_ops
options	include/types/global.h	/^		int options;       \/* various tuning options *\/$/;"	m	struct:global::__anon95
options	include/types/listener.h	/^	int options;			\/* socket options : LI_O_* *\/$/;"	m	struct:listener
options	include/types/log.h	/^	int options;   \/\/ LOG_OPT_*$/;"	m	struct:logformat_node
options	include/types/proxy.h	/^	int options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy
options	include/types/server.h	/^		int options;			\/* ssl options *\/$/;"	m	struct:server::__anon99
options2	include/types/proxy.h	/^	int options2;				\/* PR_O2_* *\/$/;"	m	struct:proxy
opts	include/types/connection.h	/^	unsigned int opts;                   \/* CO_SRC_* *\/$/;"	m	struct:conn_src
order	include/types/ssl_sock.h	/^	int order;                \/* load order for the certificate *\/$/;"	m	struct:sni_ctx
orgto_hdr_len	include/types/proxy.h	/^	int orgto_hdr_len;			\/* length of "x-original-to" header *\/$/;"	m	struct:proxy
orgto_hdr_name	include/types/proxy.h	/^	char *orgto_hdr_name;			\/* header to use - default: "x-original-to" *\/$/;"	m	struct:proxy
out_type	include/types/sample.h	/^	unsigned int out_type;                    \/* output sample type *\/$/;"	m	struct:sample_conv
out_type	include/types/sample.h	/^	unsigned long out_type;                   \/* output sample type *\/$/;"	m	struct:sample_fetch
owner	include/types/connection.h	/^	void *owner;                  \/* pointer to upper layer's entity (eg: stream interface) *\/$/;"	m	struct:connection
owner	include/types/fd.h	/^	void *owner;                         \/* the connection or listener associated with this fd, NULL if closed *\/$/;"	m	struct:fdtab
owner	include/types/stream_interface.h	/^	void *owner;            \/* generally a (struct task*) *\/$/;"	m	struct:stream_interface
p	include/common/buffer.h	/^	char *p;                        \/* buffer's start pointer, separates in and out data *\/$/;"	m	struct:buffer
p	include/common/mini-clist.h	/^    struct list *p;	\/* prev *\/$/;"	m	struct:list	typeref:struct:list::list
p	include/types/counters.h	/^	} p;                                    \/* protocol-specific stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon3
p	include/types/counters.h	/^	} p;$/;"	m	struct:srvcounters	typeref:union:srvcounters::__anon5
p	include/types/sample.h	/^	void *p;        \/* any pointer *\/$/;"	m	union:smp_ctx
p	include/types/stick_table.h	/^		struct peers *p; \/* sync peers *\/$/;"	m	union:stktable::__anon29	typeref:struct:stktable::__anon29::peers
p	include/types/stick_table.h	/^		void *p;$/;"	m	union:stktable::__anon30
p	src/shctx.c	/^	struct shared_block *p;$/;"	m	struct:shared_block	typeref:struct:shared_block::shared_block	file:
p	tests/filltab25.c	/^int p;          \/* current position, between sw..2sw-1 *\/$/;"	v
parent	include/types/proxy.h	/^	void *parent;				\/* parent of the proxy when applicable *\/$/;"	m	struct:proxy
parse	include/common/cfgparse.h	/^	int (*parse)(                           \/* 0=OK, <0=Alert, >0=Warning *\/$/;"	m	struct:cfg_keyword
parse	include/types/acl.h	/^	int (*parse)(const char *text, struct pattern *pattern, int flags, char **err);$/;"	m	struct:acl_keyword
parse	include/types/listener.h	/^	int (*parse)(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err);$/;"	m	struct:bind_kw
parse	include/types/pattern.h	/^	int (*parse)(const char *text, struct pattern *pattern, int flags, char **err);$/;"	m	struct:pattern_head
parse	include/types/proto_http.h	/^       int (*parse)(const char **args, int *cur_arg, struct proxy *px, struct http_req_rule *rule, char **err);$/;"	m	struct:http_req_action_kw
parse	include/types/proto_http.h	/^       int (*parse)(const char **args, int *cur_arg, struct proxy *px, struct http_res_rule *rule, char **err);$/;"	m	struct:http_res_action_kw
parse	include/types/server.h	/^	int (*parse)(char **args, int *cur_arg, struct proxy *px, struct server *srv, char **err);$/;"	m	struct:srv_kw
parse_acl	src/acl.c	/^struct acl *parse_acl(const char **args, struct list *known_acl, char **err, struct arg_list *al,$/;"	f
parse_acl_cond	src/acl.c	/^struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl,$/;"	f
parse_acl_expr	src/acl.c	/^struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *al,$/;"	f
parse_binary	src/standard.c	/^int parse_binary(const char *source, char **binstr, int *binstrlen, char **err)$/;"	f
parse_conf	examples/check	/^sub parse_conf$/;"	s
parse_err	contrib/halog/halog.c	/^int parse_err = 0;$/;"	v
parse_http_req_cond	src/proto_http.c	/^struct http_req_rule *parse_http_req_cond(const char **args, const char *file, int linenum, struct proxy *proxy)$/;"	f
parse_http_res_cond	src/proto_http.c	/^struct http_res_rule *parse_http_res_cond(const char **args, const char *file, int linenum, struct proxy *proxy)$/;"	f
parse_logformat_string	src/log.c	/^void parse_logformat_string(const char *fmt, struct proxy *curproxy, struct list *list_format, int options, int cap, const char *file, int line)$/;"	f
parse_logformat_var	src/log.c	/^int parse_logformat_var(char *arg, int arg_len, char *var, int var_len, struct proxy *curproxy, struct list *list_format, int *defoptions)$/;"	f
parse_logformat_var_args	src/log.c	/^int parse_logformat_var_args(char *args, struct logformat_node *node)$/;"	f
parse_qvalue	src/proto_http.c	/^int parse_qvalue(const char *qvalue, const char **end)$/;"	f
parse_server	src/server.c	/^int parse_server(const char *file, int linenum, char **args, struct proxy *curproxy, struct proxy *defproxy)$/;"	f
parse_size_err	src/standard.c	/^const char *parse_size_err(const char *text, unsigned *ret) {$/;"	f
parse_smp	include/types/pattern.h	/^	int (*parse_smp)(const char *text, struct sample_storage *smp);$/;"	m	struct:pattern_head
parse_time_err	src/standard.c	/^const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags)$/;"	f
pass	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users
pass	include/types/proto_http.h	/^	char *user, *pass;                    \/* extracted username & password *\/$/;"	m	struct:http_auth_data
pat	include/types/acl.h	/^	struct pattern_head pat;      \/* the pattern matching expression *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::pattern_head
pat	include/types/map.h	/^	struct pattern_head pat;       \/* the pattern matching associated to the map *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::pattern_head
pat	include/types/pattern.h	/^	struct list pat; \/* The head of the list of struct pattern_expr. *\/$/;"	m	struct:pat_ref	typeref:struct:pat_ref::list
pat	include/types/pattern.h	/^	struct pattern pat;$/;"	m	struct:pattern_list	typeref:struct:pattern_list::pattern
pat2acl	src/acl.c	/^static inline enum acl_test_res pat2acl(struct pattern *pat)$/;"	f	file:
pat_del_list_ptr	src/pattern.c	/^void pat_del_list_ptr(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_list_reg	src/pattern.c	/^void pat_del_list_reg(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_list_val	src/pattern.c	/^void pat_del_list_val(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_tree_ip	src/pattern.c	/^void pat_del_tree_ip(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_tree_str	src/pattern.c	/^void pat_del_tree_str(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_delete_fcts	src/pattern.c	/^void (*pat_delete_fcts[PAT_MATCH_NUM])(struct pattern_expr *, struct pat_ref_elt *) = {$/;"	v
pat_expr_get_next	src/dumpstats.c	/^struct pattern_expr *pat_expr_get_next(struct pattern_expr *getnext, struct list *end)$/;"	f	file:
pat_find_match_name	include/proto/pattern.h	/^static inline int pat_find_match_name(const char *name)$/;"	f
pat_head	include/types/pattern.h	/^	struct pattern_head *pat_head; \/* Point to the pattern_head that contain manipulation functions.$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::pattern_head
pat_idx_list_ptr	src/pattern.c	/^int pat_idx_list_ptr(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_list_reg	src/pattern.c	/^int pat_idx_list_reg(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_list_str	src/pattern.c	/^int pat_idx_list_str(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_list_val	src/pattern.c	/^int pat_idx_list_val(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_tree_ip	src/pattern.c	/^int pat_idx_tree_ip(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_tree_pfx	src/pattern.c	/^int pat_idx_tree_pfx(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_tree_str	src/pattern.c	/^int pat_idx_tree_str(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_index_fcts	src/pattern.c	/^int (*pat_index_fcts[PAT_MATCH_NUM])(struct pattern_expr *, struct pattern *, char **) = {$/;"	v
pat_list_get_next	src/dumpstats.c	/^struct pat_ref *pat_list_get_next(struct pat_ref *getnext, struct list *end,$/;"	f	file:
pat_match_auth	src/auth.c	/^pat_match_auth(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_beg	src/pattern.c	/^struct pattern *pat_match_beg(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_bin	src/pattern.c	/^struct pattern *pat_match_bin(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_dir	src/pattern.c	/^struct pattern *pat_match_dir(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_dom	src/pattern.c	/^struct pattern *pat_match_dom(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_end	src/pattern.c	/^struct pattern *pat_match_end(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_fcts	src/pattern.c	/^struct pattern *(*pat_match_fcts[PAT_MATCH_NUM])(struct sample *, struct pattern_expr *, int) = {$/;"	v	typeref:struct:pat_match_fcts
pat_match_int	src/pattern.c	/^struct pattern *pat_match_int(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_ip	src/pattern.c	/^struct pattern *pat_match_ip(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_len	src/pattern.c	/^struct pattern *pat_match_len(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_meth	src/proto_http.c	/^static struct pattern *pat_match_meth(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f	file:
pat_match_names	src/pattern.c	/^char *pat_match_names[PAT_MATCH_NUM] = {$/;"	v
pat_match_nothing	src/pattern.c	/^struct pattern *pat_match_nothing(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_reg	src/pattern.c	/^struct pattern *pat_match_reg(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_res	include/types/pattern.h	/^enum pat_match_res {$/;"	g
pat_match_str	src/pattern.c	/^struct pattern *pat_match_str(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_sub	src/pattern.c	/^struct pattern *pat_match_sub(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_types	src/pattern.c	/^int pat_match_types[PAT_MATCH_NUM] = {$/;"	v
pat_parse_bin	src/pattern.c	/^int pat_parse_bin(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_dotted_ver	src/pattern.c	/^int pat_parse_dotted_ver(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_fcts	src/pattern.c	/^int (*pat_parse_fcts[PAT_MATCH_NUM])(const char *, struct pattern *, int, char **) = {$/;"	v
pat_parse_int	src/pattern.c	/^int pat_parse_int(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_ip	src/pattern.c	/^int pat_parse_ip(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_meth	src/proto_http.c	/^static int pat_parse_meth(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f	file:
pat_parse_nothing	src/pattern.c	/^int pat_parse_nothing(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_reg	src/pattern.c	/^int pat_parse_reg(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_str	src/pattern.c	/^int pat_parse_str(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_prune_fcts	src/pattern.c	/^void (*pat_prune_fcts[PAT_MATCH_NUM])(struct pattern_expr *) = {$/;"	v
pat_prune_ptr	src/pattern.c	/^void pat_prune_ptr(struct pattern_expr *expr)$/;"	f
pat_prune_reg	src/pattern.c	/^void pat_prune_reg(struct pattern_expr *expr)$/;"	f
pat_prune_val	src/pattern.c	/^void pat_prune_val(struct pattern_expr *expr)$/;"	f
pat_ref	include/types/pattern.h	/^struct pat_ref {$/;"	s
pat_ref_add	src/pattern.c	/^int pat_ref_add(struct pat_ref *ref,$/;"	f
pat_ref_append	src/pattern.c	/^int pat_ref_append(struct pat_ref *ref, char *pattern, char *sample, int line)$/;"	f
pat_ref_delete	src/pattern.c	/^int pat_ref_delete(struct pat_ref *ref, const char *key)$/;"	f
pat_ref_delete_by_id	src/pattern.c	/^int pat_ref_delete_by_id(struct pat_ref *ref, struct pat_ref_elt *refelt)$/;"	f
pat_ref_elt	include/types/pattern.h	/^struct pat_ref_elt {$/;"	s
pat_ref_find_elt	src/pattern.c	/^struct pat_ref_elt *pat_ref_find_elt(struct pat_ref *ref, const char *key)$/;"	f
pat_ref_lookup	src/pattern.c	/^struct pat_ref *pat_ref_lookup(const char *reference)$/;"	f
pat_ref_lookup_ref	src/dumpstats.c	/^struct pat_ref *pat_ref_lookup_ref(const char *reference)$/;"	f	file:
pat_ref_lookupid	src/pattern.c	/^struct pat_ref *pat_ref_lookupid(int unique_id)$/;"	f
pat_ref_new	src/pattern.c	/^struct pat_ref *pat_ref_new(const char *reference, const char *display, unsigned int flags)$/;"	f
pat_ref_newid	src/pattern.c	/^struct pat_ref *pat_ref_newid(int unique_id, const char *display, unsigned int flags)$/;"	f
pat_ref_prune	src/pattern.c	/^void pat_ref_prune(struct pat_ref *ref)$/;"	f
pat_ref_push	src/pattern.c	/^int pat_ref_push(struct pat_ref_elt *elt, struct pattern_expr *expr,$/;"	f	file:
pat_ref_read_from_file	src/pattern.c	/^int pat_ref_read_from_file(struct pat_ref *ref, const char *filename, char **err)$/;"	f
pat_ref_read_from_file_smp	src/pattern.c	/^int pat_ref_read_from_file_smp(struct pat_ref *ref, const char *filename, char **err)$/;"	f
pat_ref_reload	src/pattern.c	/^void pat_ref_reload(struct pat_ref *ref, struct pat_ref *replace)$/;"	f
pat_ref_set	src/pattern.c	/^int pat_ref_set(struct pat_ref *ref, const char *key, const char *value, char **err)$/;"	f
pat_ref_set_by_id	src/pattern.c	/^int pat_ref_set_by_id(struct pat_ref *ref, struct pat_ref_elt *refelt, const char *value, char **err)$/;"	f
pat_ref_set_elt	src/pattern.c	/^static inline int pat_ref_set_elt(struct pat_ref *ref, struct pat_ref_elt *elt,$/;"	f	file:
pat_time	include/types/pattern.h	/^struct pat_time {$/;"	s
pattern	include/types/pattern.h	/^	char *pattern;$/;"	m	struct:pat_ref_elt
pattern	include/types/pattern.h	/^struct pattern {$/;"	s
pattern_delete	src/pattern.c	/^int pattern_delete(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pattern_exec_match	src/pattern.c	/^struct pattern *pattern_exec_match(struct pattern_head *head, struct sample *smp, int fill)$/;"	f
pattern_expr	include/types/pattern.h	/^struct pattern_expr {$/;"	s
pattern_expr_list	include/types/pattern.h	/^struct pattern_expr_list {$/;"	s
pattern_finalize_config	src/pattern.c	/^void pattern_finalize_config(void)$/;"	f
pattern_find_smp	src/pattern.c	/^struct sample_storage **pattern_find_smp(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pattern_head	include/types/pattern.h	/^struct pattern_head {$/;"	s
pattern_init_expr	src/pattern.c	/^void pattern_init_expr(struct pattern_expr *expr)$/;"	f
pattern_init_head	src/pattern.c	/^void pattern_init_head(struct pattern_head *head)$/;"	f
pattern_list	include/types/pattern.h	/^struct pattern_list {$/;"	s
pattern_lookup_expr	src/pattern.c	/^struct pattern_expr *pattern_lookup_expr(struct pattern_head *head, struct pat_ref *ref)$/;"	f
pattern_new_expr	src/pattern.c	/^struct pattern_expr *pattern_new_expr(struct pattern_head *head, struct pat_ref *ref, char **err)$/;"	f
pattern_prune	src/pattern.c	/^void pattern_prune(struct pattern_head *head)$/;"	f
pattern_read_from_file	src/pattern.c	/^int pattern_read_from_file(struct pattern_head *head, unsigned int refflags,$/;"	f
pattern_reference	src/pattern.c	/^struct list pattern_reference = LIST_HEAD_INIT(pattern_reference);$/;"	v	typeref:struct:list
pattern_tree	include/types/pattern.h	/^	struct eb_root pattern_tree;  \/* may be used for lookup in large datasets *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::eb_root
pattern_tree	include/types/pattern.h	/^struct pattern_tree {$/;"	s
pattern_tree_2	include/types/pattern.h	/^	struct eb_root pattern_tree_2;  \/* may be used for different types *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::eb_root
patterns	include/types/pattern.h	/^	struct list patterns;         \/* list of acl_patterns *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list
pause_listener	src/listener.c	/^int pause_listener(struct listener *l)$/;"	f
pause_proxies	src/proxy.c	/^void pause_proxies(void)$/;"	f
pause_proxy	src/proxy.c	/^int pause_proxy(struct proxy *p)$/;"	f
peer	include/types/peers.h	/^	struct peer *peer;	      \/* current peer *\/$/;"	m	struct:peer_session	typeref:struct:peer_session::peer
peer	include/types/peers.h	/^struct peer {$/;"	s
peer_accept	src/peers.c	/^int peer_accept(struct session *s)$/;"	f
peer_applet	src/peers.c	/^static struct si_applet peer_applet = {$/;"	v	typeref:struct:si_applet	file:
peer_io_handler	src/peers.c	/^static void peer_io_handler(struct stream_interface *si)$/;"	f	file:
peer_prepare_datamsg	src/peers.c	/^static int peer_prepare_datamsg(struct stksess *ts, struct peer_session *ps, char *msg, size_t size)$/;"	f	file:
peer_session	include/types/peers.h	/^struct peer_session {$/;"	s
peer_session_create	src/peers.c	/^static struct session *peer_session_create(struct peer *peer, struct peer_session *ps)$/;"	f	file:
peer_session_forceshutdown	src/peers.c	/^static void peer_session_forceshutdown(struct session * session)$/;"	f	file:
peer_session_release	src/peers.c	/^static void peer_session_release(struct stream_interface *si)$/;"	f	file:
peers	include/types/peers.h	/^	struct peers *peers;$/;"	m	struct:peer	typeref:struct:peer::peers
peers	include/types/peers.h	/^struct peers {$/;"	s
peers	include/types/stick_table.h	/^	} peers;$/;"	m	struct:stktable	typeref:union:stktable::__anon29
peers	include/types/stream_interface.h	/^		} peers;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon49
peers	src/peers.c	/^struct peers *peers = NULL;$/;"	v	typeref:struct:peers
peers_fe	include/types/peers.h	/^	struct proxy *peers_fe;		 \/* peer frontend *\/$/;"	m	struct:peers	typeref:struct:peers::proxy
peers_register_table	src/peers.c	/^void peers_register_table(struct peers *peers, struct stktable *table)$/;"	f
pend_pos	include/types/session.h	/^	struct pendconn *pend_pos;		\/* if not NULL, points to the position in the pending queue *\/$/;"	m	struct:session	typeref:struct:session::pendconn
pendconn	include/types/queue.h	/^struct pendconn {$/;"	s
pendconn_add	src/queue.c	/^struct pendconn *pendconn_add(struct session *sess)$/;"	f
pendconn_free	src/queue.c	/^void pendconn_free(struct pendconn *p)$/;"	f
pendconn_from_px	include/proto/queue.h	/^static inline struct pendconn *pendconn_from_px(const struct proxy *px) {$/;"	f
pendconn_from_srv	include/proto/queue.h	/^static inline struct pendconn *pendconn_from_srv(const struct server *s) {$/;"	f
pendconn_get_next_sess	src/queue.c	/^struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px)$/;"	f
pendconn_grab_from_px	src/queue.c	/^int pendconn_grab_from_px(struct server *s)$/;"	f
pendconn_redistribute	src/queue.c	/^int pendconn_redistribute(struct server *s)$/;"	f
pendconns	include/types/proxy.h	/^	struct list pendconns;			\/* pending connections with no server assigned yet *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
pendconns	include/types/server.h	/^	struct list pendconns;			\/* pending connections *\/$/;"	m	struct:server	typeref:struct:server::list
persist_rule	include/types/proxy.h	/^struct persist_rule {$/;"	s
persist_rules	include/types/proxy.h	/^	struct list persist_rules;		\/* 'force-persist' and 'ignore-persist' rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
pfx	ebtree/ebtree.h	/^	short unsigned int pfx; \/* data prefix length, always related to leaf *\/$/;"	m	struct:eb_node
pid	src/haproxy.c	/^int  pid;			\/* current process id *\/$/;"	v
pid_file	src/haproxy-systemd-wrapper.c	/^static char *pid_file = "\/run\/haproxy.pid";$/;"	v	file:
pidfile	include/types/global.h	/^	char *pidfile;$/;"	m	struct:global
pipe	include/types/channel.h	/^	struct pipe *pipe;		\/* non-NULL only when data present *\/$/;"	m	struct:channel	typeref:struct:channel::pipe
pipe	include/types/pipe.h	/^struct pipe {$/;"	s
pipes_free	src/pipe.c	/^int pipes_free = 0;             \/* # of pipes unused *\/$/;"	v
pipes_live	src/pipe.c	/^struct pipe *pipes_live = NULL; \/* pipes which are still ready to use *\/$/;"	v	typeref:struct:pipe
pipes_used	src/pipe.c	/^int pipes_used = 0;             \/* # of pipes in use (2 fds each) *\/$/;"	v
pipesize	include/types/global.h	/^		int pipesize;      \/* pipe size in bytes, system defaults if zero *\/$/;"	m	struct:global::__anon95
pmatch	src/regex.c	/^regmatch_t pmatch[MAX_MATCH];  \/* rm_so, rm_eo for regular expressions *\/$/;"	v
pol	include/types/acl.h	/^	enum acl_cond_pol pol;      \/* polarity: ACL_COND_IF \/ ACL_COND_UNLESS *\/$/;"	m	struct:acl_cond	typeref:enum:acl_cond::acl_cond_pol
poll	include/types/fd.h	/^    	void REGPRM2   (*poll)(struct poller *p, int exp);   \/* the poller itself *\/$/;"	m	struct:poller
poll_events	src/ev_poll.c	/^static struct pollfd *poll_events = NULL;$/;"	v	typeref:struct:pollfd	file:
poller	include/types/fd.h	/^struct poller {$/;"	s
pollers	src/fd.c	/^struct poller pollers[MAX_POLLERS];$/;"	v	typeref:struct:poller
pool	include/types/capture.h	/^    struct pool_head *pool;		\/* pool of pre-allocated memory area of (len+1) bytes *\/$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::pool_head
pool	include/types/stick_table.h	/^	struct pool_head *pool;   \/* pool used to allocate sticky sessions *\/$/;"	m	struct:stktable	typeref:struct:stktable::pool_head
pool2_appsess	src/appsession.c	/^struct pool_head *pool2_appsess;$/;"	v	typeref:struct:pool_head
pool2_buffer	src/buffer.c	/^struct pool_head *pool2_buffer;$/;"	v	typeref:struct:pool_head
pool2_capture	src/proto_http.c	/^struct pool_head *pool2_capture = NULL;$/;"	v	typeref:struct:pool_head
pool2_channel	src/channel.c	/^struct pool_head *pool2_channel;$/;"	v	typeref:struct:pool_head
pool2_connection	src/connection.c	/^struct pool_head *pool2_connection;$/;"	v	typeref:struct:pool_head
pool2_hdr_idx	src/hdr_idx.c	/^struct pool_head *pool2_hdr_idx = NULL;$/;"	v	typeref:struct:pool_head
pool2_pendconn	src/queue.c	/^struct pool_head *pool2_pendconn;$/;"	v	typeref:struct:pool_head
pool2_pipe	src/pipe.c	/^struct pool_head *pool2_pipe = NULL;$/;"	v	typeref:struct:pool_head
pool2_requri	src/proto_http.c	/^struct pool_head *pool2_requri;$/;"	v	typeref:struct:pool_head
pool2_session	src/session.c	/^struct pool_head *pool2_session;$/;"	v	typeref:struct:pool_head
pool2_sig_handlers	src/signal.c	/^struct pool_head *pool2_sig_handlers = NULL;$/;"	v	typeref:struct:pool_head
pool2_task	src/task.c	/^struct pool_head *pool2_task;$/;"	v	typeref:struct:pool_head
pool2_uniqueid	src/proto_http.c	/^struct pool_head *pool2_uniqueid;$/;"	v	typeref:struct:pool_head
pool_alloc	include/common/memory.h	69;"	d
pool_alloc	include/common/memory.h	95;"	d
pool_alloc	tests/test_pools.c	84;"	d	file:
pool_alloc2	include/common/memory.h	174;"	d
pool_alloc_from	include/common/memory.h	35;"	d
pool_alloc_from	tests/test_pools.c	52;"	d	file:
pool_comp_ctx	src/compression.c	/^static struct pool_head *pool_comp_ctx = NULL;$/;"	v	typeref:struct:pool_head	file:
pool_destroy	include/common/memory.h	/^static inline void pool_destroy(void **pool)$/;"	f
pool_destroy	tests/test_pools.c	/^static inline void pool_destroy(void **pool)$/;"	f	file:
pool_destroy2	src/memory.c	/^void *pool_destroy2(struct pool_head *pool)$/;"	f
pool_flush2	src/memory.c	/^void pool_flush2(struct pool_head *pool)$/;"	f
pool_free	include/common/memory.h	88;"	d
pool_free	include/common/memory.h	96;"	d
pool_free	tests/test_pools.c	103;"	d	file:
pool_free2	include/common/memory.h	195;"	d
pool_free_to	include/common/memory.h	55;"	d
pool_free_to	tests/test_pools.c	72;"	d	file:
pool_gc2	src/memory.c	/^void pool_gc2()$/;"	f
pool_head	include/common/memory.h	/^struct pool_head {$/;"	s
pool_refill_alloc	src/memory.c	/^void *pool_refill_alloc(struct pool_head *pool)$/;"	f
pools	src/memory.c	/^static struct list pools = LIST_HEAD_INIT(pools);$/;"	v	typeref:struct:list	file:
popcount	include/common/standard.h	/^static inline unsigned int popcount(unsigned long a)$/;"	f
port	include/types/checks.h	/^	unsigned short port;			\/* the port to use for the health checks *\/$/;"	m	struct:check
port	include/types/checks.h	/^	unsigned short port;                    \/* port to connect to *\/$/;"	m	struct:tcpcheck_rule
port_range	include/types/fd.h	/^	struct port_range *port_range;       \/* optional port range to bind to *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::port_range
port_range	include/types/port_range.h	/^struct port_range {$/;"	s
port_range_alloc_port	include/proto/port_range.h	/^static inline int port_range_alloc_port(struct port_range *range)$/;"	f
port_range_alloc_range	include/proto/port_range.h	/^static inline struct port_range *port_range_alloc_range(int n)$/;"	f
port_range_release_port	include/proto/port_range.h	/^static inline void port_range_release_port(struct port_range *range, int port)$/;"	f
port_to_str	src/standard.c	/^int port_to_str(struct sockaddr_storage *addr, char *str, int size)$/;"	f
ports	include/types/port_range.h	/^	uint16_t ports[0];		\/* array of <size> ports, in host byte order *\/$/;"	m	struct:port_range
pos	include/types/proxy.h	/^	unsigned int pos;		\/* position of the first invalid character *\/$/;"	m	struct:error_snapshot
pos	include/types/stream_interface.h	/^			int pos;		\/* last position of the current session's buffer *\/$/;"	m	struct:appctx::__anon43::__anon45
pp_opts	include/types/server.h	/^	int pp_opts;				\/* proxy protocol options (SRV_PP_*) *\/$/;"	m	struct:server
pr_mode	include/types/proxy.h	/^enum pr_mode {$/;"	g
pr_state	include/types/proxy.h	/^enum pr_state {$/;"	g
pref	include/types/fd.h	/^	int    pref;                                         \/* try pollers with higher preference first *\/$/;"	m	struct:poller
prefix	include/types/global.h	/^		char *prefix;           \/* path prefix of unix bind socket *\/$/;"	m	struct:global::__anon96
preg	include/common/regex.h	/^    struct my_regex *preg;		\/* expression to look for *\/$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::my_regex
prepare_addrsource	src/log.c	/^int prepare_addrsource(struct logformat_node *node, struct proxy *curproxy)$/;"	f
prepare_mini_sess_log_prefix	src/session.c	/^static void prepare_mini_sess_log_prefix(struct session *s)$/;"	f	file:
prev	include/types/proto_http.h	/^	int  prev; \/* index of previous header *\/$/;"	m	struct:hdr_ctx
prev_admin	include/types/server.h	/^	enum srv_admin admin, prev_admin;       \/* server maintenance status : SRV_ADMF_* *\/$/;"	m	struct:server	typeref:enum:server::
prev_ctr	include/types/freq_ctr.h	/^	unsigned int prev_ctr;  \/* value for last period *\/$/;"	m	struct:freq_ctr_period
prev_ctr	include/types/freq_ctr.h	/^	unsigned int prev_ctr; \/* value for last period *\/$/;"	m	struct:freq_ctr
prev_eweight	include/types/server.h	/^	unsigned prev_eweight;			\/* eweight before last change *\/$/;"	m	struct:server
prev_state	include/types/server.h	/^	enum srv_state state, prev_state;       \/* server state among SRV_ST_* *\/$/;"	m	struct:server	typeref:enum:server::
prev_state	include/types/stream_interface.h	/^	enum si_state prev_state;\/* SI_ST*, copy of previous state *\/$/;"	m	struct:stream_interface	typeref:enum:stream_interface::si_state
printUsage	examples/stats_haproxy.sh	/^printUsage ()$/;"	f
process	include/types/sample.h	/^	int (*process)(const struct arg *arg_p,$/;"	m	struct:sample_conv
process	include/types/sample.h	/^	int (*process)(struct proxy *px,$/;"	m	struct:sample_fetch
process	include/types/task.h	/^	struct task * (*process)(struct task *t);  \/* the function which processes the task *\/$/;"	m	struct:task	typeref:struct:task::process
process_chk	src/checks.c	/^static struct task *process_chk(struct task *t)$/;"	f	file:
process_peer_sync	src/peers.c	/^static struct task *process_peer_sync(struct task * task)$/;"	f	file:
process_request	examples/check	/^sub process_request$/;"	s
process_runnable_tasks	src/task.c	/^void process_runnable_tasks(int *next)$/;"	f
process_server_rules	src/session.c	/^static int process_server_rules(struct session *s, struct channel *req, int an_bit)$/;"	f	file:
process_session	src/session.c	/^struct task *process_session(struct task *t)$/;"	f
process_srv_queue	src/queue.c	/^void process_srv_queue(struct server *s)$/;"	f
process_sticking_rules	src/session.c	/^static int process_sticking_rules(struct session *s, struct channel *req, int an_bit)$/;"	f	file:
process_store_rules	src/session.c	/^static int process_store_rules(struct session *s, struct channel *rep, int an_bit)$/;"	f	file:
process_switching_rules	src/session.c	/^static int process_switching_rules(struct session *s, struct channel *req, int an_bit)$/;"	f	file:
process_table_expire	src/stick_table.c	/^static struct task *process_table_expire(struct task *task)$/;"	f	file:
prod	include/types/channel.h	/^	struct stream_interface *prod;  \/* producer attached to this channel *\/$/;"	m	struct:channel	typeref:struct:channel::stream_interface
prod	include/types/pipe.h	/^	int prod;	\/* FD the producer must write to ; -1 if none *\/$/;"	m	struct:pipe
proto	include/types/listener.h	/^	struct protocol *proto;		\/* protocol this listener belongs to *\/$/;"	m	struct:listener	typeref:struct:listener::protocol
proto	include/types/peers.h	/^	struct protocol *proto;	       \/* peer address protocol *\/$/;"	m	struct:peer	typeref:struct:peer::protocol
proto	include/types/server.h	/^		struct protocol *proto;	        \/* server address protocol for health checks *\/$/;"	m	struct:server::__anon98	typeref:struct:server::__anon98::protocol
proto	include/types/server.h	/^	struct protocol *proto;	                \/* server address protocol *\/$/;"	m	struct:server	typeref:struct:server::protocol
proto_list	include/types/listener.h	/^	struct list proto_list;         \/* list in the protocol header *\/$/;"	m	struct:listener	typeref:struct:listener::list
proto_tcpv4	src/proto_tcp.c	/^static struct protocol proto_tcpv4 = {$/;"	v	typeref:struct:protocol	file:
proto_tcpv6	src/proto_tcp.c	/^static struct protocol proto_tcpv6 = {$/;"	v	typeref:struct:protocol	file:
proto_unix	src/proto_uxst.c	/^static struct protocol proto_unix = {$/;"	v	typeref:struct:protocol	file:
protocol	include/types/protocol.h	/^struct protocol {$/;"	s
protocol_bind_all	src/protocol.c	/^int protocol_bind_all(char *errmsg, int errlen)$/;"	f
protocol_by_family	src/protocol.c	/^struct protocol *protocol_by_family(int family)$/;"	f
protocol_disable_all	src/protocol.c	/^int protocol_disable_all(void)$/;"	f
protocol_enable_all	src/protocol.c	/^int protocol_enable_all(void)$/;"	f
protocol_register	src/protocol.c	/^void protocol_register(struct protocol *proto)$/;"	f
protocol_unbind_all	src/protocol.c	/^int protocol_unbind_all(void)$/;"	f
protocol_unregister	src/protocol.c	/^void protocol_unregister(struct protocol *proto)$/;"	f
protocols	src/protocol.c	/^static struct list protocols = LIST_HEAD_INIT(protocols);$/;"	v	typeref:struct:list	file:
proxy	include/types/proxy.h	/^struct proxy {$/;"	s
proxy	include/types/server.h	/^	struct proxy *proxy;			\/* the proxy this server belongs to *\/$/;"	m	struct:server	typeref:struct:server::proxy
proxy	include/types/stream_interface.h	/^			struct proxy *proxy;	\/* table being currently dumped (first if NULL) *\/$/;"	m	struct:appctx::__anon43::__anon47	typeref:struct:appctx::__anon43::__anon47::proxy
proxy	src/proxy.c	/^struct proxy *proxy  = NULL;	\/* list of all existing proxies *\/$/;"	v	typeref:struct:proxy
proxy_by_name	src/proxy.c	/^struct eb_root proxy_by_name = EB_ROOT; \/* tree of proxies sorted by name *\/$/;"	v	typeref:struct:eb_root
proxy_cap_str	src/proxy.c	/^const char *proxy_cap_str(int cap)$/;"	f
proxy_cfg_ensure_no_http	src/proxy.c	/^int proxy_cfg_ensure_no_http(struct proxy *curproxy)$/;"	f
proxy_hdr_v2	include/types/connection.h	/^struct proxy_hdr_v2 {$/;"	s
proxy_inc_be_ctr	include/proto/proxy.h	/^static void inline proxy_inc_be_ctr(struct proxy *be)$/;"	f
proxy_inc_fe_conn_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_conn_ctr(struct listener *l, struct proxy *fe)$/;"	f
proxy_inc_fe_req_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_req_ctr(struct proxy *fe)$/;"	f
proxy_inc_fe_sess_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_sess_ctr(struct listener *l, struct proxy *fe)$/;"	f
proxy_mode_str	src/proxy.c	/^const char *proxy_mode_str(int mode) {$/;"	f
proxy_parse_max_ka_queue	src/proxy.c	/^static int proxy_parse_max_ka_queue(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_parse_rate_limit	src/proxy.c	/^static int proxy_parse_rate_limit(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_parse_timeout	src/proxy.c	/^static int proxy_parse_timeout(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_reset_timeouts	include/proto/proxy.h	/^static inline void proxy_reset_timeouts(struct proxy *proxy)$/;"	f
proxy_store_name	src/proxy.c	/^void proxy_store_name(struct proxy *px)$/;"	f
proxy_type_str	include/proto/proxy.h	/^static inline const char *proxy_type_str(struct proxy *proxy)$/;"	f
prune	include/types/acl.h	/^	void (*prune)(struct pattern_expr *expr);$/;"	m	struct:acl_keyword
prune	include/types/pattern.h	/^	void (*prune)(struct pattern_expr *);$/;"	m	struct:pattern_head
prune_acl	src/acl.c	/^struct acl *prune_acl(struct acl *acl) {$/;"	f
prune_acl_cond	src/acl.c	/^struct acl_cond *prune_acl_cond(struct acl_cond *cond)$/;"	f
prune_acl_expr	src/acl.c	/^static struct acl_expr *prune_acl_expr(struct acl_expr *expr)$/;"	f	file:
prx	include/types/arg.h	/^	struct proxy *prx; \/* used for fe, be, tables *\/$/;"	m	union:arg_data	typeref:struct:arg_data::proxy
prx_queue_size	include/types/session.h	/^		unsigned long prx_queue_size;	\/* overall number of sessions waiting for a connect slot on this instance at accept() time *\/$/;"	m	struct:session::__anon55
ptr	include/common/epoll.h	/^		void *ptr;$/;"	m	union:epoll_event::__anon104
ptr	include/types/pattern.h	/^		void *ptr;              \/* any data *\/$/;"	m	union:pattern::__anon14
ptr	include/types/pattern.h	/^	} ptr;                          \/* indirect values, allocated *\/$/;"	m	struct:pattern	typeref:union:pattern::__anon14
ptr	include/types/proxy.h	/^		struct server *ptr;		\/* target server *\/$/;"	m	union:server_rule::__anon21	typeref:struct:server_rule::__anon21::server
ptr	include/types/stream_interface.h	/^			int ptr;		\/* <0: headers, >=0 : text pointer to restart from *\/$/;"	m	struct:appctx::__anon43::__anon46
ptr	include/types/stream_interface.h	/^			void *ptr;              \/* multi-purpose pointer for peers *\/$/;"	m	struct:appctx::__anon43::__anon49
ptr_t	ebtree/ebpttree.h	/^typedef PTR_INT_TYPE ptr_t;$/;"	t
puid	include/types/server.h	/^	int puid;				\/* proxy-unique server ID, used for SNMP, and "first" LB algo *\/$/;"	m	struct:server
pushack	include/types/peers.h	/^	unsigned int pushack;	      \/* last commited update to ack *\/$/;"	m	struct:peer_session
pushed	include/types/peers.h	/^	unsigned int pushed;	      \/* equal to last pushed data or to table local update in case of total push$/;"	m	struct:peer_session
put	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
put_pipe	src/pipe.c	/^void put_pipe(struct pipe *p)$/;"	f
put_srv	tests/filltab25.c	/^void put_srv(struct srv *s) {$/;"	f
px	include/types/stream_interface.h	/^			struct proxy *px;	\/* current proxy being dumped, NULL = not started yet. *\/$/;"	m	struct:appctx::__anon43::__anon46	typeref:struct:appctx::__anon43::__anon46::proxy
px	include/types/stream_interface.h	/^			struct proxy *px;$/;"	m	struct:appctx::__anon43::__anon44	typeref:struct:appctx::__anon43::__anon44::proxy
px_id	include/common/uri_auth.h	/^	char *px_id;			\/* proxy id *\/$/;"	m	struct:stat_scope
px_len	include/common/uri_auth.h	/^	int px_len;			\/* proxy name length *\/$/;"	m	struct:stat_scope
px_st	include/types/stream_interface.h	/^			int px_st;		\/* STAT_PX_ST* *\/$/;"	m	struct:appctx::__anon43::__anon44
pxcounters	include/types/counters.h	/^struct pxcounters {$/;"	s
q_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
q_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
qfprintf	src/log.c	/^void qfprintf(FILE *out, const char *fmt, ...)$/;"	f
qstr	src/standard.c	/^const char *qstr(const char *str)$/;"	f
quantify	contrib/halog/halog.c	/^static inline int quantify(int i, int bits)$/;"	f	file:
quantify_u32	contrib/halog/halog.c	/^static inline unsigned int quantify_u32(unsigned int i, int bits)$/;"	f	file:
queue	include/types/proxy.h	/^		int queue;                      \/* queue timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon18
queue_by_weight	tests/filltab25.c	/^void queue_by_weight(struct eb_root *root, struct srv *s) {$/;"	f
queue_by_weight_0	tests/filltab25.c	/^void queue_by_weight_0(struct eb_root *root, struct srv *s) {$/;"	f
quote_arg	src/standard.c	/^const char *quote_arg(const char *ptr)$/;"	f
quoted_idx	src/standard.c	/^int quoted_idx = 0;$/;"	v
quoted_str	src/standard.c	/^char quoted_str[NB_QSTR][QSTR_SIZE + 1];$/;"	v
r	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon64::__anon66
r_l	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon64::__anon66
range	include/types/pattern.h	/^		} range; \/* integer range *\/$/;"	m	union:pattern::__anon10	typeref:struct:pattern::__anon10::__anon11
raw_sock	src/raw_sock.c	/^struct xprt_ops raw_sock = {$/;"	v	typeref:struct:xprt_ops
raw_sock_from_buf	src/raw_sock.c	/^static int raw_sock_from_buf(struct connection *conn, struct buffer *buf, int flags)$/;"	f	file:
raw_sock_from_pipe	src/raw_sock.c	/^int raw_sock_from_pipe(struct connection *conn, struct pipe *pipe)$/;"	f
raw_sock_to_buf	src/raw_sock.c	/^static int raw_sock_to_buf(struct connection *conn, struct buffer *buf, int count)$/;"	f	file:
raw_sock_to_pipe	src/raw_sock.c	/^int raw_sock_to_pipe(struct connection *conn, struct pipe *pipe, unsigned int count)$/;"	f
rb_color	include/common/rbtree.h	/^	int rb_color;$/;"	m	struct:rb_node
rb_entry	include/common/rbtree.h	125;"	d
rb_erase	src/rbtree.c	/^void rb_erase(struct rb_node *node, struct rb_root *root)$/;"	f
rb_first	src/rbtree.c	/^struct rb_node *rb_first(struct rb_root *root)$/;"	f
rb_insert_color	src/rbtree.c	/^void rb_insert_color(struct rb_node *node, struct rb_root *root)$/;"	f
rb_last	src/rbtree.c	/^struct rb_node *rb_last(struct rb_root *root)$/;"	f
rb_left	include/common/rbtree.h	/^	struct rb_node *rb_left;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_link_node	include/common/rbtree.h	/^static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,$/;"	f
rb_next	src/rbtree.c	/^struct rb_node *rb_next(struct rb_node *node)$/;"	f
rb_node	include/common/rbtree.h	/^	struct rb_node *rb_node;$/;"	m	struct:rb_root	typeref:struct:rb_root::rb_node
rb_node	include/common/rbtree.h	/^struct rb_node$/;"	s
rb_parent	include/common/rbtree.h	/^	struct rb_node *rb_parent;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_prev	src/rbtree.c	/^struct rb_node *rb_prev(struct rb_node *node)$/;"	f
rb_replace_node	src/rbtree.c	/^void rb_replace_node(struct rb_node *victim, struct rb_node *new,$/;"	f
rb_right	include/common/rbtree.h	/^	struct rb_node *rb_right;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_root	include/common/rbtree.h	/^struct rb_root$/;"	s
rcv_buf	include/types/connection.h	/^	int  (*rcv_buf)(struct connection *conn, struct buffer *buf, int count); \/* recv callback *\/$/;"	m	struct:xprt_ops
rcv_pipe	include/types/connection.h	/^	int  (*rcv_pipe)(struct connection *conn, struct pipe *pipe, unsigned int count); \/* recv-to-pipe callback *\/$/;"	m	struct:xprt_ops
rdp_cookie_len	include/types/proxy.h	/^	int  rdp_cookie_len;			\/* strlen(rdp_cookie_name), computed only once *\/$/;"	m	struct:proxy
rdp_cookie_name	include/types/proxy.h	/^	char *rdp_cookie_name;			\/* name of the RDP cookie to look for *\/$/;"	m	struct:proxy
rdr_fmt	include/types/proxy.h	/^	struct list rdr_fmt;$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list
rdr_len	include/types/proxy.h	/^	int rdr_len;$/;"	m	struct:redirect_rule
rdr_len	include/types/server.h	/^	int rdr_len;				\/* the length of the redirection prefix *\/$/;"	m	struct:server
rdr_pfx	include/types/server.h	/^	char *rdr_pfx;				\/* the redirection prefix *\/$/;"	m	struct:server
rdr_str	include/types/proxy.h	/^	char *rdr_str;$/;"	m	struct:redirect_rule
rdtsc	src/trace.c	/^static inline unsigned long long rdtsc()$/;"	f	file:
re	include/types/proto_http.h	/^			struct my_regex re;    \/* used by replace-header and replace-value *\/$/;"	m	struct:http_req_rule::__anon67::__anon69	typeref:struct:http_req_rule::__anon67::__anon69::my_regex
re	include/types/proto_http.h	/^			struct my_regex re;    \/* used by replace-header and replace-value *\/$/;"	m	struct:http_res_rule::__anon71::__anon72	typeref:struct:http_res_rule::__anon71::__anon72::my_regex
read_freq_ctr	src/freq_ctr.c	/^unsigned int read_freq_ctr(struct freq_ctr *ctr)$/;"	f
read_freq_ctr_period	src/freq_ctr.c	/^unsigned int read_freq_ctr_period(struct freq_ctr_period *ctr, unsigned int period)$/;"	f
read_pids	src/haproxy-systemd-wrapper.c	/^static int read_pids(char ***pid_strv)$/;"	f	file:
read_uint	src/standard.c	/^unsigned int read_uint(const char **s, const char *end)$/;"	f
readcfgfile	src/cfgparse.c	/^int readcfgfile(const char *file)$/;"	f
realm	include/types/proto_http.h	/^			char *realm;$/;"	m	struct:http_req_rule::__anon67::__anon68
recalc_server_map	src/lb_map.c	/^void recalc_server_map(struct proxy *px)$/;"	f
reconnect	include/types/peers.h	/^	unsigned int reconnect;	      \/* next connect timer *\/$/;"	m	struct:peer_session
recount_servers	src/backend.c	/^void recount_servers(struct proxy *px)$/;"	f
recv	include/types/connection.h	/^	void (*recv)(struct connection *conn);  \/* data-layer recv callback *\/$/;"	m	struct:data_cb
recv_enough	include/types/global.h	/^		int recv_enough;   \/* how many input bytes at once are "enough" *\/$/;"	m	struct:global::__anon95
redir	include/types/proto_http.h	/^		struct redirect_rule *redir;   \/* redirect rule or "http-request redirect" *\/$/;"	m	union:http_req_rule::__anon67	typeref:struct:http_req_rule::__anon67::redirect_rule
redirect_rule	include/types/proxy.h	/^struct redirect_rule {$/;"	s
redirect_rules	include/types/proxy.h	/^	struct list redirect_rules;             \/* content redirecting rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
redispatches	include/types/counters.h	/^	long long redispatches;                 \/* retried and redispatched connections (BE only) *\/$/;"	m	struct:pxcounters
redispatches	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters
ref	include/common/mini-clist.h	/^	struct list *ref; \/* pointer to the target's list entry *\/$/;"	m	struct:bref	typeref:struct:bref::list
ref	include/types/pattern.h	/^	struct pat_ref *ref; \/* The pattern reference if exists. *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::pat_ref
ref	include/types/pattern.h	/^	struct pat_ref_elt *ref;$/;"	m	struct:pattern	typeref:struct:pattern::pat_ref_elt
ref	include/types/pattern.h	/^	struct pat_ref_elt *ref;$/;"	m	struct:pattern_tree	typeref:struct:pattern_tree::pat_ref_elt
ref	include/types/proto_http.h	/^			char *ref;             \/* MAP or ACL file name to update *\/$/;"	m	struct:http_req_rule::__anon67::__anon70
ref	include/types/proto_http.h	/^			char *ref;             \/* MAP or ACL file name to update *\/$/;"	m	struct:http_res_rule::__anon71::__anon73
ref	include/types/stream_interface.h	/^			struct pat_ref *ref;$/;"	m	struct:appctx::__anon43::__anon50	typeref:struct:appctx::__anon43::__anon50::pat_ref
ref_cnt	include/types/stick_table.h	/^	unsigned int ref_cnt;     \/* reference count, can only purge when zero *\/$/;"	m	struct:stksess
reference	include/types/pattern.h	/^	char *reference; \/* The reference name. *\/$/;"	m	struct:pat_ref
refresh	include/common/uri_auth.h	/^	int refresh;			\/* refresh interval for the browser (in seconds) *\/$/;"	m	struct:uri_auth
reg	include/common/regex.h	/^	pcre *reg;$/;"	m	struct:my_regex
reg	include/types/pattern.h	/^		struct my_regex *reg;   \/* a compiled regex *\/$/;"	m	union:pattern::__anon14	typeref:struct:pattern::__anon14::my_regex
regex	examples/check	/^sub regex$/;"	s
regex_comp	src/regex.c	/^int regex_comp(const char *str, struct my_regex *regex, int cs, int cap, char **err)$/;"	f
regex_exec	include/common/regex.h	/^static inline int regex_exec(const struct my_regex *preg, char *subject) {$/;"	f
regex_exec2	include/common/regex.h	/^static inline int regex_exec2(const struct my_regex *preg, char *subject, int length) {$/;"	f
regex_exec_match	src/regex.c	/^int regex_exec_match(const struct my_regex *preg, const char *subject,$/;"	f
regex_exec_match2	src/regex.c	/^int regex_exec_match2(const struct my_regex *preg, char *subject, int length,$/;"	f
regex_free	include/common/regex.h	/^static inline void regex_free(struct my_regex *preg) {$/;"	f
relative_pid	src/haproxy.c	/^int  relative_pid = 1;		\/* process id starting at 1 *\/$/;"	v
relax	src/shctx.c	/^static inline void relax()$/;"	f	file:
release	include/types/stream_interface.h	/^	void (*release)(struct stream_interface *);  \/* callback to release resources, may be NULL *\/$/;"	m	struct:si_applet
rem	tests/filltab25.c	/^	int rem;$/;"	m	struct:srv	file:
remote	include/types/peers.h	/^	struct peer *remote;		 \/* remote peers list *\/$/;"	m	struct:peers	typeref:struct:peers::peer
rep	include/types/session.h	/^	struct channel *rep;			\/* response buffer *\/$/;"	m	struct:session	typeref:struct:session::channel
replace	include/common/regex.h	/^    const char *replace;		\/* expression to set instead *\/$/;"	m	struct:hdr_exp
replace_by	src/log.c	/^	const char *replace_by; \/* new option to use instead of old one *\/$/;"	m	struct:logformat_type	file:
req	include/types/proto_http.h	/^	struct http_msg req;            \/* HTTP request message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg
req	include/types/session.h	/^	struct channel *req;			\/* request buffer *\/$/;"	m	struct:session	typeref:struct:session::channel
req_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
req_cap	include/types/proxy.h	/^	struct cap_hdr *req_cap;		\/* chained list of request headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr
req_cap_pool	include/types/proxy.h	/^	struct pool_head *req_cap_pool,		\/* pools of pre-allocated char ** used to build the sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head
req_count	include/types/global.h	/^	unsigned int req_count; \/* request counter (HTTP or TCP session) for logs and unique_id *\/$/;"	m	struct:global
req_exp	include/types/proxy.h	/^	struct hdr_exp *req_exp;		\/* regular expressions for request headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp
request_count	include/common/appsession.h	/^	unsigned long int request_count;$/;"	m	struct:appsessions
reset	include/types/compression.h	/^	int (*reset)(struct comp_ctx *comp_ctx);$/;"	m	struct:comp_algo
response	src/ssl_sock.c	/^	struct chunk response;$/;"	m	struct:certificate_ocsp	typeref:struct:certificate_ocsp::chunk	file:
result	include/types/checks.h	/^	enum chk_result result;                 \/* health-check result : CHK_RES_* *\/$/;"	m	struct:check	typeref:enum:check::chk_result
result	include/types/checks.h	/^	short result;			\/* one of SRV_CHK_* *\/$/;"	m	struct:check_status
resume_listener	src/listener.c	/^int resume_listener(struct listener *l)$/;"	f
resume_proxies	src/proxy.c	/^void resume_proxies(void)$/;"	f
resume_proxy	src/proxy.c	/^int resume_proxy(struct proxy *p)$/;"	f
resync_timeout	include/types/peers.h	/^	unsigned int resync_timeout;	    \/* resync timeout timer *\/$/;"	m	struct:shared_table
retries	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters
retries	include/types/counters.h	/^	long long retries;                      \/* retried and redispatched connections (BE only) *\/$/;"	m	struct:pxcounters
retrieve_errno_from_socket	src/checks.c	/^static int retrieve_errno_from_socket(struct connection *conn)$/;"	f	file:
reused_sess	include/types/server.h	/^		SSL_SESSION *reused_sess;$/;"	m	struct:server::__anon99
rev32	tests/uri_hash.c	/^static unsigned int rev32(unsigned int c) {$/;"	f	file:
rex	include/types/channel.h	/^	int rex;                        \/* expiration date for a read, in ticks *\/$/;"	m	struct:channel
rfc4291_pfx	src/standard.c	/^const char rfc4291_pfx[] = { 0x00, 0x00, 0x00, 0x00,$/;"	v
rise	include/types/checks.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:check
rlimit_memmax	include/types/global.h	/^	int rlimit_memmax;	\/* default ulimit-d in megs value : 0=unset *\/$/;"	m	struct:global
rlimit_nofile	include/types/global.h	/^	int rlimit_nofile;	\/* default ulimit-n value : 0=unset *\/$/;"	m	struct:global
rot	tests/test_hashes.c	308;"	d	file:
rotate_freq_ctr	include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr(struct freq_ctr *ctr)$/;"	f
rotate_freq_ctr_period	include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr_period(struct freq_ctr_period *ctr,$/;"	f
rps_max	include/types/counters.h	/^			unsigned int rps_max;   \/* maximum of new HTTP requests second observed *\/$/;"	m	struct:pxcounters::__anon3::__anon4
rq	include/types/proto_http.h	/^		} rq;                          \/* request line : field, length *\/$/;"	m	union:http_msg::__anon64	typeref:struct:http_msg::__anon64::__anon65
rq	include/types/task.h	/^	struct eb32_node rq;		\/* ebtree node used to hold the task in the run queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node
rqueue	src/task.c	/^static struct eb_root rqueue;      \/* tree constituting the run queue *\/$/;"	v	typeref:struct:eb_root	file:
rqueue_ticks	src/task.c	/^static unsigned int rqueue_ticks;  \/* insertion count *\/$/;"	v	file:
rr_idx	include/types/lb_map.h	/^	int rr_idx;		\/* next server to be elected in round robin mode *\/$/;"	m	struct:lb_map
rsp	include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:srvcounters::__anon5::__anon6
rsp	include/types/counters.h	/^			long long rsp[6];       \/* http response codes *\/$/;"	m	struct:pxcounters::__anon3::__anon4
rsp	include/types/proto_http.h	/^	struct http_msg rsp;            \/* HTTP response message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg
rsp_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::
rsp_cap	include/types/proxy.h	/^	struct cap_hdr *rsp_cap;		\/* chained list of response headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr
rsp_cap_pool	include/types/proxy.h	/^	                 *rsp_cap_pool;$/;"	m	struct:proxy	typeref:struct:proxy::
rsp_exp	include/types/proxy.h	/^	struct hdr_exp *rsp_exp;		\/* regular expressions for response headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp
rto	include/types/channel.h	/^	int rto;                        \/* read timeout, in ticks *\/$/;"	m	struct:channel
rtrim	include/common/standard.h	/^static inline char *rtrim(char *s, char c) {$/;"	f
rule_result	include/types/proto_http.h	/^enum rule_result {$/;"	g
run_poll_loop	src/haproxy.c	/^void run_poll_loop()$/;"	f
run_queue	src/task.c	/^unsigned int run_queue = 0;$/;"	v
run_queue_cur	src/task.c	/^unsigned int run_queue_cur = 0;    \/* copy of the run queue size *\/$/;"	v
run_test	tests/test_hashes.c	510;"	d	file:
rweight	include/types/server.h	/^	unsigned rweight;			\/* remainer of weight in the current LB tree *\/$/;"	m	struct:server
s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:cond_wordlist
s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:wordlist
s30tob64	src/base64.c	/^const char *s30tob64(int in, char *out)$/;"	f
s32	ebtree/eb32tree.h	/^typedef   signed int s32;$/;"	t
s64	ebtree/eb64tree.h	/^typedef   signed long long s64;$/;"	t
s_flags	include/types/proxy.h	/^	unsigned int s_flags;		\/* session flags *\/$/;"	m	struct:error_snapshot
samp_time	src/time.c	/^unsigned int   samp_time;       \/* total elapsed time over current sample *\/$/;"	v
sample	include/types/pattern.h	/^	char *sample;$/;"	m	struct:pat_ref_elt
sample	include/types/sample.h	/^struct sample {$/;"	s
sample_cast_fct	include/types/sample.h	/^typedef int (*sample_cast_fct)(struct sample *smp);$/;"	t
sample_casts	src/sample.c	/^sample_cast_fct sample_casts[SMP_TYPES][SMP_TYPES] = {$/;"	v
sample_ckp_names	src/sample.c	/^const char *sample_ckp_names(unsigned int use)$/;"	f
sample_conv	include/types/sample.h	/^struct sample_conv {$/;"	s
sample_conv_bin2base64	src/sample.c	/^static int sample_conv_bin2base64(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_bin2hex	src/sample.c	/^static int sample_conv_bin2hex(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_expr	include/types/sample.h	/^struct sample_conv_expr {$/;"	s
sample_conv_http_date	src/proto_http.c	/^static int sample_conv_http_date(const struct arg *args, struct sample *smp)$/;"	f	file:
sample_conv_ipmask	src/sample.c	/^static int sample_conv_ipmask(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_kw_list	include/types/sample.h	/^struct sample_conv_kw_list {$/;"	s
sample_conv_kws	src/map.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_kws	src/proto_http.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_kws	src/sample.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_map	src/map.c	/^static int sample_conv_map(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_q_prefered	src/proto_http.c	/^static int sample_conv_q_prefered(const struct arg *args, struct sample *smp)$/;"	f	file:
sample_conv_str2lower	src/sample.c	/^static int sample_conv_str2lower(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_str2upper	src/sample.c	/^static int sample_conv_str2upper(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_convert	include/proto/sample.h	/^int sample_convert(struct sample *sample, int req_type)$/;"	f
sample_convs	src/sample.c	/^static struct sample_conv_kw_list sample_convs = {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_expr	include/types/sample.h	/^struct sample_expr {$/;"	s
sample_fetch	include/types/sample.h	/^struct sample_fetch {$/;"	s
sample_fetch_keywords	src/compression.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	src/proto_http.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	src/proto_tcp.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	src/ssl_sock.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_kw_list	include/types/sample.h	/^struct sample_fetch_kw_list {$/;"	s
sample_fetch_string	src/sample.c	/^struct sample *sample_fetch_string(struct proxy *px, struct session *l4, void *l7,$/;"	f
sample_fetches	src/sample.c	/^static struct sample_fetch_kw_list sample_fetches = {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_load_map	src/map.c	/^static int sample_load_map(struct arg *arg, struct sample_conv *conv,$/;"	f	file:
sample_parse_expr	src/sample.c	/^struct sample_expr *sample_parse_expr(char **str, int *idx, const char *file, int line, char **err_msg, struct arg_list *al)$/;"	f
sample_process	src/sample.c	/^struct sample *sample_process(struct proxy *px, struct session *l4, void *l7,$/;"	f
sample_register_convs	src/sample.c	/^void sample_register_convs(struct sample_conv_kw_list *pckl)$/;"	f
sample_register_fetches	src/sample.c	/^void sample_register_fetches(struct sample_fetch_kw_list *kwl)$/;"	f
sample_src_names	src/sample.c	/^const char *sample_src_names(unsigned int use)$/;"	f
sample_storage	include/types/sample.h	/^struct sample_storage {$/;"	s
sample_to_key	src/stick_table.c	/^static sample_to_key_fct sample_to_key[SMP_TYPES][STKTABLE_TYPES] = {$/;"	v	file:
sample_to_key_fct	src/stick_table.c	/^typedef void *(*sample_to_key_fct)(struct sample *smp, union stktable_key_data *kdata, size_t *len);$/;"	t	file:
sax_hash	tests/test_hashes.c	/^unsigned sax_hash ( void *key, int len )$/;"	f
scheme	include/common/standard.h	/^	enum http_scheme scheme;$/;"	m	struct:split_url	typeref:enum:split_url::http_scheme
scope	include/common/uri_auth.h	/^	struct stat_scope *scope;	\/* linked list of authorized proxies *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::stat_scope
scope	include/types/listener.h	/^	const char *scope;$/;"	m	struct:bind_kw_list
scope	include/types/proto_http.h	/^       const char *scope;$/;"	m	struct:http_req_action_kw_list
scope	include/types/proto_http.h	/^       const char *scope;$/;"	m	struct:http_res_action_kw_list
scope	include/types/server.h	/^	const char *scope;$/;"	m	struct:srv_kw_list
scope_len	include/types/stream_interface.h	/^			int scope_len;		\/* length of the string above in the buffer *\/$/;"	m	struct:appctx::__anon43::__anon44
scope_str	include/types/stream_interface.h	/^			int scope_str;		\/* limit scope to a frontend\/backend substring *\/$/;"	m	struct:appctx::__anon43::__anon44
section	include/common/cfgparse.h	/^	int section;                            \/* section type for this keyword *\/$/;"	m	struct:cfg_keyword
section	include/types/stream_interface.h	/^			int section;		\/* section of the session being dumped *\/$/;"	m	struct:appctx::__anon43::__anon45
section_name	src/cfgparse.c	/^	char *section_name;$/;"	m	struct:cfg_section	file:
section_parser	src/cfgparse.c	/^	int (*section_parser)(const char *, int, char **, int);$/;"	m	struct:cfg_section	file:
sections	src/cfgparse.c	/^struct list sections = LIST_HEAD_INIT(sections);$/;"	v	typeref:struct:list
select_compression_request_header	src/proto_http.c	/^int select_compression_request_header(struct session *s, struct buffer *req)$/;"	f
select_compression_response_header	src/proto_http.c	/^int select_compression_response_header(struct session *s, struct buffer *res)$/;"	f
send	include/types/connection.h	/^	void (*send)(struct connection *conn);  \/* data-layer send callback *\/$/;"	m	struct:data_cb
send_log	src/log.c	/^void send_log(struct proxy *p, int level, const char *format, ...)$/;"	f
send_proxy	include/types/checks.h	/^	int send_proxy;				\/* send a PROXY protocol header with checks *\/$/;"	m	struct:check
send_proxy_ofs	include/types/connection.h	/^	signed short send_proxy_ofs;  \/* <0 = offset to (re)send from the end, >0 = send all *\/$/;"	m	struct:connection
seq	src/shctx.c	/^	unsigned char seq:7;$/;"	m	struct:shsess_packet_hdr	file:
served	include/types/server.h	/^	int served;				\/* # of active sessions currently being served (ie not pending) *\/$/;"	m	struct:server
server	include/types/checks.h	/^	struct server *server;			\/* back-pointer to server *\/$/;"	m	struct:check	typeref:struct:check::server
server	include/types/proxy.h	/^		int server;                     \/* server I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon18
server	include/types/server.h	/^	struct server *server;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::server
server	include/types/server.h	/^struct server {$/;"	s
server_drop_conn	include/types/backend.h	/^	void (*server_drop_conn)(struct server *);       \/* to be called when connection is dropped *\/$/;"	m	struct:lbprm
server_has_room	include/proto/queue.h	/^static inline int server_has_room(const struct server *s) {$/;"	f
server_id	include/types/stick_table.h	/^	int server_id;$/;"	m	union:stktable_data
server_id_hdr_len	include/types/proxy.h	/^	int server_id_hdr_len;                      \/* the length of the id (name) header... name *\/$/;"	m	struct:proxy
server_id_hdr_name	include/types/proxy.h	/^	char *server_id_hdr_name;                   \/* the header to use to send the server id (name) *\/$/;"	m	struct:proxy
server_is_draining	include/proto/server.h	/^static inline int server_is_draining(const struct server *s)$/;"	f
server_parse_weight_change_request	src/server.c	/^const char *server_parse_weight_change_request(struct server *sv,$/;"	f
server_rcvbuf	include/types/global.h	/^		int server_rcvbuf; \/* set server rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon95
server_recalc_eweight	src/server.c	/^void server_recalc_eweight(struct server *sv)$/;"	f
server_rule	include/types/proxy.h	/^struct server_rule {$/;"	s
server_rules	include/types/proxy.h	/^	struct list server_rules;               \/* server switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
server_sndbuf	include/types/global.h	/^		int server_sndbuf; \/* set server sndbuf to this value if not null *\/$/;"	m	struct:global::__anon95
server_take_conn	include/types/backend.h	/^	void (*server_take_conn)(struct server *);       \/* to be called when connection is assigned *\/$/;"	m	struct:lbprm
server_throttle_rate	include/proto/server.h	/^static inline unsigned int server_throttle_rate(struct server *sv)$/;"	f
server_warmup	src/checks.c	/^static struct task *server_warmup(struct task *t)$/;"	f	file:
serverfin	include/types/proxy.h	/^		int serverfin;                  \/* timeout to apply to server half-closed connections *\/$/;"	m	struct:proxy::__anon18
serverid	include/common/appsession.h	/^	char *serverid;$/;"	m	struct:appsessions
serverid	include/common/appsession.h	/^	struct pool_head *serverid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head
sess	include/types/queue.h	/^	struct session *sess;		\/* the session waiting for a connection *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::session
sess	include/types/stream_interface.h	/^		} sess;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon45
sess_change_server	src/session.c	/^void sess_change_server(struct session *sess, struct server *newsrv)$/;"	f
sess_cnt	include/types/stick_table.h	/^	unsigned int sess_cnt;$/;"	m	union:stktable_data
sess_conn_cb	src/session.c	/^struct data_cb sess_conn_cb = {$/;"	v	typeref:struct:data_cb
sess_cookie	src/log.c	/^const char sess_cookie[8]     = "NIDVEOU7";	\/* No cookie, Invalid cookie, cookie for a Down server, Valid cookie, Expired cookie, Old cookie, Unused, unknown *\/$/;"	v
sess_establish	src/session.c	/^static void sess_establish(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_fin_state	src/log.c	/^const char sess_fin_state[8]  = "-RCHDLQT";	\/* cliRequest, srvConnect, srvHeader, Data, Last, Queue, Tarpit *\/$/;"	v
sess_log	src/log.c	/^void sess_log(struct session *s)$/;"	f
sess_per_sec	include/types/global.h	/^	struct freq_ctr sess_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
sess_per_sec	include/types/server.h	/^	struct freq_ctr sess_per_sec;		\/* sessions per second on this server *\/$/;"	m	struct:server	typeref:struct:server::freq_ctr
sess_prepare_conn_req	src/session.c	/^static void sess_prepare_conn_req(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_rate	include/types/stick_table.h	/^	struct freq_ctr_period sess_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
sess_set_cookie	src/log.c	/^const char sess_set_cookie[8] = "NPDIRU67";	\/* No set-cookie, Set-cookie found and left unchanged (passive),$/;"	v
sess_set_term_flags	src/session.c	/^static void sess_set_term_flags(struct session *s)$/;"	f	file:
sess_term_cond	src/log.c	/^const char sess_term_cond[16] = "-LcCsSPRIDKUIIII"; \/* normal, Local, CliTo, CliErr, SrvTo, SrvErr, PxErr, Resource, Internal, Down, Killed, Up, -- *\/$/;"	v
sess_update_st_cer	src/session.c	/^static int sess_update_st_cer(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_update_st_con_tcp	src/session.c	/^static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_update_stream_int	src/session.c	/^static void sess_update_stream_int(struct session *s, struct stream_interface *si)$/;"	f	file:
sessid	include/common/appsession.h	/^	char *sessid;$/;"	m	struct:appsessions
sessid	include/common/appsession.h	/^	struct pool_head *sessid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head
sessid	include/types/proto_http.h	/^	char *sessid;                   \/* the appsession id, if found in the request or in the response *\/$/;"	m	struct:http_txn
session	include/types/peers.h	/^	struct session *session;      \/* current transport session *\/$/;"	m	struct:peer_session	typeref:struct:peer_session::session
session	include/types/session.h	/^struct session {$/;"	s
session	src/shctx.c	/^		struct shared_session session;$/;"	m	union:shared_block::__anon115	typeref:struct:shared_block::__anon115::shared_session	file:
session_accept	src/session.c	/^int session_accept(struct listener *l, int cfd, struct sockaddr_storage *addr)$/;"	f
session_add_srv_conn	include/proto/session.h	/^static void inline session_add_srv_conn(struct session *sess, struct server *srv)$/;"	f
session_complete	src/session.c	/^int session_complete(struct session *s)$/;"	f
session_del_srv_conn	include/proto/session.h	/^static void inline session_del_srv_conn(struct session *sess)$/;"	f
session_free	src/session.c	/^static void session_free(struct session *s)$/;"	f	file:
session_from_task	include/proto/session.h	/^static inline struct session *session_from_task(struct task *t)$/;"	f
session_inc_be_http_req_ctr	include/proto/session.h	/^static void inline session_inc_be_http_req_ctr(struct session *s)$/;"	f
session_inc_http_err_ctr	include/proto/session.h	/^static void inline session_inc_http_err_ctr(struct session *s)$/;"	f
session_inc_http_req_ctr	include/proto/session.h	/^static void inline session_inc_http_req_ctr(struct session *s)$/;"	f
session_init_srv_conn	include/proto/session.h	/^static void inline session_init_srv_conn(struct session *sess)$/;"	f
session_process_counters	src/session.c	/^void session_process_counters(struct session *s)$/;"	f
session_set_backend	src/proxy.c	/^int session_set_backend(struct session *s, struct proxy *be)$/;"	f
session_shutdown	src/session.c	/^void session_shutdown(struct session *session, int why)$/;"	f
session_start_counters	include/proto/session.h	/^static inline void session_start_counters(struct stktable *t, struct stksess *ts)$/;"	f
session_stop_content_counters	include/proto/session.h	/^static inline void session_stop_content_counters(struct session *s)$/;"	f
session_store_counters	include/proto/session.h	/^static inline void session_store_counters(struct session *s)$/;"	f
session_track_stkctr	include/proto/session.h	/^static inline void session_track_stkctr(struct stkctr *ctr, struct stktable *t, struct stksess *ts)$/;"	f
session_update_time_stats	src/session.c	/^void session_update_time_stats(struct session *s)$/;"	f
sessions	include/types/peers.h	/^	struct peer_session *sessions;	    \/* peer sessions list *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::peer_session
sessions	src/session.c	/^struct list sessions;$/;"	v	typeref:struct:list
set_backend_down	src/backend.c	/^void set_backend_down(struct proxy *be)$/;"	f
set_host_port	include/common/standard.h	/^static inline int set_host_port(struct sockaddr_storage *addr, int port)$/;"	f
set_net_port	include/common/standard.h	/^static inline int set_net_port(struct sockaddr_storage *addr, int port)$/;"	f
set_server_check_status	src/checks.c	/^static void set_server_check_status(struct check *check, short status, const char *desc)$/;"	f	file:
set_server_status_down	include/types/backend.h	/^	void (*set_server_status_down)(struct server *); \/* to be called after status changes to DOWN *\/$/;"	m	struct:lbprm
set_server_status_up	include/types/backend.h	/^	void (*set_server_status_up)(struct server *);   \/* to be called after status changes to UP *\/$/;"	m	struct:lbprm
sflags	include/types/pattern.h	/^	int sflags;                     \/* flags relative to the storage method. *\/$/;"	m	struct:pattern
shared_block	src/shctx.c	/^struct shared_block {$/;"	s	file:
shared_context	src/shctx.c	/^struct shared_context {$/;"	s	file:
shared_context_init	src/shctx.c	/^int shared_context_init(int size, int shared)$/;"	f
shared_context_lock	src/shctx.c	210;"	d	file:
shared_context_lock	src/shctx.c	83;"	d	file:
shared_context_lock	src/shctx.c	89;"	d	file:
shared_context_set_cache	src/shctx.c	/^void shared_context_set_cache(SSL_CTX *ctx)$/;"	f
shared_context_unlock	src/shctx.c	212;"	d	file:
shared_context_unlock	src/shctx.c	84;"	d	file:
shared_context_unlock	src/shctx.c	90;"	d	file:
shared_session	src/shctx.c	/^struct shared_session {$/;"	s	file:
shared_table	include/types/peers.h	/^struct shared_table {$/;"	s
shblock_set_active	src/shctx.c	228;"	d	file:
shblock_set_free	src/shctx.c	221;"	d	file:
shblock_unset	src/shctx.c	218;"	d	file:
shctx	src/shctx.c	/^static struct shared_context *shctx = NULL;$/;"	v	typeref:struct:shared_context	file:
shctx_get_cb	src/shctx.c	/^SSL_SESSION *shctx_get_cb(SSL *ssl, unsigned char *key, int key_len, int *do_copy)$/;"	f
shctx_lookups	include/types/global.h	/^	unsigned int shctx_lookups, shctx_misses;$/;"	m	struct:global
shctx_misses	include/types/global.h	/^	unsigned int shctx_lookups, shctx_misses;$/;"	m	struct:global
shctx_new_cb	src/shctx.c	/^int shctx_new_cb(SSL *ssl, SSL_SESSION *sess)$/;"	f
shctx_remove_cb	src/shctx.c	/^void shctx_remove_cb(SSL_CTX *ctx, SSL_SESSION *sess)$/;"	f
shl32	tests/uri_hash.c	/^static inline u_int32_t shl32(u_int32_t i, int count) {$/;"	f	file:
showList	examples/stats_haproxy.sh	/^showList ()$/;"	f
shr32	tests/uri_hash.c	/^static inline u_int32_t shr32(u_int32_t i, int count) {$/;"	f	file:
shsess_free	src/shctx.c	/^static int shsess_free(struct shared_session *shsess)$/;"	f	file:
shsess_get_next	src/shctx.c	/^static struct shared_session *shsess_get_next(int data_len)$/;"	f	file:
shsess_packet	src/shctx.c	/^struct shsess_packet {$/;"	s	file:
shsess_packet_hdr	src/shctx.c	/^struct shsess_packet_hdr {$/;"	s	file:
shsess_store	src/shctx.c	/^static int shsess_store(unsigned char *s_id, unsigned char *data, int data_len)$/;"	f	file:
shsess_tree_delete	src/shctx.c	237;"	d	file:
shsess_tree_insert	src/shctx.c	239;"	d	file:
shsess_tree_lookup	src/shctx.c	242;"	d	file:
shut_your_big_mouth_gcc	include/common/standard.h	/^static inline void shut_your_big_mouth_gcc(int r)$/;"	f
shut_your_big_mouth_gcc_int	src/haproxy.c	/^int shut_your_big_mouth_gcc_int = 0;$/;"	v
shutr	include/types/connection.h	/^	void (*shutr)(struct connection *, int);    \/* shutr function *\/$/;"	m	struct:xprt_ops
shutr	include/types/stream_interface.h	/^	void (*shutr)(struct stream_interface *);   \/* shut read function *\/$/;"	m	struct:si_ops
shutw	include/types/connection.h	/^	void (*shutw)(struct connection *, int);    \/* shutw function *\/$/;"	m	struct:xprt_ops
shutw	include/types/stream_interface.h	/^	void (*shutw)(struct stream_interface *);   \/* shut write function *\/$/;"	m	struct:si_ops
si	include/types/session.h	/^	struct stream_interface si[2];          \/* client and server stream interfaces *\/$/;"	m	struct:session	typeref:struct:session::stream_interface
si_alloc_appctx	include/proto/stream_interface.h	/^static inline struct appctx *si_alloc_appctx(struct stream_interface *si)$/;"	f
si_alloc_conn	include/proto/stream_interface.h	/^static inline struct connection *si_alloc_conn(struct stream_interface *si, int reuse)$/;"	f
si_appctx	include/proto/stream_interface.h	/^static inline struct appctx *si_appctx(struct stream_interface *si)$/;"	f
si_applet	include/proto/stream_interface.h	/^static inline const struct si_applet *si_applet(struct stream_interface *si)$/;"	f
si_applet	include/types/stream_interface.h	/^struct si_applet {$/;"	s
si_applet_call	include/proto/stream_interface.h	/^static inline int si_applet_call(struct stream_interface *si)$/;"	f
si_applet_release	include/proto/stream_interface.h	/^static inline void si_applet_release(struct stream_interface *si)$/;"	f
si_attach_appctx	include/proto/stream_interface.h	/^static inline void si_attach_appctx(struct stream_interface *si, struct appctx *appctx)$/;"	f
si_attach_conn	include/proto/stream_interface.h	/^static inline void si_attach_conn(struct stream_interface *si, struct connection *conn)$/;"	f
si_chk_rcv	include/proto/stream_interface.h	/^static inline void si_chk_rcv(struct stream_interface *si)$/;"	f
si_chk_snd	include/proto/stream_interface.h	/^static inline void si_chk_snd(struct stream_interface *si)$/;"	f
si_conn_cb	src/stream_interface.c	/^struct data_cb si_conn_cb = {$/;"	v	typeref:struct:data_cb
si_conn_ops	src/stream_interface.c	/^struct si_ops si_conn_ops = {$/;"	v	typeref:struct:si_ops
si_conn_ready	include/proto/stream_interface.h	/^static inline int si_conn_ready(struct stream_interface *si)$/;"	f
si_conn_recv_cb	src/stream_interface.c	/^static void si_conn_recv_cb(struct connection *conn)$/;"	f	file:
si_conn_send	src/stream_interface.c	/^static void si_conn_send(struct connection *conn)$/;"	f	file:
si_conn_send_cb	src/stream_interface.c	/^static void si_conn_send_cb(struct connection *conn)$/;"	f	file:
si_conn_wake_cb	src/stream_interface.c	/^static int si_conn_wake_cb(struct connection *conn)$/;"	f	file:
si_connect	include/proto/stream_interface.h	/^static inline int si_connect(struct stream_interface *si)$/;"	f
si_detach	include/proto/stream_interface.h	/^static inline void si_detach(struct stream_interface *si)$/;"	f
si_embedded_ops	src/stream_interface.c	/^struct si_ops si_embedded_ops = {$/;"	v	typeref:struct:si_ops
si_idle_conn	include/proto/stream_interface.h	/^static inline void si_idle_conn(struct stream_interface *si)$/;"	f
si_idle_conn_cb	src/stream_interface.c	/^struct data_cb si_idle_conn_cb = {$/;"	v	typeref:struct:data_cb
si_idle_conn_null_cb	src/stream_interface.c	/^static void si_idle_conn_null_cb(struct connection *conn)$/;"	f	file:
si_idle_conn_wake_cb	src/stream_interface.c	/^static int si_idle_conn_wake_cb(struct connection *conn)$/;"	f	file:
si_ops	include/types/stream_interface.h	/^struct si_ops {$/;"	s
si_release_endpoint	include/proto/stream_interface.h	/^static inline void si_release_endpoint(struct stream_interface *si)$/;"	f
si_reset	include/proto/stream_interface.h	/^static inline void si_reset(struct stream_interface *si, void *owner)$/;"	f
si_set_state	include/proto/stream_interface.h	/^static inline void si_set_state(struct stream_interface *si, int state)$/;"	f
si_shutr	include/proto/stream_interface.h	/^static inline void si_shutr(struct stream_interface *si)$/;"	f
si_shutw	include/proto/stream_interface.h	/^static inline void si_shutw(struct stream_interface *si)$/;"	f
si_state	include/types/stream_interface.h	/^enum si_state {$/;"	g
si_state_str	include/proto/stream_interface.h	/^static inline const char *si_state_str(int state)$/;"	f
si_update	include/proto/stream_interface.h	/^static inline void si_update(struct stream_interface *si)$/;"	f
sid	include/types/proxy.h	/^	unsigned int sid;		\/* ID of the faulty session *\/$/;"	m	struct:error_snapshot
sid	include/types/stream_interface.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:appctx::__anon43::__anon44
sid	include/types/stream_interface.h	/^			unsigned int sid;	\/* session ID of error being dumped *\/$/;"	m	struct:appctx::__anon43::__anon46
sig	include/types/connection.h	/^	uint8_t sig[12];   \/* hex 0D 0A 0D 0A 00 0D 0A 51 55 49 54 0A *\/$/;"	m	struct:proxy_hdr_v2
sig	src/shctx.c	/^	unsigned char sig[SHA_DIGEST_LENGTH];$/;"	m	struct:shsess_packet	file:
sig_dump_state	src/haproxy.c	/^void sig_dump_state(struct sig_handler *sh)$/;"	f
sig_handler	include/types/signal.h	/^struct sig_handler {$/;"	s
sig_listen	src/haproxy.c	/^void sig_listen(struct sig_handler *sh)$/;"	f
sig_pause	src/haproxy.c	/^void sig_pause(struct sig_handler *sh)$/;"	f
sig_soft_stop	src/haproxy.c	/^void sig_soft_stop(struct sig_handler *sh)$/;"	f
sigint_handler	src/haproxy-systemd-wrapper.c	/^static void sigint_handler(int signum __attribute__((unused)))$/;"	f	file:
signal_descriptor	include/types/signal.h	/^struct signal_descriptor {$/;"	s
signal_handler	src/signal.c	/^void signal_handler(int sig)$/;"	f
signal_init	src/signal.c	/^int signal_init()$/;"	f
signal_pending	src/signal.c	/^int signal_pending = 0; \/* non-zero if t least one signal remains unprocessed *\/$/;"	v
signal_process_queue	include/proto/signal.h	/^static inline void signal_process_queue()$/;"	f
signal_queue	src/signal.c	/^int signal_queue[MAX_SIGNAL];                     \/* in-order queue of received signals *\/$/;"	v
signal_queue_len	src/signal.c	/^int signal_queue_len; \/* length of signal queue, <= MAX_SIGNAL (1 entry per signal max) *\/$/;"	v
signal_register_fct	src/signal.c	/^struct sig_handler *signal_register_fct(int sig, void (*fct)(struct sig_handler *), int arg)$/;"	f
signal_register_task	src/signal.c	/^struct sig_handler *signal_register_task(int sig, struct task *task, int reason)$/;"	f
signal_state	src/signal.c	/^struct signal_descriptor signal_state[MAX_SIGNAL];$/;"	v	typeref:struct:signal_descriptor
signal_unregister_handler	src/signal.c	/^void signal_unregister_handler(struct sig_handler *handler)$/;"	f
signal_unregister_target	src/signal.c	/^void signal_unregister_target(int sig, void *target)$/;"	f
sigusr2_handler	src/haproxy-systemd-wrapper.c	/^static void sigusr2_handler(int signum __attribute__((unused)))$/;"	f	file:
sint	include/types/arg.h	/^	int sint;$/;"	m	union:arg_data
sint	include/types/sample.h	/^		int             sint;  \/* used for signed 32bits integers *\/$/;"	m	union:sample::__anon92
sint	include/types/sample.h	/^		int             sint;  \/* used for signed 32bits integers *\/$/;"	m	union:sample_storage::__anon93
size	include/common/buffer.h	/^	unsigned int size;              \/* buffer size in bytes *\/$/;"	m	struct:buffer
size	include/common/chunk.h	/^	int size;	\/* total size of the buffer, 0 if the *str is read-only *\/$/;"	m	struct:chunk
size	include/common/memory.h	/^	unsigned int size;	\/* chunk size *\/$/;"	m	struct:pool_head
size	include/types/hdr_idx.h	/^	short size;                 \/* size of the array including the head *\/$/;"	m	struct:hdr_idx
size	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
size	include/types/stick_table.h	/^	unsigned int size;        \/* maximum number of sticky sessions in table *\/$/;"	m	struct:stktable
sizeof_talloc	tests/test_pools.c	124;"	d	file:
skip	include/types/listener.h	/^	int skip; \/* nb of args to skip *\/$/;"	m	struct:bind_kw
skip	include/types/server.h	/^	int skip; \/* nb min of args to skip, for use when kw is not handled *\/$/;"	m	struct:srv_kw
sl	include/types/proto_http.h	/^	} sl;                                  \/* start line *\/$/;"	m	struct:http_msg	typeref:union:http_msg::__anon64
slowstart	include/types/server.h	/^	int slowstart;				\/* slowstart time in seconds (ms in the conf) *\/$/;"	m	struct:server
smp	include/types/acl.h	/^	struct sample_expr *smp;      \/* the sample expression we depend on *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::sample_expr
smp	include/types/acl.h	/^	struct sample_fetch *smp; \/* the sample fetch we depend on *\/$/;"	m	struct:acl_keyword	typeref:struct:acl_keyword::sample_fetch
smp	include/types/pattern.h	/^	struct sample_storage *smp;     \/* used to store a pointer to sample value associated$/;"	m	struct:pattern	typeref:struct:pattern::sample_storage
smp	include/types/pattern.h	/^	struct sample_storage *smp;$/;"	m	struct:pattern_tree	typeref:struct:pattern_tree::sample_storage
smp_ctx	include/types/sample.h	/^union smp_ctx {$/;"	u
smp_dup	src/sample.c	/^int smp_dup(struct sample *smp)$/;"	f
smp_expr_output_type	src/sample.c	/^int smp_expr_output_type(struct sample_expr *expr)$/;"	f
smp_fetch_avg_queue_size	src/backend.c	/^smp_fetch_avg_queue_size(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_base	src/proto_http.c	/^smp_fetch_base(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_base32	src/proto_http.c	/^smp_fetch_base32(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_base32_src	src/proto_http.c	/^smp_fetch_base32_src(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_be_conn	src/backend.c	/^smp_fetch_be_conn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_be_id	src/backend.c	/^smp_fetch_be_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_be_sess_rate	src/backend.c	/^smp_fetch_be_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_capture_header_req	src/proto_http.c	/^smp_fetch_capture_header_req(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_capture_header_res	src/proto_http.c	/^smp_fetch_capture_header_res(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_capture_req_method	src/proto_http.c	/^smp_fetch_capture_req_method(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_capture_req_uri	src/proto_http.c	/^smp_fetch_capture_req_uri(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_capture_req_ver	src/proto_http.c	/^smp_fetch_capture_req_ver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_capture_res_ver	src/proto_http.c	/^smp_fetch_capture_res_ver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_connslots	src/backend.c	/^smp_fetch_connslots(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_cookie	src/proto_http.c	/^int smp_fetch_cookie(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f
smp_fetch_cookie_cnt	src/proto_http.c	/^smp_fetch_cookie_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_cookie_val	src/proto_http.c	/^smp_fetch_cookie_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_date	src/sample.c	/^smp_fetch_date(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_dconn	src/listener.c	/^smp_fetch_dconn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_dport	src/proto_tcp.c	/^smp_fetch_dport(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_dst	src/proto_tcp.c	/^smp_fetch_dst(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_env	src/sample.c	/^smp_fetch_env(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_false	src/sample.c	/^smp_fetch_false(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_fe_conn	src/frontend.c	/^smp_fetch_fe_conn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_fe_id	src/frontend.c	/^smp_fetch_fe_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_fe_sess_rate	src/frontend.c	/^smp_fetch_fe_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_fhdr	src/proto_http.c	/^smp_fetch_fhdr(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_fhdr_cnt	src/proto_http.c	/^smp_fetch_fhdr_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr	src/proto_http.c	/^smp_fetch_hdr(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr_cnt	src/proto_http.c	/^smp_fetch_hdr_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr_ip	src/proto_http.c	/^smp_fetch_hdr_ip(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr_val	src/proto_http.c	/^smp_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_http_auth	src/proto_http.c	/^smp_fetch_http_auth(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_http_auth_grp	src/proto_http.c	/^smp_fetch_http_auth_grp(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_http_first_req	src/proto_http.c	/^smp_fetch_http_first_req(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_keywords	src/session.c	/^static struct sample_fetch_kw_list smp_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_fetch_len	src/payload.c	/^smp_fetch_len(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_meth	src/proto_http.c	/^smp_fetch_meth(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_nbsrv	src/backend.c	/^smp_fetch_nbsrv(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_path	src/proto_http.c	/^smp_fetch_path(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_payload	src/payload.c	/^smp_fetch_payload(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_payload_lv	src/payload.c	/^smp_fetch_payload_lv(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_proto_http	src/proto_http.c	/^smp_fetch_proto_http(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_queue_size	src/backend.c	/^smp_fetch_queue_size(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_rand	src/sample.c	/^smp_fetch_rand(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_rdp_cookie	src/payload.c	/^smp_fetch_rdp_cookie(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f
smp_fetch_rdp_cookie_cnt	src/payload.c	/^smp_fetch_rdp_cookie_cnt(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_req_ssl_ver	src/payload.c	/^smp_fetch_req_ssl_ver(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_res_comp	src/compression.c	/^smp_fetch_res_comp(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_res_comp_algo	src/compression.c	/^smp_fetch_res_comp_algo(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_rqver	src/proto_http.c	/^smp_fetch_rqver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_bytes_in_rate	src/session.c	/^smp_fetch_sc_bytes_in_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_bytes_out_rate	src/session.c	/^smp_fetch_sc_bytes_out_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_clr_gpc0	src/session.c	/^smp_fetch_sc_clr_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_conn_cnt	src/session.c	/^smp_fetch_sc_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_conn_cur	src/session.c	/^smp_fetch_sc_conn_cur(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_conn_rate	src/session.c	/^smp_fetch_sc_conn_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_get_gpc0	src/session.c	/^smp_fetch_sc_get_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_gpc0_rate	src/session.c	/^smp_fetch_sc_gpc0_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_http_err_cnt	src/session.c	/^smp_fetch_sc_http_err_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_http_err_rate	src/session.c	/^smp_fetch_sc_http_err_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_http_req_cnt	src/session.c	/^smp_fetch_sc_http_req_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_http_req_rate	src/session.c	/^smp_fetch_sc_http_req_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_inc_gpc0	src/session.c	/^smp_fetch_sc_inc_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_kbytes_in	src/session.c	/^smp_fetch_sc_kbytes_in(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_kbytes_out	src/session.c	/^smp_fetch_sc_kbytes_out(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_sess_cnt	src/session.c	/^smp_fetch_sc_sess_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_sess_rate	src/session.c	/^smp_fetch_sc_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_stkctr	src/session.c	/^smp_fetch_sc_stkctr(struct session *l4, const struct arg *args, const char *kw)$/;"	f	file:
smp_fetch_sc_tracked	src/session.c	/^smp_fetch_sc_tracked(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sc_trackers	src/session.c	/^smp_fetch_sc_trackers(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_so_id	src/listener.c	/^smp_fetch_so_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_sport	src/proto_tcp.c	/^smp_fetch_sport(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_src	src/proto_tcp.c	/^smp_fetch_src(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_src_updt_conn_cnt	src/session.c	/^smp_fetch_src_updt_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_srv_conn	src/backend.c	/^smp_fetch_srv_conn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_srv_id	src/backend.c	/^smp_fetch_srv_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_srv_is_up	src/backend.c	/^smp_fetch_srv_is_up(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_srv_sess_rate	src/backend.c	/^smp_fetch_srv_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_c_ca_err	src/ssl_sock.c	/^smp_fetch_ssl_c_ca_err(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_c_ca_err_depth	src/ssl_sock.c	/^smp_fetch_ssl_c_ca_err_depth(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_c_err	src/ssl_sock.c	/^smp_fetch_ssl_c_err(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_c_used	src/ssl_sock.c	/^smp_fetch_ssl_c_used(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_c_verify	src/ssl_sock.c	/^smp_fetch_ssl_c_verify(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc	src/ssl_sock.c	/^smp_fetch_ssl_fc(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_alg_keysize	src/ssl_sock.c	/^smp_fetch_ssl_fc_alg_keysize(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_alpn	src/ssl_sock.c	/^smp_fetch_ssl_fc_alpn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_cipher	src/ssl_sock.c	/^smp_fetch_ssl_fc_cipher(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_has_crt	src/ssl_sock.c	/^smp_fetch_ssl_fc_has_crt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_has_sni	src/ssl_sock.c	/^smp_fetch_ssl_fc_has_sni(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_npn	src/ssl_sock.c	/^smp_fetch_ssl_fc_npn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_protocol	src/ssl_sock.c	/^smp_fetch_ssl_fc_protocol(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_session_id	src/ssl_sock.c	/^smp_fetch_ssl_fc_session_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_sni	src/ssl_sock.c	/^smp_fetch_ssl_fc_sni(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_unique_id	src/ssl_sock.c	/^smp_fetch_ssl_fc_unique_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_fc_use_keysize	src/ssl_sock.c	/^smp_fetch_ssl_fc_use_keysize(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_hello_sni	src/payload.c	/^smp_fetch_ssl_hello_sni(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_hello_type	src/payload.c	/^smp_fetch_ssl_hello_type(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_i_dn	src/ssl_sock.c	/^smp_fetch_ssl_x_i_dn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_key_alg	src/ssl_sock.c	/^smp_fetch_ssl_x_key_alg(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_notafter	src/ssl_sock.c	/^smp_fetch_ssl_x_notafter(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_notbefore	src/ssl_sock.c	/^smp_fetch_ssl_x_notbefore(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_s_dn	src/ssl_sock.c	/^smp_fetch_ssl_x_s_dn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_serial	src/ssl_sock.c	/^smp_fetch_ssl_x_serial(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_sha1	src/ssl_sock.c	/^smp_fetch_ssl_x_sha1(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_sig_alg	src/ssl_sock.c	/^smp_fetch_ssl_x_sig_alg(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_ssl_x_version	src/ssl_sock.c	/^smp_fetch_ssl_x_version(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_stcode	src/proto_http.c	/^smp_fetch_stcode(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_stver	src/proto_http.c	/^smp_fetch_stver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_table_avl	src/session.c	/^smp_fetch_table_avl(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_table_cnt	src/session.c	/^smp_fetch_table_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_true	src/sample.c	/^smp_fetch_true(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url	src/proto_http.c	/^smp_fetch_url(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url32	src/proto_http.c	/^smp_fetch_url32(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url32_src	src/proto_http.c	/^smp_fetch_url32_src(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url_ip	src/proto_http.c	/^smp_fetch_url_ip(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url_param	src/proto_http.c	/^smp_fetch_url_param(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url_param_val	src/proto_http.c	/^smp_fetch_url_param_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url_port	src/proto_http.c	/^smp_fetch_url_port(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_wait_end	src/payload.c	/^smp_fetch_wait_end(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_kws	src/backend.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	src/frontend.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	src/listener.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	src/payload.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	src/sample.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_prefetch_http	src/proto_http.c	/^smp_prefetch_http(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
smp_resolve_args	src/sample.c	/^int smp_resolve_args(struct proxy *p)$/;"	f
smp_to_type	src/sample.c	/^const char *smp_to_type[SMP_TYPES] = {$/;"	v
snd_buf	include/types/connection.h	/^	int  (*snd_buf)(struct connection *conn, struct buffer *buf, int flags); \/* send callback *\/$/;"	m	struct:xprt_ops
snd_pipe	include/types/connection.h	/^	int  (*snd_pipe)(struct connection *conn, struct pipe *pipe); \/* send-to-pipe callback *\/$/;"	m	struct:xprt_ops
sni_ctx	include/types/listener.h	/^	struct eb_root sni_ctx;    \/* sni_ctx tree of all known certs full-names sorted by name *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::eb_root
sni_ctx	include/types/ssl_sock.h	/^struct sni_ctx {$/;"	s
sni_w_ctx	include/types/listener.h	/^	struct eb_root sni_w_ctx;  \/* sni_ctx tree of all known certs wildcards sorted by name *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::eb_root
sock	include/types/connection.h	/^		} sock;$/;"	m	union:connection::__anon78	typeref:struct:connection::__anon78::__anon79
sock_addrlen	include/types/protocol.h	/^	socklen_t sock_addrlen;				\/* socket address length, used by bind() *\/$/;"	m	struct:protocol
sock_domain	include/types/protocol.h	/^	int sock_domain;				\/* socket domain, as passed to socket()   *\/$/;"	m	struct:protocol
sock_family	include/types/protocol.h	/^	sa_family_t sock_family;			\/* socket family, for sockaddr *\/$/;"	m	struct:protocol
sock_init_arg	include/types/peers.h	/^	void *sock_init_arg;           \/* socket operations's opaque init argument if needed *\/$/;"	m	struct:peer
sock_prot	include/types/protocol.h	/^	int sock_prot;					\/* socket protocol, as passed to socket() *\/$/;"	m	struct:protocol
sock_type	include/types/protocol.h	/^	int sock_type;					\/* socket type, as passed to socket()     *\/$/;"	m	struct:protocol
soft_stop	src/proxy.c	/^void soft_stop(void)$/;"	f
sol	include/types/proto_http.h	/^	unsigned int sol;                      \/* start of current line during parsing otherwise zero *\/$/;"	m	struct:http_msg
source_addr	include/types/connection.h	/^	struct sockaddr_storage source_addr; \/* the address to which we want to bind for connect() *\/$/;"	m	struct:conn_src	typeref:struct:conn_src::sockaddr_storage
sov	include/types/proto_http.h	/^	unsigned int sov;                      \/* current header: start of value *\/$/;"	m	struct:http_msg
spawn_haproxy	src/haproxy-systemd-wrapper.c	/^static void spawn_haproxy(char **pid_strv, int nb_pid)$/;"	f	file:
split_url	include/common/standard.h	/^struct split_url {$/;"	s
sport_range	include/types/connection.h	/^	struct port_range *sport_range;      \/* optional per-server TCP source ports *\/$/;"	m	struct:conn_src	typeref:struct:conn_src::port_range
spread_checks	include/types/global.h	/^	int spread_checks;$/;"	m	struct:global
sps_lim	include/types/global.h	/^	int sps_lim, sps_max;$/;"	m	struct:global
sps_max	include/types/counters.h	/^	unsigned int sps_max;			\/* maximum of new sessions per second seen on this server *\/$/;"	m	struct:srvcounters
sps_max	include/types/counters.h	/^	unsigned int sps_max;                   \/* maximum of new connections accepted per second (sessions) *\/$/;"	m	struct:pxcounters
sps_max	include/types/global.h	/^	int sps_lim, sps_max;$/;"	m	struct:global
src	include/types/proxy.h	/^	struct sockaddr_storage src;	\/* client's address *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::sockaddr_storage
src_addr	include/types/connection.h	/^			uint32_t src_addr;$/;"	m	struct:proxy_hdr_v2::__anon81::__anon82
src_addr	include/types/connection.h	/^			uint8_t  src_addr[16];$/;"	m	struct:proxy_hdr_v2::__anon81::__anon83
src_addr	include/types/connection.h	/^			uint8_t src_addr[108];$/;"	m	struct:proxy_hdr_v2::__anon81::__anon84
src_port	include/types/connection.h	/^			uint16_t src_port;$/;"	m	struct:proxy_hdr_v2::__anon81::__anon82
src_port	include/types/connection.h	/^			uint16_t src_port;$/;"	m	struct:proxy_hdr_v2::__anon81::__anon83
srv	include/types/arg.h	/^	struct server *srv;$/;"	m	union:arg_data	typeref:struct:arg_data::server
srv	include/types/lb_map.h	/^	struct server **srv;	\/* the server map used to apply weights *\/$/;"	m	struct:lb_map	typeref:struct:lb_map::server
srv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::server
srv	include/types/proxy.h	/^	struct server *srv;		\/* server associated with the error (or NULL) *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::server
srv	include/types/proxy.h	/^	} srv;$/;"	m	struct:server_rule	typeref:union:server_rule::__anon21
srv	include/types/queue.h	/^	struct server *srv;		\/* the server we are waiting for *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::server
srv	tests/filltab25.c	/^struct srv {$/;"	s	file:
srv	tests/filltab25.c	/^} *srv;$/;"	v	typeref:struct:srv
srv_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters
srv_aborts	include/types/counters.h	/^	long long srv_aborts;                   \/* aborted responses during DATA phase caused by the server *\/$/;"	m	struct:pxcounters
srv_act	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy
srv_adm_set_drain	include/proto/server.h	/^static inline void srv_adm_set_drain(struct server *s)$/;"	f
srv_adm_set_maint	include/proto/server.h	/^static inline void srv_adm_set_maint(struct server *s)$/;"	f
srv_adm_set_ready	include/proto/server.h	/^static inline void srv_adm_set_ready(struct server *s)$/;"	f
srv_admin	include/types/server.h	/^enum srv_admin {$/;"	g
srv_append_status	src/server.c	/^void srv_append_status(struct chunk *msg, struct server *s, const char *reason, int xferred, int forced)$/;"	f
srv_bck	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy
srv_clr_admin_flag	src/server.c	/^void srv_clr_admin_flag(struct server *s, enum srv_admin mode)$/;"	f
srv_conn	include/types/session.h	/^	struct server *srv_conn;		\/* session already has a slot on a server and is not in queue *\/$/;"	m	struct:session	typeref:struct:session::server
srv_cookie	include/types/proto_http.h	/^	char *srv_cookie;               \/* cookie presented by the server, in capture mode *\/$/;"	m	struct:http_txn
srv_downtime	src/server.c	/^int srv_downtime(const struct server *s)$/;"	f
srv_dump_kws	src/server.c	/^void srv_dump_kws(char **out)$/;"	f
srv_dynamic_maxconn	src/queue.c	/^unsigned int srv_dynamic_maxconn(const struct server *s)$/;"	f
srv_error	include/types/session.h	/^	void (*srv_error)(struct session *s,	\/* the function to call upon unrecoverable server errors (or NULL) *\/$/;"	m	struct:session
srv_find_kw	src/server.c	/^struct srv_kw *srv_find_kw(const char *kw)$/;"	f
srv_getinter	src/server.c	/^int srv_getinter(const struct check *check)$/;"	f
srv_inc_sess_ctr	include/proto/server.h	/^static void inline srv_inc_sess_ctr(struct server *s)$/;"	f
srv_is_usable	include/proto/backend.h	/^static inline int srv_is_usable(const struct server *srv)$/;"	f
srv_keywords	src/server.c	/^static struct srv_kw_list srv_keywords = {$/;"	v	typeref:struct:srv_kw_list	file:
srv_kw	include/types/server.h	/^struct srv_kw {$/;"	s
srv_kw_list	include/types/server.h	/^struct srv_kw_list {$/;"	s
srv_kws	src/server.c	/^static struct srv_kw_list srv_kws = { "ALL", { }, {$/;"	v	typeref:struct:srv_kw_list	file:
srv_kws	src/ssl_sock.c	/^static struct srv_kw_list srv_kws = { "SSL", { }, {$/;"	v	typeref:struct:srv_kw_list	file:
srv_lastsession	src/server.c	/^int srv_lastsession(const struct server *s)$/;"	f
srv_lb_commit_status	include/proto/backend.h	/^static inline void srv_lb_commit_status(struct server *srv)$/;"	f
srv_lb_status_changed	include/proto/backend.h	/^static inline int srv_lb_status_changed(const struct server *srv)$/;"	f
srv_parse_ca_file	src/ssl_sock.c	/^static int srv_parse_ca_file(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_check_ssl	src/ssl_sock.c	/^static int srv_parse_check_ssl(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_ciphers	src/ssl_sock.c	/^static int srv_parse_ciphers(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_crl_file	src/ssl_sock.c	/^static int srv_parse_crl_file(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_crt	src/ssl_sock.c	/^static int srv_parse_crt(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_sslv3	src/ssl_sock.c	/^static int srv_parse_force_sslv3(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_tlsv10	src/ssl_sock.c	/^static int srv_parse_force_tlsv10(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_tlsv11	src/ssl_sock.c	/^static int srv_parse_force_tlsv11(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_tlsv12	src/ssl_sock.c	/^static int srv_parse_force_tlsv12(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_id	src/server.c	/^static int srv_parse_id(char **args, int *cur_arg, struct proxy *curproxy, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_sslv3	src/ssl_sock.c	/^static int srv_parse_no_sslv3(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tls_tickets	src/ssl_sock.c	/^static int srv_parse_no_tls_tickets(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tlsv10	src/ssl_sock.c	/^static int srv_parse_no_tlsv10(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tlsv11	src/ssl_sock.c	/^static int srv_parse_no_tlsv11(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tlsv12	src/ssl_sock.c	/^static int srv_parse_no_tlsv12(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_send_proxy_cn	src/ssl_sock.c	/^static int srv_parse_send_proxy_cn(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_send_proxy_ssl	src/ssl_sock.c	/^static int srv_parse_send_proxy_ssl(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_ssl	src/ssl_sock.c	/^static int srv_parse_ssl(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_verify	src/ssl_sock.c	/^static int srv_parse_verify(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_verifyhost	src/ssl_sock.c	/^static int srv_parse_verifyhost(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_queue_size	include/types/session.h	/^		unsigned long srv_queue_size;	\/* number of sessions waiting for a connect slot on this server at accept() time (in direct assignment) *\/$/;"	m	struct:session::__anon55
srv_redispatch_connect	src/backend.c	/^int srv_redispatch_connect(struct session *s)$/;"	f
srv_register_keywords	src/server.c	/^void srv_register_keywords(struct srv_kw_list *kwl)$/;"	f
srv_set_admin_flag	src/server.c	/^void srv_set_admin_flag(struct server *s, enum srv_admin mode)$/;"	f
srv_set_running	src/server.c	/^void srv_set_running(struct server *s, const char *reason)$/;"	f
srv_set_sess_last	include/proto/server.h	/^static void inline srv_set_sess_last(struct server *s)$/;"	f
srv_set_stopped	src/server.c	/^void srv_set_stopped(struct server *s, const char *reason)$/;"	f
srv_set_stopping	src/server.c	/^void srv_set_stopping(struct server *s, const char *reason)$/;"	f
srv_shutdown_backup_sessions	src/server.c	/^void srv_shutdown_backup_sessions(struct proxy *px, int why)$/;"	f
srv_shutdown_sessions	src/server.c	/^void srv_shutdown_sessions(struct server *srv, int why)$/;"	f
srv_st	contrib/halog/halog.c	/^struct srv_st {$/;"	s	file:
srv_state	include/types/server.h	/^enum srv_state {$/;"	g
srv_was_usable	include/proto/backend.h	/^static inline int srv_was_usable(const struct server *srv)$/;"	f
srvcounters	include/types/counters.h	/^struct srvcounters {$/;"	s
ssl_be_keys_max	include/types/global.h	/^	int ssl_fe_keys_max, ssl_be_keys_max;$/;"	m	struct:global
ssl_be_keys_per_sec	include/types/global.h	/^	struct freq_ctr ssl_be_keys_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
ssl_ctx	include/types/server.h	/^	} ssl_ctx;$/;"	m	struct:server	typeref:struct:server::__anon99
ssl_default_dh_param	include/types/global.h	/^		unsigned int ssl_default_dh_param; \/* SSL maximum DH parameter size *\/$/;"	m	struct:global::__anon95
ssl_fe_keys_max	include/types/global.h	/^	int ssl_fe_keys_max, ssl_be_keys_max;$/;"	m	struct:global
ssl_fe_keys_per_sec	include/types/global.h	/^	struct freq_ctr ssl_fe_keys_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
ssl_get_dh_1024	src/ssl_sock.c	/^static DH * ssl_get_dh_1024(void)$/;"	f	file:
ssl_get_dh_2048	src/ssl_sock.c	/^static DH *ssl_get_dh_2048(void)$/;"	f	file:
ssl_get_dh_4096	src/ssl_sock.c	/^static DH *ssl_get_dh_4096(void)$/;"	f	file:
ssl_get_dh_8192	src/ssl_sock.c	/^static DH *ssl_get_dh_8192(void)$/;"	f	file:
ssl_get_tmp_dh	src/ssl_sock.c	/^static DH *ssl_get_tmp_dh(SSL *ssl, int export, int keylen)$/;"	f	file:
ssl_initialize_random	src/ssl_sock.c	/^static int ssl_initialize_random()$/;"	f	file:
ssl_lim	include/types/global.h	/^	int ssl_lim, ssl_max;$/;"	m	struct:global
ssl_max	include/types/global.h	/^	int ssl_lim, ssl_max;$/;"	m	struct:global
ssl_max_record	include/types/global.h	/^		unsigned int ssl_max_record; \/* SSL max record size *\/$/;"	m	struct:global::__anon95
ssl_options	include/types/listener.h	/^	int ssl_options;           \/* ssl options *\/$/;"	m	struct:bind_conf
ssl_per_sec	include/types/global.h	/^	struct freq_ctr ssl_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
ssl_server_verify	include/types/global.h	/^	unsigned int ssl_server_verify; \/* default verify mode on servers side *\/$/;"	m	struct:global
ssl_sock	src/ssl_sock.c	/^struct xprt_ops ssl_sock = {$/;"	v	typeref:struct:xprt_ops
ssl_sock_add_cert_sni	src/ssl_sock.c	/^static int ssl_sock_add_cert_sni(SSL_CTX *ctx, struct bind_conf *s, char *name, int order)$/;"	f	file:
ssl_sock_advertise_alpn_protos	src/ssl_sock.c	/^static int ssl_sock_advertise_alpn_protos(SSL *s, const unsigned char **out,$/;"	f	file:
ssl_sock_advertise_npn_protos	src/ssl_sock.c	/^static int ssl_sock_advertise_npn_protos(SSL *s, const unsigned char **data,$/;"	f	file:
ssl_sock_bind_verifycbk	src/ssl_sock.c	/^int ssl_sock_bind_verifycbk(int ok, X509_STORE_CTX *x_store)$/;"	f
ssl_sock_close	src/ssl_sock.c	/^static void ssl_sock_close(struct connection *conn) {$/;"	f	file:
ssl_sock_free_all_ctx	src/ssl_sock.c	/^void ssl_sock_free_all_ctx(struct bind_conf *bind_conf)$/;"	f
ssl_sock_from_buf	src/ssl_sock.c	/^static int ssl_sock_from_buf(struct connection *conn, struct buffer *buf, int flags)$/;"	f	file:
ssl_sock_get_cert_used	src/ssl_sock.c	/^int ssl_sock_get_cert_used(struct connection *conn)$/;"	f
ssl_sock_get_cipher_name	src/ssl_sock.c	/^const char *ssl_sock_get_cipher_name(struct connection *conn)$/;"	f
ssl_sock_get_common_name	src/ssl_sock.c	/^char *ssl_sock_get_common_name(struct connection *conn)$/;"	f
ssl_sock_get_dn_entry	src/ssl_sock.c	/^ssl_sock_get_dn_entry(X509_NAME *a, const struct chunk *entry, int pos, struct chunk *out)$/;"	f	file:
ssl_sock_get_dn_oneline	src/ssl_sock.c	/^ssl_sock_get_dn_oneline(X509_NAME *a, struct chunk *out)$/;"	f	file:
ssl_sock_get_proto_version	src/ssl_sock.c	/^const char *ssl_sock_get_proto_version(struct connection *conn)$/;"	f
ssl_sock_get_serial	src/ssl_sock.c	/^ssl_sock_get_serial(X509 *crt, struct chunk *out)$/;"	f	file:
ssl_sock_get_time	src/ssl_sock.c	/^ssl_sock_get_time(ASN1_TIME *tm, struct chunk *out)$/;"	f	file:
ssl_sock_get_verify_result	src/ssl_sock.c	/^unsigned int ssl_sock_get_verify_result(struct connection *conn)$/;"	f
ssl_sock_get_version	src/ssl_sock.c	/^char *ssl_sock_get_version(struct connection *conn)$/;"	f
ssl_sock_handshake	src/ssl_sock.c	/^int ssl_sock_handshake(struct connection *conn, unsigned int flag)$/;"	f
ssl_sock_infocbk	src/ssl_sock.c	/^void ssl_sock_infocbk(const SSL *ssl, int where, int ret)$/;"	f
ssl_sock_init	src/ssl_sock.c	/^static int ssl_sock_init(struct connection *conn)$/;"	f	file:
ssl_sock_is_ssl	include/proto/ssl_sock.h	/^int ssl_sock_is_ssl(struct connection *conn)$/;"	f
ssl_sock_load_cert	src/ssl_sock.c	/^int ssl_sock_load_cert(char *path, struct bind_conf *bind_conf, struct proxy *curproxy, char **err)$/;"	f
ssl_sock_load_cert_chain_file	src/ssl_sock.c	/^static int ssl_sock_load_cert_chain_file(SSL_CTX *ctx, const char *file, struct bind_conf *s, char **sni_filter, int fcount)$/;"	f	file:
ssl_sock_load_cert_file	src/ssl_sock.c	/^static int ssl_sock_load_cert_file(const char *path, struct bind_conf *bind_conf, struct proxy *curproxy, char **sni_filter, int fcount, char **err)$/;"	f	file:
ssl_sock_load_cert_list_file	src/ssl_sock.c	/^int ssl_sock_load_cert_list_file(char *file, struct bind_conf *bind_conf, struct proxy *curproxy, char **err)$/;"	f
ssl_sock_load_dh_params	src/ssl_sock.c	/^int ssl_sock_load_dh_params(SSL_CTX *ctx, const char *file)$/;"	f
ssl_sock_load_ocsp	src/ssl_sock.c	/^static int ssl_sock_load_ocsp(SSL_CTX *ctx, const char *cert_path)$/;"	f	file:
ssl_sock_load_ocsp_response	src/ssl_sock.c	/^static int ssl_sock_load_ocsp_response(struct chunk *ocsp_response, struct certificate_ocsp *ocsp, OCSP_CERTID *cid, char **err)$/;"	f	file:
ssl_sock_load_ocsp_response_from_file	src/ssl_sock.c	/^static int ssl_sock_load_ocsp_response_from_file(const char *ocsp_path, struct certificate_ocsp *ocsp, OCSP_CERTID *cid, char **err)$/;"	f	file:
ssl_sock_msgcbk	src/ssl_sock.c	/^void ssl_sock_msgcbk(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)$/;"	f
ssl_sock_ocsp_stapling_cbk	src/ssl_sock.c	/^int ssl_sock_ocsp_stapling_cbk(SSL *ssl, void *arg)$/;"	f
ssl_sock_prepare_all_ctx	src/ssl_sock.c	/^int ssl_sock_prepare_all_ctx(struct bind_conf *bind_conf, struct proxy *px)$/;"	f
ssl_sock_prepare_ctx	src/ssl_sock.c	/^int ssl_sock_prepare_ctx(struct bind_conf *bind_conf, SSL_CTX *ctx, struct proxy *curproxy)$/;"	f
ssl_sock_prepare_srv_ctx	src/ssl_sock.c	/^int ssl_sock_prepare_srv_ctx(struct server *srv, struct proxy *curproxy)$/;"	f
ssl_sock_shutw	src/ssl_sock.c	/^static void ssl_sock_shutw(struct connection *conn, int clean)$/;"	f	file:
ssl_sock_srv_hostcheck	src/ssl_sock.c	/^static int ssl_sock_srv_hostcheck(const char *pattern, const char *hostname)$/;"	f	file:
ssl_sock_srv_verifycbk	src/ssl_sock.c	/^static int ssl_sock_srv_verifycbk(int ok, X509_STORE_CTX *ctx)$/;"	f	file:
ssl_sock_switchctx_cbk	src/ssl_sock.c	/^static int ssl_sock_switchctx_cbk(SSL *ssl, int *al, struct bind_conf *s)$/;"	f	file:
ssl_sock_to_buf	src/ssl_sock.c	/^static int ssl_sock_to_buf(struct connection *conn, struct buffer *buf, int count)$/;"	f	file:
ssl_sock_update_ocsp_response	src/ssl_sock.c	/^int ssl_sock_update_ocsp_response(struct chunk *ocsp_response, char **err)$/;"	f
sslcachesize	include/types/global.h	/^		int sslcachesize;  \/* SSL cache size in session, defaults to 20000 *\/$/;"	m	struct:global::__anon95
sslconns	src/ssl_sock.c	/^int sslconns = 0;$/;"	v
ssllifetime	include/types/global.h	/^		unsigned int ssllifetime;   \/* SSL session lifetime in seconds *\/$/;"	m	struct:global::__anon95
sslprivatecache	include/types/global.h	/^		int sslprivatecache; \/* Force to use a private session cache even if nbproc > 1 *\/$/;"	m	struct:global::__anon95
sslv3_client_hello_pkt	src/cfgparse.c	/^const char sslv3_client_hello_pkt[] = {$/;"	v
st	include/types/proto_http.h	/^		} st;                          \/* status line : field, length *\/$/;"	m	union:http_msg::__anon64	typeref:struct:http_msg::__anon64::__anon66
st0	include/types/stream_interface.h	/^	unsigned int st0;          \/* CLI state for stats, session state for peers *\/$/;"	m	struct:appctx
st1	include/types/stream_interface.h	/^	unsigned int st1;          \/* prompt for stats, session error for peers *\/$/;"	m	struct:appctx
st2	include/types/stream_interface.h	/^	unsigned int st2;          \/* output state for stats, unused by peers  *\/$/;"	m	struct:appctx
st_cnt	contrib/halog/halog.c	/^	unsigned int st_cnt[6]; \/* 0xx to 5xx *\/$/;"	m	struct:srv_st	file:
st_code	include/types/stream_interface.h	/^			int st_code;		\/* the status code returned by an action *\/$/;"	m	struct:appctx::__anon43::__anon44
start	include/types/checks.h	/^	struct timeval start;			\/* last health check start time *\/$/;"	m	struct:check	typeref:struct:check::timeval
start_check_task	src/checks.c	/^static int start_check_task(struct check *check, int mininter,$/;"	f	file:
start_checks	src/checks.c	/^int start_checks() {$/;"	f
start_date	src/time.c	/^struct timeval start_date;      \/* the process's start date *\/$/;"	v	typeref:struct:timeval
start_proxies	src/proxy.c	/^int start_proxies(int verbose)$/;"	f
stat_scope	include/common/uri_auth.h	/^struct stat_scope {$/;"	s
stat_status_codes	src/proto_http.c	/^const char *stat_status_codes[STAT_STATUS_SIZE] = {$/;"	v
state	include/types/checks.h	/^	int state;				\/* state of the check : CHK_ST_*   *\/$/;"	m	struct:check
state	include/types/fd.h	/^	unsigned char state;                 \/* FD state for read and write directions (2*3 bits) *\/$/;"	m	struct:fdtab
state	include/types/lb_map.h	/^	int state;		\/* LB_MAP_RECALC *\/$/;"	m	struct:lb_map
state	include/types/listener.h	/^	enum li_state state;            \/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL *\/$/;"	m	struct:listener	typeref:enum:listener::li_state
state	include/types/peers.h	/^	int state;			 \/* proxy state *\/$/;"	m	struct:peers
state	include/types/proxy.h	/^	enum pr_state state;                    \/* proxy state, one of PR_* *\/$/;"	m	struct:proxy	typeref:enum:proxy::pr_state
state	include/types/proxy.h	/^	unsigned int state;		\/* message state before the error (when saved) *\/$/;"	m	struct:error_snapshot
state	include/types/server.h	/^	enum srv_state state, prev_state;       \/* server state among SRV_ST_* *\/$/;"	m	struct:server	typeref:enum:server::srv_state
state	include/types/stream_interface.h	/^	enum si_state state;     \/* SI_ST* *\/$/;"	m	struct:stream_interface	typeref:enum:stream_interface::si_state
state	include/types/task.h	/^	unsigned short state;		\/* task state : bit field of TASK_* *\/$/;"	m	struct:task
static_hdr_ctx	src/proto_http.c	/^static struct hdr_ctx static_hdr_ctx;$/;"	v	typeref:struct:hdr_ctx	file:
static_pattern	src/pattern.c	/^static struct pattern static_pattern;$/;"	v	typeref:struct:pattern	file:
static_table_key	src/stick_table.c	/^struct stktable_key *static_table_key;$/;"	v	typeref:struct:stktable_key
stats	include/types/stream_interface.h	/^		} stats;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon44
stats_accept	src/dumpstats.c	/^static int stats_accept(struct session *s)$/;"	f	file:
stats_add_auth	src/uri_auth.c	/^struct uri_auth *stats_add_auth(struct uri_auth **root, char *user)$/;"	f
stats_add_scope	src/uri_auth.c	/^struct uri_auth *stats_add_scope(struct uri_auth **root, char *scope)$/;"	f
stats_admin_rule	include/common/uri_auth.h	/^struct stats_admin_rule {$/;"	s
stats_check_init_uri_auth	src/uri_auth.c	/^struct uri_auth *stats_check_init_uri_auth(struct uri_auth **root)$/;"	f
stats_check_uri	src/proto_http.c	/^int stats_check_uri(struct stream_interface *si, struct http_txn *txn, struct proxy *backend)$/;"	f
stats_dump_be_stats	src/dumpstats.c	/^static int stats_dump_be_stats(struct stream_interface *si, struct proxy *px, int flags)$/;"	f	file:
stats_dump_csv_header	src/dumpstats.c	/^static void stats_dump_csv_header()$/;"	f	file:
stats_dump_errors_to_buffer	src/dumpstats.c	/^static int stats_dump_errors_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_fe_stats	src/dumpstats.c	/^static int stats_dump_fe_stats(struct stream_interface *si, struct proxy *px)$/;"	f	file:
stats_dump_full_sess_to_buffer	src/dumpstats.c	/^static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct session *sess)$/;"	f	file:
stats_dump_html_end	src/dumpstats.c	/^static void stats_dump_html_end()$/;"	f	file:
stats_dump_html_head	src/dumpstats.c	/^static void stats_dump_html_head(struct uri_auth *uri)$/;"	f	file:
stats_dump_html_info	src/dumpstats.c	/^static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *uri)$/;"	f	file:
stats_dump_html_px_end	src/dumpstats.c	/^static void stats_dump_html_px_end(struct stream_interface *si, struct proxy *px)$/;"	f	file:
stats_dump_html_px_hdr	src/dumpstats.c	/^static void stats_dump_html_px_hdr(struct stream_interface *si, struct proxy *px, struct uri_auth *uri)$/;"	f	file:
stats_dump_info_to_buffer	src/dumpstats.c	/^static int stats_dump_info_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_li_stats	src/dumpstats.c	/^static int stats_dump_li_stats(struct stream_interface *si, struct proxy *px, struct listener *l, int flags)$/;"	f	file:
stats_dump_pools_to_buffer	src/dumpstats.c	/^static int stats_dump_pools_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_proxy_to_buffer	src/dumpstats.c	/^static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy *px, struct uri_auth *uri)$/;"	f	file:
stats_dump_sess_to_buffer	src/dumpstats.c	/^static int stats_dump_sess_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_stat_to_buffer	src/dumpstats.c	/^static int stats_dump_stat_to_buffer(struct stream_interface *si, struct uri_auth *uri)$/;"	f	file:
stats_dump_sv_stats	src/dumpstats.c	/^static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, int flags, struct server *sv, int state)$/;"	f	file:
stats_dump_table_entry_to_buffer	src/dumpstats.c	/^static int stats_dump_table_entry_to_buffer(struct chunk *msg, struct stream_interface *si,$/;"	f	file:
stats_dump_table_head_to_buffer	src/dumpstats.c	/^static int stats_dump_table_head_to_buffer(struct chunk *msg, struct stream_interface *si,$/;"	f	file:
stats_fe	include/types/global.h	/^	struct proxy *stats_fe;     \/* the frontend holding the stats settings *\/$/;"	m	struct:global	typeref:struct:global::proxy
stats_map_lookup	src/dumpstats.c	/^static int stats_map_lookup(struct stream_interface *si)$/;"	f	file:
stats_parse_global	src/dumpstats.c	/^static int stats_parse_global(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
stats_pat_list	src/dumpstats.c	/^static int stats_pat_list(struct stream_interface *si)$/;"	f	file:
stats_pats_list	src/dumpstats.c	/^static int stats_pats_list(struct stream_interface *si)$/;"	f	file:
stats_permission_denied_msg	src/dumpstats.c	/^static const char stats_permission_denied_msg[] =$/;"	v	file:
stats_process_http_post	src/dumpstats.c	/^static int stats_process_http_post(struct stream_interface *si)$/;"	f	file:
stats_send_http_headers	src/dumpstats.c	/^static int stats_send_http_headers(struct stream_interface *si)$/;"	f	file:
stats_send_http_redirect	src/dumpstats.c	/^static int stats_send_http_redirect(struct stream_interface *si)$/;"	f	file:
stats_set_desc	src/uri_auth.c	/^struct uri_auth *stats_set_desc(struct uri_auth **root, char *desc)$/;"	f
stats_set_flag	src/uri_auth.c	/^struct uri_auth *stats_set_flag(struct uri_auth **root, int flag)$/;"	f
stats_set_node	src/uri_auth.c	/^struct uri_auth *stats_set_node(struct uri_auth **root, char *name)$/;"	f
stats_set_realm	src/uri_auth.c	/^struct uri_auth *stats_set_realm(struct uri_auth **root, char *realm)$/;"	f
stats_set_refresh	src/uri_auth.c	/^struct uri_auth *stats_set_refresh(struct uri_auth **root, int interval)$/;"	f
stats_set_uri	src/uri_auth.c	/^struct uri_auth *stats_set_uri(struct uri_auth **root, char *uri)$/;"	f
stats_sock_parse_request	src/dumpstats.c	/^static int stats_sock_parse_request(struct stream_interface *si, char *line)$/;"	f	file:
stats_sock_table_data_request	src/dumpstats.c	/^static void stats_sock_table_data_request(struct stream_interface *si, char **args, int action)$/;"	f	file:
stats_sock_table_key_request	src/dumpstats.c	/^static void stats_sock_table_key_request(struct stream_interface *si, char **args, int action)$/;"	f	file:
stats_sock_table_request	src/dumpstats.c	/^static void stats_sock_table_request(struct stream_interface *si, char **args, int action)$/;"	f	file:
stats_sock_usage_msg	src/dumpstats.c	/^static const char stats_sock_usage_msg[] =$/;"	v	file:
stats_table_request	src/dumpstats.c	/^static int stats_table_request(struct stream_interface *si, int action)$/;"	f	file:
status	include/types/checks.h	/^	short status, code;			\/* check result, check code *\/$/;"	m	struct:check
status	include/types/proto_http.h	/^	short status;                   \/* HTTP status from the server, negative if from proxy *\/$/;"	m	struct:http_txn
statuscode	include/types/peers.h	/^	unsigned int statuscode;      \/* current\/last session status code *\/$/;"	m	struct:peer_session
std_t_frqp	include/types/stick_table.h	/^	struct freq_ctr_period std_t_frqp;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
std_t_sint	include/types/stick_table.h	/^	int std_t_sint;$/;"	m	union:stktable_data
std_t_uint	include/types/stick_table.h	/^	unsigned int std_t_uint;$/;"	m	union:stktable_data
std_t_ull	include/types/stick_table.h	/^	unsigned long long std_t_ull;$/;"	m	union:stktable_data
std_type	include/types/stick_table.h	/^	int std_type;     \/* standard type we can use for this data, STD_T_* *\/$/;"	m	struct:stktable_data_type
sticking_rule	include/types/proxy.h	/^struct sticking_rule {$/;"	s
sticking_rules	include/types/proxy.h	/^	struct list sticking_rules;             \/* content sticking rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
stkctr	include/types/session.h	/^	struct stkctr stkctr[MAX_SESS_STKCTR];  \/* stick counters *\/$/;"	m	struct:session	typeref:struct:session::stkctr
stkctr	include/types/session.h	/^struct stkctr {$/;"	s
stkctr_clr_flags	include/proto/session.h	/^static inline void stkctr_clr_flags(struct stkctr *stkctr, unsigned int flags)$/;"	f
stkctr_entry	include/proto/session.h	/^static inline struct stksess *stkctr_entry(struct stkctr *stkctr)$/;"	f
stkctr_flags	include/proto/session.h	/^static inline unsigned int stkctr_flags(struct stkctr *stkctr)$/;"	f
stkctr_set_entry	include/proto/session.h	/^static inline void stkctr_set_entry(struct stkctr *stkctr, struct stksess *entry)$/;"	f
stkctr_set_flags	include/proto/session.h	/^static inline void stkctr_set_flags(struct stkctr *stkctr, unsigned int flags)$/;"	f
stksess	include/types/stick_table.h	/^struct stksess {$/;"	s
stksess_free	src/stick_table.c	/^void stksess_free(struct stktable *t, struct stksess *ts)$/;"	f
stksess_init	src/stick_table.c	/^static struct stksess *stksess_init(struct stktable *t, struct stksess * ts)$/;"	f	file:
stksess_kill	src/stick_table.c	/^void stksess_kill(struct stktable *t, struct stksess *ts)$/;"	f
stksess_kill_if_expired	include/proto/stick_table.h	/^static inline void stksess_kill_if_expired(struct stktable *t, struct stksess *ts)$/;"	f
stksess_new	src/stick_table.c	/^struct stksess *stksess_new(struct stktable *t, struct stktable_key *key)$/;"	f
stksess_setkey	src/stick_table.c	/^void stksess_setkey(struct stktable *t, struct stksess *ts, struct stktable_key *key)$/;"	f
stktable	include/types/stick_table.h	/^struct stktable {$/;"	s
stktable_alloc_data_type	include/proto/stick_table.h	/^static inline int stktable_alloc_data_type(struct stktable *t, int type, const char *sa)$/;"	f
stktable_compatible_sample	src/stick_table.c	/^int stktable_compatible_sample(struct sample_expr *expr, unsigned long table_type)$/;"	f
stktable_data	include/types/stick_table.h	/^union stktable_data {$/;"	u
stktable_data_cast	include/proto/stick_table.h	32;"	d
stktable_data_ptr	include/proto/stick_table.h	/^static inline void *stktable_data_ptr(struct stktable *t, struct stksess *ts, int type)$/;"	f
stktable_data_size	include/proto/stick_table.h	31;"	d
stktable_data_type	include/types/stick_table.h	/^struct stktable_data_type {$/;"	s
stktable_data_types	src/stick_table.c	/^struct stktable_data_type stktable_data_types[STKTABLE_DATA_TYPES] = {$/;"	v	typeref:struct:stktable_data_type
stktable_fetch_key	src/stick_table.c	/^struct stktable_key *stktable_fetch_key(struct stktable *t, struct proxy *px, struct session *l4, void *l7,$/;"	f
stktable_get_data_type	src/stick_table.c	/^int stktable_get_data_type(char *name)$/;"	f
stktable_get_entry	src/stick_table.c	/^struct stksess *stktable_get_entry(struct stktable *table, struct stktable_key *key)$/;"	f
stktable_init	src/stick_table.c	/^int stktable_init(struct stktable *t)$/;"	f
stktable_key	include/types/stick_table.h	/^struct stktable_key {$/;"	s
stktable_key_data	include/types/stick_table.h	/^union stktable_key_data {$/;"	u
stktable_lookup	src/stick_table.c	/^struct stksess *stktable_lookup(struct stktable *t, struct stksess *ts)$/;"	f
stktable_lookup_key	src/stick_table.c	/^struct stksess *stktable_lookup_key(struct stktable *t, struct stktable_key *key)$/;"	f
stktable_parse_type	src/stick_table.c	/^int stktable_parse_type(char **args, int *myidx, unsigned long *type, size_t *key_size)$/;"	f
stktable_store	src/stick_table.c	/^struct stksess *stktable_store(struct stktable *t, struct stksess *ts, int local)$/;"	f
stktable_touch	src/stick_table.c	/^struct stksess *stktable_touch(struct stktable *t, struct stksess *ts, int local)$/;"	f
stktable_trash_expired	src/stick_table.c	/^static int stktable_trash_expired(struct stktable *t)$/;"	f	file:
stktable_trash_oldest	src/stick_table.c	/^int stktable_trash_oldest(struct stktable *t, int to_batch)$/;"	f
stktable_type	include/types/stick_table.h	/^struct stktable_type {$/;"	s
stktable_type_size	include/proto/stick_table.h	/^static inline int stktable_type_size(int type)$/;"	f
stktable_types	src/stick_table.c	/^struct stktable_type stktable_types[STKTABLE_TYPES] =  {{ "ip", 0, 4 },$/;"	v	typeref:struct:stktable_type
stktable_update_key	src/stick_table.c	/^struct stksess *stktable_update_key(struct stktable *table, struct stktable_key *key)$/;"	f
stop_proxy	src/proxy.c	/^void stop_proxy(struct proxy *p)$/;"	f
stop_time	include/types/proxy.h	/^	int stop_time;                          \/* date to stop listening, when stopping != 0 (int ticks) *\/$/;"	m	struct:proxy
stopping	src/haproxy.c	/^int stopping;	\/* non zero means stopping in progress *\/$/;"	v
store	include/types/session.h	/^	} store[8];				\/* tracked stickiness values to store *\/$/;"	m	struct:session	typeref:struct:session::__anon54
store_count	include/types/session.h	/^	int store_count;$/;"	m	struct:session
storersp_rules	include/types/proxy.h	/^	struct list storersp_rules;             \/* content store response rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
str	include/common/chunk.h	/^	char *str;	\/* beginning of the string itself. Might not be 0-terminated *\/$/;"	m	struct:chunk
str	include/types/arg.h	/^	struct chunk str;$/;"	m	union:arg_data	typeref:struct:arg_data::chunk
str	include/types/pattern.h	/^		char *str;              \/* any string  *\/$/;"	m	union:pattern::__anon14
str	include/types/sample.h	/^		struct chunk    str;   \/* used for char strings or buffers *\/$/;"	m	union:sample::__anon92	typeref:struct:sample::__anon92::chunk
str	include/types/sample.h	/^		struct chunk    str;   \/* used for char strings or buffers *\/$/;"	m	union:sample_storage::__anon93	typeref:struct:sample_storage::__anon93::chunk
str	include/types/sample.h	/^	struct chunk str;$/;"	m	struct:meth	typeref:struct:meth::chunk
str2ic	contrib/halog/halog.c	/^int str2ic(const char *s)$/;"	f
str2ip	src/standard.c	/^static struct sockaddr_storage *str2ip(const char *str, struct sockaddr_storage *sa)$/;"	f	file:
str2listener	src/cfgparse.c	/^int str2listener(char *str, struct proxy *curproxy, struct bind_conf *bind_conf, const char *file, int line, char **err)$/;"	f
str2mask	src/standard.c	/^int str2mask(const char *str, struct in_addr *mask)$/;"	f
str2net	src/standard.c	/^int str2net(const char *str, int resolve, struct in_addr *addr, struct in_addr *mask)$/;"	f
str2sa_range	src/standard.c	/^struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char **err, const char *pfx)$/;"	f
str2ui	src/standard.c	/^unsigned int str2ui(const char *s)$/;"	f
str2uic	src/standard.c	/^unsigned int str2uic(const char *s)$/;"	f
str62net	src/standard.c	/^int str62net(const char *str, struct in6_addr *addr, unsigned char *mask)$/;"	f
stream_int_check_timeouts	src/stream_interface.c	/^int stream_int_check_timeouts(struct stream_interface *si)$/;"	f
stream_int_chk_rcv	src/stream_interface.c	/^static void stream_int_chk_rcv(struct stream_interface *si)$/;"	f	file:
stream_int_chk_rcv_conn	src/stream_interface.c	/^static void stream_int_chk_rcv_conn(struct stream_interface *si)$/;"	f	file:
stream_int_chk_snd	src/stream_interface.c	/^static void stream_int_chk_snd(struct stream_interface *si)$/;"	f	file:
stream_int_chk_snd_conn	src/stream_interface.c	/^static void stream_int_chk_snd_conn(struct stream_interface *si)$/;"	f	file:
stream_int_register_handler	src/stream_interface.c	/^struct appctx *stream_int_register_handler(struct stream_interface *si, struct si_applet *app)$/;"	f
stream_int_report_error	src/stream_interface.c	/^void stream_int_report_error(struct stream_interface *si)$/;"	f
stream_int_retnclose	src/stream_interface.c	/^void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg)$/;"	f
stream_int_shutr	src/stream_interface.c	/^static void stream_int_shutr(struct stream_interface *si)$/;"	f	file:
stream_int_shutr_conn	src/stream_interface.c	/^static void stream_int_shutr_conn(struct stream_interface *si)$/;"	f	file:
stream_int_shutw	src/stream_interface.c	/^static void stream_int_shutw(struct stream_interface *si)$/;"	f	file:
stream_int_shutw_conn	src/stream_interface.c	/^static void stream_int_shutw_conn(struct stream_interface *si)$/;"	f	file:
stream_int_unregister_handler	src/stream_interface.c	/^void stream_int_unregister_handler(struct stream_interface *si)$/;"	f
stream_int_update_conn	src/stream_interface.c	/^void stream_int_update_conn(struct stream_interface *si)$/;"	f
stream_int_update_embedded	src/stream_interface.c	/^static void stream_int_update_embedded(struct stream_interface *si)$/;"	f	file:
stream_interface	include/types/stream_interface.h	/^struct stream_interface {$/;"	s
stream_sock_read0	src/stream_interface.c	/^void stream_sock_read0(struct stream_interface *si)$/;"	f
strict_sni	include/types/listener.h	/^	int strict_sni;            \/* refuse negotiation if sni doesn't match a certificate *\/$/;"	m	struct:bind_conf
string	include/types/checks.h	/^	char *string;                           \/* sent or expected string *\/$/;"	m	struct:tcpcheck_rule
string_equal_bits	ebtree/ebtree.h	/^static forceinline int string_equal_bits(const unsigned char *a,$/;"	f
string_len	include/types/checks.h	/^	int string_len;                         \/* string lenght *\/$/;"	m	struct:tcpcheck_rule
strl2ic	src/standard.c	/^int strl2ic(const char *s, int len)$/;"	f
strl2irc	src/standard.c	/^int strl2irc(const char *s, int len, int *ret)$/;"	f
strl2llrc	src/standard.c	/^int strl2llrc(const char *s, int len, long long *ret)$/;"	f
strl2llrc_dotted	src/standard.c	/^int strl2llrc_dotted(const char *text, int len, long long *ret)$/;"	f
strl2ui	contrib/halog/halog.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f
strl2ui	src/standard.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f
strl2uic	src/standard.c	/^unsigned int strl2uic(const char *s, int len)$/;"	f
strlcpy2	src/standard.c	/^int strlcpy2(char *dst, const char *src, int size)$/;"	f
strm	include/types/compression.h	/^	z_stream strm; \/* zlib stream *\/$/;"	m	struct:comp_ctx
strnistr	src/standard.c	/^const char *strnistr(const char *str1, int len_str1, const char *str2, int len_str2)$/;"	f
sub_tlv	include/types/connection.h	/^	uint8_t sub_tlv[0];$/;"	m	struct:tlv_ssl
suites	include/types/acl.h	/^	struct list suites;         \/* list of acl_term_suites *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list
sv	include/types/stream_interface.h	/^			struct server *sv;$/;"	m	struct:appctx::__anon43::__anon44	typeref:struct:appctx::__anon43::__anon44::server
sw	tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
swap_buffer	src/haproxy.c	/^char *swap_buffer = NULL;$/;"	v
switch_trees	tests/filltab25.c	/^void switch_trees() {$/;"	f
switching_rule	include/types/proxy.h	/^struct switching_rule {$/;"	s
switching_rules	include/types/proxy.h	/^	struct list switching_rules;            \/* content switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
swrate_add	include/proto/freq_ctr.h	/^static inline unsigned int swrate_add(unsigned int *sum, unsigned int n, unsigned int v)$/;"	f
swrate_avg	include/proto/freq_ctr.h	/^static inline unsigned int swrate_avg(unsigned int sum, unsigned int n)$/;"	f
sync_task	include/types/peers.h	/^	struct task *sync_task;		    \/* main sync task *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::task
sync_task	include/types/stick_table.h	/^	struct task *sync_task;   \/* sync task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task
syncing	include/types/stick_table.h	/^	unsigned int syncing;     \/* number of sync tasks watching this table now *\/$/;"	m	struct:stktable
t	include/types/connection.h	/^	} t;$/;"	m	struct:connection	typeref:union:connection::__anon78
t	include/types/proxy.h	/^		struct stktable *t;	        \/* target table *\/$/;"	m	union:sticking_rule::__anon22	typeref:struct:sticking_rule::__anon22::stktable
t	include/types/session.h	/^		struct stktable *t;		\/* a pointer to the table *\/$/;"	m	union:track_ctr_prm::__anon56	typeref:struct:track_ctr_prm::__anon56::stktable
t0	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
t1	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::
t_close	include/types/session.h	/^		unsigned long t_close;		\/* total session duration *\/$/;"	m	struct:session::__anon55
t_connect	include/types/session.h	/^		long  t_connect;		\/* delay before the connect() to the server succeeds, -1 if never occurs *\/$/;"	m	struct:session::__anon55
t_data	include/types/session.h	/^		long  t_data;			\/* delay before the first data byte from the server ... *\/$/;"	m	struct:session::__anon55
t_flags	include/types/proxy.h	/^	unsigned int t_flags;		\/* transaction flags *\/$/;"	m	struct:error_snapshot
t_queue	include/types/session.h	/^		long  t_queue;			\/* delay before the session gets out of the connect queue, -1 if never occurs *\/$/;"	m	struct:session::__anon55
t_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
t_time	include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
table	include/common/sessionhash.h	/^	struct list *table;$/;"	m	struct:appsession_hash	typeref:struct:appsession_hash::list
table	include/types/peers.h	/^	struct shared_table *table;   \/* shared table *\/$/;"	m	struct:peer_session	typeref:struct:peer_session::shared_table
table	include/types/peers.h	/^	struct stktable *table;		    \/* stick table to sync *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::stktable
table	include/types/proxy.h	/^	struct stktable table;			\/* table for storing sticking sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::stktable
table	include/types/proxy.h	/^	} table;$/;"	m	struct:sticking_rule	typeref:union:sticking_rule::__anon22
table	include/types/session.h	/^		struct stktable *table;$/;"	m	struct:session::__anon54	typeref:struct:session::__anon54::stktable
table	include/types/session.h	/^	struct stktable *table;         \/* table the counters above belong to (undefined if counters are null) *\/$/;"	m	struct:stkctr	typeref:struct:stkctr::stktable
table	include/types/session.h	/^	} table;$/;"	m	struct:track_ctr_prm	typeref:union:track_ctr_prm::__anon56
table	include/types/stream_interface.h	/^		} table;$/;"	m	union:appctx::__anon43	typeref:struct:appctx::__anon43::__anon47
tables	include/types/peers.h	/^	struct shared_table *tables;	 \/* registered shared tables *\/$/;"	m	struct:peers	typeref:struct:peers::shared_table
tail	include/types/hdr_idx.h	/^	signed short tail;          \/* last used element, 0..size-1 *\/$/;"	m	struct:hdr_idx
target	include/types/connection.h	/^	enum obj_type *target;        \/* the target to connect to (server, proxy, applet, ...) *\/$/;"	m	struct:connection	typeref:enum:connection::obj_type
target	include/types/session.h	/^	enum obj_type *target;			\/* target to use for this session ; for mini-sess: incoming connection *\/$/;"	m	struct:session	typeref:enum:session::obj_type
target	include/types/stream_interface.h	/^			void *target;		\/* session we want to dump, or NULL for all *\/$/;"	m	struct:appctx::__anon43::__anon45
target	include/types/stream_interface.h	/^			void *target;		\/* table we want to dump, or NULL for all *\/$/;"	m	struct:appctx::__anon43::__anon47
tarpit	include/types/proxy.h	/^		int tarpit;                     \/* tarpit timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon18
task	include/types/checks.h	/^	struct task *task;			\/* the task associated to the health check processing, NULL if disabled *\/$/;"	m	struct:check	typeref:struct:check::task
task	include/types/proxy.h	/^	struct task *task;			\/* the associated task, mandatory to manage rate limiting, stopping and resource shortage, NULL if disabled *\/$/;"	m	struct:proxy	typeref:struct:proxy::task
task	include/types/session.h	/^	struct task *task;			\/* the task associated with this session *\/$/;"	m	struct:session	typeref:struct:session::task
task	include/types/task.h	/^struct task {$/;"	s
task_delete	include/proto/task.h	/^static inline struct task *task_delete(struct task *t)$/;"	f
task_free	include/proto/task.h	/^static inline void task_free(struct task *t)$/;"	f
task_in_rq	include/proto/task.h	/^static inline int task_in_rq(struct task *t)$/;"	f
task_in_wq	include/proto/task.h	/^static inline int task_in_wq(struct task *t)$/;"	f
task_init	include/proto/task.h	/^static inline struct task *task_init(struct task *t)$/;"	f
task_new	include/proto/task.h	/^static inline struct task *task_new(void)$/;"	f
task_queue	include/proto/task.h	/^static inline void task_queue(struct task *task)$/;"	f
task_schedule	include/proto/task.h	/^static inline void task_schedule(struct task *task, int when)$/;"	f
task_unlink_rq	include/proto/task.h	/^static inline struct task *task_unlink_rq(struct task *t)$/;"	f
task_unlink_wq	include/proto/task.h	/^static inline struct task *task_unlink_wq(struct task *t)$/;"	f
task_wakeup	include/proto/task.h	/^static inline struct task *task_wakeup(struct task *t, unsigned int f)$/;"	f
tcp_bind_listener	src/proto_tcp.c	/^int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f
tcp_bind_listeners	src/proto_tcp.c	/^static int tcp_bind_listeners(struct protocol *proto, char *errmsg, int errlen)$/;"	f	file:
tcp_bind_socket	src/proto_tcp.c	/^int tcp_bind_socket(int fd, int flags, struct sockaddr_storage *local, struct sockaddr_storage *remote)$/;"	f
tcp_connect_probe	src/proto_tcp.c	/^int tcp_connect_probe(struct connection *conn)$/;"	f
tcp_connect_server	src/proto_tcp.c	/^int tcp_connect_server(struct connection *conn, int data, int delack)$/;"	f
tcp_drain	src/proto_tcp.c	/^int tcp_drain(int fd)$/;"	f
tcp_exec_req_rules	src/proto_tcp.c	/^int tcp_exec_req_rules(struct session *s)$/;"	f
tcp_get_dst	src/proto_tcp.c	/^int tcp_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
tcp_get_src	src/proto_tcp.c	/^int tcp_get_src(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
tcp_inspect_request	src/proto_tcp.c	/^int tcp_inspect_request(struct session *s, struct channel *req, int an_bit)$/;"	f
tcp_inspect_response	src/proto_tcp.c	/^int tcp_inspect_response(struct session *s, struct channel *rep, int an_bit)$/;"	f
tcp_parse_request_rule	src/proto_tcp.c	/^static int tcp_parse_request_rule(char **args, int arg, int section_type,$/;"	f	file:
tcp_parse_response_rule	src/proto_tcp.c	/^static int tcp_parse_response_rule(char **args, int arg, int section_type,$/;"	f	file:
tcp_parse_tcp_rep	src/proto_tcp.c	/^static int tcp_parse_tcp_rep(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
tcp_parse_tcp_req	src/proto_tcp.c	/^static int tcp_parse_tcp_req(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
tcp_persist_rdp_cookie	src/backend.c	/^int tcp_persist_rdp_cookie(struct session *s, struct channel *req, int an_bit)$/;"	f
tcp_rep	include/types/proxy.h	/^	} tcp_rep;$/;"	m	struct:proxy	typeref:struct:proxy::__anon17
tcp_req	include/types/proxy.h	/^	} tcp_req;$/;"	m	struct:proxy	typeref:struct:proxy::__anon16
tcp_rule	include/types/proto_tcp.h	/^struct tcp_rule {$/;"	s
tcp_trk_idx	include/proto/proto_tcp.h	/^static inline int tcp_trk_idx(int trk_action)$/;"	f
tcpcheck_get_step_id	src/checks.c	/^static int tcpcheck_get_step_id(struct server *s)$/;"	f	file:
tcpcheck_main	src/checks.c	/^static void tcpcheck_main(struct connection *conn)$/;"	f	file:
tcpcheck_rule	include/types/checks.h	/^struct tcpcheck_rule {$/;"	s
tcpcheck_rules	include/types/proxy.h	/^	struct list tcpcheck_rules;		\/* tcp-check send \/ expect rules *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
tcpv4_add_listener	src/proto_tcp.c	/^void tcpv4_add_listener(struct listener *listener)$/;"	f
tcpv6_add_listener	src/proto_tcp.c	/^void tcpv6_add_listener(struct listener *listener)$/;"	f
teaching_origin	include/types/peers.h	/^	unsigned int teaching_origin; \/* resync teaching origine update *\/$/;"	m	struct:peer_session
tell_old_pids	src/haproxy.c	/^static int tell_old_pids(int sig)$/;"	f	file:
temp_smp	src/sample.c	/^static struct sample temp_smp;$/;"	v	typeref:struct:sample	file:
term	include/types/fd.h	/^	void REGPRM1   (*term)(struct poller *p);            \/* termination of this poller *\/$/;"	m	struct:poller
terms	include/types/acl.h	/^	struct list terms;          \/* list of acl_terms *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list
test	include/types/fd.h	/^	int  REGPRM1   (*test)(struct poller *p);            \/* pre-init check of the poller *\/$/;"	m	struct:poller
test_speed1	tests/test_pools.c	/^static bool test_speed1(void)$/;"	f	file:
text	src/proto_http.c	/^	const char text[8];$/;"	m	struct:http_method_desc	file:
tick_add	include/common/ticks.h	/^static inline int tick_add(int now, int timeout)$/;"	f
tick_add_ifset	include/common/ticks.h	/^static inline int tick_add_ifset(int now, int timeout)$/;"	f
tick_first	include/common/ticks.h	/^static inline int tick_first(int t1, int t2)$/;"	f
tick_first_2nz	include/common/ticks.h	/^static inline int tick_first_2nz(int t1, int t2)$/;"	f
tick_is_expired	include/common/ticks.h	/^static inline int tick_is_expired(int timer, int now)$/;"	f
tick_is_le	include/common/ticks.h	/^static inline int tick_is_le(int t1, int t2)$/;"	f
tick_is_lt	include/common/ticks.h	/^static inline int tick_is_lt(int t1, int t2)$/;"	f
tick_isset	include/common/ticks.h	/^static inline int tick_isset(int expire)$/;"	f
tick_remain	include/common/ticks.h	/^static inline int tick_remain(int now, int exp)$/;"	f
time	include/types/pattern.h	/^		struct pat_time time;           \/* valid hours and days *\/$/;"	m	union:pattern::__anon10	typeref:struct:pattern::__anon10::pat_time
timeout	include/types/listener.h	/^	int  *timeout;                  \/* pointer to client-side timeout *\/$/;"	m	struct:listener
timeout	include/types/proxy.h	/^	} timeout;$/;"	m	struct:proxy	typeref:struct:proxy::__anon18
timer	contrib/halog/halog.c	/^struct timer {$/;"	s	file:
timers	contrib/halog/halog.c	/^static struct eb_root timers[5] = {$/;"	v	typeref:struct:eb_root	file:
timers	src/task.c	/^static struct eb_root timers;      \/* sorted timers tree *\/$/;"	v	typeref:struct:eb_root	file:
timeval_current	tests/test_hashes.c	/^static struct timeval timeval_current(void)$/;"	f	file:
timeval_current	tests/test_pools.c	/^static struct timeval timeval_current(void)$/;"	f	file:
timeval_elapsed	tests/test_hashes.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:
timeval_elapsed	tests/test_pools.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:
tlv	include/types/connection.h	/^	struct tlv tlv;$/;"	m	struct:tlv_ssl	typeref:struct:tlv_ssl::tlv
tlv	include/types/connection.h	/^struct tlv {$/;"	s
tlv_ssl	include/types/connection.h	/^struct tlv_ssl {$/;"	s
tmp_evts	src/ev_select.c	/^static fd_set *tmp_evts[2];$/;"	v	file:
to	include/types/connection.h	/^		struct sockaddr_storage to;	\/* address reached by the client, or address to connect to *\/$/;"	m	struct:connection::__anon80	typeref:struct:connection::__anon80::sockaddr_storage
to_forward	include/types/channel.h	/^	unsigned int to_forward;        \/* number of bytes to forward after out without a wake-up *\/$/;"	m	struct:channel
to_log	include/types/proxy.h	/^	int to_log;				\/* things to be logged (LW_*) *\/$/;"	m	struct:proxy
torture_assert	tests/test_pools.c	31;"	d	file:
torture_assert_str_equal	tests/test_pools.c	37;"	d	file:
tos	include/types/proto_http.h	/^		int tos;                       \/* tos value for HTTP_REQ_ACT_SET_TOS *\/$/;"	m	union:http_req_rule::__anon67
tos	include/types/proto_http.h	/^		int tos;                       \/* tos value for HTTP_RES_ACT_SET_TOS *\/$/;"	m	union:http_res_rule::__anon71
tot_used	include/types/backend.h	/^	int tot_used;			\/* total number of servers used for LB *\/$/;"	m	struct:lbprm
tot_wact	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm
tot_wbck	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm
tot_weight	include/types/backend.h	/^	int tot_weight;			\/* total effective weight of servers participating to LB *\/$/;"	m	struct:lbprm
total	include/types/channel.h	/^	unsigned long long total;       \/* total data read *\/$/;"	m	struct:channel
total_bytes_sent	contrib/halog/halog.c	/^	unsigned long long total_bytes_sent; \/* sum(all bytes sent) *\/$/;"	m	struct:url_stat	file:
total_time	contrib/halog/halog.c	/^	unsigned long long total_time;    \/* sum(all reqs' times) *\/$/;"	m	struct:url_stat	file:
total_time_ok	contrib/halog/halog.c	/^	unsigned long long total_time_ok; \/* sum(all OK reqs' times) *\/$/;"	m	struct:url_stat	file:
totalconn	src/fd.c	/^int totalconn;                  \/* total # of terminated sessions *\/$/;"	v
totalsslconns	src/ssl_sock.c	/^int totalsslconns = 0;$/;"	v
totpend	include/types/proxy.h	/^	int totpend;				\/* total number of pending connections on this instance (for stats) *\/$/;"	m	struct:proxy
tproxy_addr	include/types/connection.h	/^	struct sockaddr_storage tproxy_addr; \/* non-local address we want to bind to for connect() *\/$/;"	m	struct:conn_src	typeref:struct:conn_src::sockaddr_storage
trace_now	src/trace.c	/^static struct timeval trace_now;$/;"	v	typeref:struct:timeval	file:
track	include/types/server.h	/^	struct server *track;                   \/* the server we're currently tracking, if any *\/$/;"	m	struct:server	typeref:struct:server::server
track_ctr_prm	include/types/session.h	/^struct track_ctr_prm {$/;"	s
trackers	include/types/server.h	/^	struct server *trackers;                \/* the list of servers tracking us, if any *\/$/;"	m	struct:server	typeref:struct:server::server
trackit	include/types/server.h	/^	char *trackit;				\/* temporary variable to make assignment deferrable *\/$/;"	m	struct:server
tracknext	include/types/server.h	/^	struct server *tracknext;               \/* next server tracking <track> in <track>'s trackers list *\/$/;"	m	struct:server	typeref:struct:server::server
trash	src/haproxy.c	/^struct chunk trash = { };$/;"	v	typeref:struct:chunk
trash_buf1	src/chunk.c	/^static char *trash_buf1;$/;"	v	file:
trash_buf2	src/chunk.c	/^static char *trash_buf2;$/;"	v	file:
trash_chunk	src/chunk.c	/^static struct chunk *trash_chunk;$/;"	v	typeref:struct:chunk	file:
trash_chunk1	src/chunk.c	/^static struct chunk trash_chunk1;$/;"	v	typeref:struct:chunk	file:
trash_chunk2	src/chunk.c	/^static struct chunk trash_chunk2;$/;"	v	typeref:struct:chunk	file:
trash_size	src/chunk.c	/^static int trash_size;$/;"	v	file:
tree	include/types/pattern.h	/^		struct eb_root *tree;           \/* tree storing all values if any *\/$/;"	m	union:pattern::__anon10	typeref:struct:pattern::__anon10::eb_root
tree	tests/filltab25.c	/^	struct eb_root *tree; \/\/ we want to know where the server is$/;"	m	struct:srv	typeref:struct:srv::eb_root	file:
tree_0	tests/filltab25.c	/^struct eb_root tree_0 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_1	tests/filltab25.c	/^struct eb_root tree_1 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_2	tests/filltab25.c	/^struct eb_root tree_2 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_occ	include/types/server.h	/^struct tree_occ {$/;"	s
trk_ctr	include/types/proto_tcp.h	/^		struct track_ctr_prm trk_ctr;$/;"	m	union:tcp_rule::__anon2	typeref:struct:tcp_rule::__anon2::track_ctr_prm
truncated_line	contrib/halog/halog.c	/^void truncated_line(int linenum, const char *line)$/;"	f
ts	include/types/session.h	/^		struct stksess *ts;$/;"	m	struct:session::__anon54	typeref:struct:session::__anon54::stksess
tune	include/types/global.h	/^	} tune;$/;"	m	struct:global	typeref:struct:global::__anon95
tunnel	include/types/proxy.h	/^		int tunnel;                     \/* I\/O timeout to use in tunnel mode (in ticks) *\/$/;"	m	struct:proxy::__anon18
tv_accept	include/types/session.h	/^		struct timeval tv_accept;	\/* date of the accept() in internal date (monotonic) *\/$/;"	m	struct:session::__anon55	typeref:struct:session::__anon55::timeval
tv_add	include/common/time.h	372;"	d
tv_add_ifset	include/common/time.h	390;"	d
tv_bound	include/common/time.h	511;"	d
tv_eternity	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_eternity(struct timeval *tv)$/;"	f
tv_isbefore	include/common/time.h	485;"	d
tv_iseq	include/common/time.h	194;"	d
tv_iseternity	include/common/time.h	128;"	d
tv_isge	include/common/time.h	213;"	d
tv_isgt	include/common/time.h	202;"	d
tv_isle	include/common/time.h	233;"	d
tv_islt	include/common/time.h	223;"	d
tv_isset	include/common/time.h	133;"	d
tv_iszero	include/common/time.h	138;"	d
tv_min	include/common/time.h	496;"	d
tv_ms_add	include/common/time.h	464;"	d
tv_ms_cmp	include/common/time.h	247;"	d
tv_ms_cmp2	include/common/time.h	275;"	d
tv_ms_elapsed	include/common/time.h	327;"	d
tv_ms_le2	include/common/time.h	295;"	d
tv_ms_remain	include/common/time.h	344;"	d
tv_ms_remain2	include/common/time.h	359;"	d
tv_now	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_now(struct timeval *tv)$/;"	f
tv_remain	include/common/time.h	424;"	d
tv_remain2	include/common/time.h	451;"	d
tv_request	include/types/session.h	/^		struct timeval tv_request;	\/* date the request arrives, {0,0} if never occurs *\/$/;"	m	struct:session::__anon55	typeref:struct:session::__anon55::timeval
tv_update_date	src/time.c	/^REGPRM2 void tv_update_date(int max_wait, int interrupted)$/;"	f
tv_zero	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_zero(struct timeval *tv) {$/;"	f
tws	include/types/proto_http.h	/^	int  tws;  \/* added to vlen if some trailing white spaces are present *\/$/;"	m	struct:hdr_ctx
txn	include/types/session.h	/^	struct http_txn txn;			\/* current HTTP transaction being processed. Should become a list. *\/$/;"	m	struct:session	typeref:struct:session::http_txn
type	include/types/arg.h	/^	unsigned char type;       \/* argument type, ARGT_* *\/$/;"	m	struct:arg
type	include/types/checks.h	/^	int type;				\/* Check type, one of PR_O2_*_CHK *\/$/;"	m	struct:check
type	include/types/connection.h	/^	uint8_t type;$/;"	m	struct:tlv
type	include/types/log.h	/^	int type;      \/\/ LOG_FMT_*$/;"	m	struct:logformat_node
type	include/types/pattern.h	/^	int type;                               \/* type of the ACL pattern (SMP_T_*) *\/$/;"	m	struct:pattern
type	include/types/proxy.h	/^	int type;$/;"	m	struct:persist_rule
type	include/types/proxy.h	/^	int type;$/;"	m	struct:redirect_rule
type	include/types/sample.h	/^	int type;                 \/* SMP_T_* *\/$/;"	m	struct:sample
type	include/types/sample.h	/^	int type;                 \/* SMP_T_* *\/$/;"	m	struct:sample_storage
type	include/types/stick_table.h	/^	unsigned long type;       \/* type of table (determines key format) *\/$/;"	m	struct:stktable
type	include/types/stream_interface.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:appctx::__anon43::__anon44
type	src/log.c	/^	int type;$/;"	m	struct:logformat_type	file:
types	include/types/compression.h	/^	struct comp_type *types;$/;"	m	struct:comp	typeref:struct:comp::comp_type
u	include/types/auth.h	/^	} u;$/;"	m	struct:auth_users	typeref:union:auth_users::__anon31
u	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon64::__anon65
u	include/types/stick_table.h	/^		unsigned int u;$/;"	m	union:stktable::__anon30
u32	ebtree/eb32tree.h	/^typedef unsigned int u32;$/;"	t
u32	include/common/epoll.h	/^		uint32_t u32;$/;"	m	union:epoll_event::__anon104
u64	ebtree/eb64tree.h	/^typedef unsigned long long u64;$/;"	t
u64	include/common/epoll.h	/^		uint64_t u64;$/;"	m	union:epoll_event::__anon104
u_int32_t	tests/uri_hash.c	/^typedef unsigned int u_int32_t;$/;"	t	file:
u_l	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon64::__anon65
ub1	tests/test_hashes.c	/^typedef  unsigned       char ub1;   \/* unsigned 1-byte quantities *\/$/;"	t	file:
ub4	tests/test_hashes.c	/^typedef  unsigned long  int  ub4;   \/* unsigned 4-byte quantities *\/$/;"	t	file:
uid	include/types/global.h	/^			uid_t uid;      \/* -1 to leave unchanged *\/$/;"	m	struct:global::__anon96::__anon97
uid	include/types/global.h	/^	int uid;$/;"	m	struct:global
uid	include/types/listener.h	/^		uid_t uid;         \/* -1 to leave unchanged *\/$/;"	m	struct:bind_conf::__anon51
uid	include/types/stream_interface.h	/^			unsigned int uid;	\/* if non-null, the uniq_id of the session being dumped *\/$/;"	m	struct:appctx::__anon43::__anon45
uif_file	include/types/proxy.h	/^		char *uif_file;                 \/* file name where the unique-id-format string appears (strdup) *\/$/;"	m	struct:proxy::__anon19
uif_line	include/types/proxy.h	/^		int   uif_line;                 \/* file name where the unique-id-format string appears *\/$/;"	m	struct:proxy::__anon19
uint	include/types/arg.h	/^	unsigned int uint; \/* used for uint, time, size *\/$/;"	m	union:arg_data
uint	include/types/sample.h	/^		unsigned int    uint;  \/* used for unsigned 32bits integers and booleans *\/$/;"	m	union:sample::__anon92
uint	include/types/sample.h	/^		unsigned int    uint;  \/* used for unsigned 32bits integers and booleans *\/$/;"	m	union:sample_storage::__anon93
ulltoa	src/standard.c	/^char *ulltoa(unsigned long long n, char *dst, size_t size)$/;"	f
ulltoh_r	src/standard.c	/^const char *ulltoh_r(unsigned long long n, char *buffer, int size)$/;"	f
ultoa	include/common/standard.h	/^static inline const char *ultoa(unsigned long n)$/;"	f
ultoa_o	src/standard.c	/^char *ultoa_o(unsigned long n, char *dst, size_t size)$/;"	f
ultoa_r	src/standard.c	/^char *ultoa_r(unsigned long n, char *buffer, int size)$/;"	f
ultoad2	src/trace.c	/^static char *ultoad2(unsigned int x, char *out, int min_pairs)$/;"	f	file:
unbind_all	include/types/protocol.h	/^	int (*unbind_all)(struct protocol *proto);	\/* unbind all bound listeners *\/$/;"	m	struct:protocol
unbind_all_listeners	src/listener.c	/^int unbind_all_listeners(struct protocol *proto)$/;"	f
unbind_listener	src/listener.c	/^int unbind_listener(struct listener *listener)$/;"	f
uniq_id	include/types/session.h	/^	unsigned int uniq_id;			\/* unique ID used for the traces *\/$/;"	m	struct:session
unique_id	include/types/pattern.h	/^	int unique_id; \/* Each pattern reference have unique id. *\/$/;"	m	struct:pat_ref
unique_id	include/types/session.h	/^	char *unique_id;			\/* custom unique ID *\/$/;"	m	struct:session
uniqueid_format_string	include/types/proxy.h	/^		char *uniqueid_format_string;	\/* unique-id format string *\/$/;"	m	struct:proxy::__anon19
unix_bind	include/types/global.h	/^	} unix_bind;$/;"	m	struct:global	typeref:struct:global::__anon96
unlikely	include/common/compiler.h	102;"	d
unlikely	include/common/compiler.h	91;"	d
unlikely	include/common/compiler.h	95;"	d
unresolved	include/types/arg.h	/^	unsigned char unresolved; \/* argument contains a string in <str> that must be resolved and freed *\/$/;"	m	struct:arg
unx	include/types/connection.h	/^		} unx;$/;"	m	union:proxy_hdr_v2::__anon81	typeref:struct:proxy_hdr_v2::__anon81::__anon84
upd	include/types/stick_table.h	/^	struct eb32_node upd;     \/* ebtree node used to hold the update sequence tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node
upd	src/shctx.c	/^	struct shsess_packet_hdr upd;$/;"	m	struct:shared_context	typeref:struct:shared_context::shsess_packet_hdr	file:
update	include/types/peers.h	/^	unsigned int update;	      \/* current peer acked update *\/$/;"	m	struct:peer_session
update	include/types/stick_table.h	/^	unsigned int update;$/;"	m	struct:stktable
update	include/types/stream_interface.h	/^	void (*update)(struct stream_interface *);  \/* I\/O update function *\/$/;"	m	struct:si_ops
update_backend_weight	src/backend.c	/^void update_backend_weight(struct proxy *px)$/;"	f
update_freq_ctr	include/proto/freq_ctr.h	/^static inline void update_freq_ctr(struct freq_ctr *ctr, unsigned int inc)$/;"	f
update_freq_ctr_period	include/proto/freq_ctr.h	/^static inline void update_freq_ctr_period(struct freq_ctr_period *ctr,$/;"	f
update_log_hdr	src/log.c	/^static char *update_log_hdr()$/;"	f	file:
update_position	tests/filltab25.c	/^void update_position(struct srv *s) {$/;"	f
update_server_eweight	include/types/backend.h	/^	void (*update_server_eweight)(struct server *);  \/* to be called after eweight change *\/$/;"	m	struct:lbprm
updated	include/types/fd.h	/^	unsigned char updated:1;             \/* 1 if this fd is already in the update list *\/$/;"	m	struct:fdtab
updates	include/types/stick_table.h	/^	struct eb_root updates;   \/* head of sticky updates sequence tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
updt_fd	include/proto/fd.h	/^static inline void updt_fd(const int fd)$/;"	f
uri	include/types/proto_http.h	/^	char *uri;                      \/* first line if log needed, NULL otherwise *\/$/;"	m	struct:http_txn
uri_auth	include/common/uri_auth.h	/^struct uri_auth {$/;"	s
uri_auth	include/types/proxy.h	/^	struct uri_auth *uri_auth;		\/* if non-NULL, the (list of) per-URI authentications *\/$/;"	m	struct:proxy	typeref:struct:proxy::uri_auth
uri_dirs_depth1	include/types/proxy.h	/^	int  uri_dirs_depth1;			\/* directories+1 (slashes) limit for uri balancing algorithm *\/$/;"	m	struct:proxy
uri_len	include/common/uri_auth.h	/^	int uri_len;			\/* the prefix length *\/$/;"	m	struct:uri_auth
uri_len_limit	include/types/proxy.h	/^	int  uri_len_limit;			\/* character limit for uri balancing algorithm *\/$/;"	m	struct:proxy
uri_prefix	include/common/uri_auth.h	/^	char *uri_prefix;		\/* the prefix we want to match *\/$/;"	m	struct:uri_auth
uri_whole	include/types/proxy.h	/^	int  uri_whole;				\/* if != 0, calculates the hash from the whole uri. Still honors the len_limit and dirs_depth1 *\/$/;"	m	struct:proxy
url	contrib/halog/halog.c	/^		struct ebpt_node url;$/;"	m	union:url_stat::__anon108	typeref:struct:url_stat::__anon108::ebpt_node	file:
url	contrib/halog/halog.c	/^	char *url;$/;"	m	struct:url_stat	file:
url2ipv4	src/standard.c	/^int url2ipv4(const char *addr, struct in_addr *dst)$/;"	f
url2sa	src/standard.c	/^int url2sa(const char *url, int ulen, struct sockaddr_storage *addr, struct split_url *out)$/;"	f
url_decode	src/standard.c	/^int url_decode(char *string)$/;"	f
url_encode_map	src/proto_http.c	/^fd_set url_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
url_param_len	include/types/proxy.h	/^	int  url_param_len;			\/* strlen(url_param_name), computed only once *\/$/;"	m	struct:proxy
url_param_name	include/types/proxy.h	/^	char *url_param_name;			\/* name of the URL parameter used for hashing *\/$/;"	m	struct:proxy
url_stat	contrib/halog/halog.c	/^struct url_stat {$/;"	s	file:
usage	contrib/halog/halog.c	/^void usage(FILE *output, const char *msg)$/;"	f
usage	contrib/ip6range/ip6range.c	/^static void usage(const char *argv0)$/;"	f	file:
usage	contrib/iprange/iprange.c	/^static void usage(const char *argv0)$/;"	f	file:
usage	src/haproxy.c	/^void usage(char *name)$/;"	f
use	include/types/acl.h	/^	unsigned int use;           \/* or'ed bit mask of all acl_expr's SMP_USE_* *\/$/;"	m	struct:acl
use	include/types/acl.h	/^	unsigned int use;           \/* or'ed bit mask of all suites's SMP_USE_* *\/$/;"	m	struct:acl_cond
use	include/types/sample.h	/^	unsigned int use;                         \/* fetch source (SMP_USE_*) *\/$/;"	m	struct:sample_fetch
use_shared_mem	src/shctx.c	/^static int use_shared_mem = 0;$/;"	v	file:
use_ssl	include/types/checks.h	/^	int use_ssl;				\/* use SSL for health checks *\/$/;"	m	struct:check
use_ssl	include/types/server.h	/^	int use_ssl;				\/* ssl enabled *\/$/;"	m	struct:server
use_tsc	src/trace.c	/^static int use_tsc;$/;"	v	file:
used	include/common/memory.h	/^	unsigned int used;	\/* how many chunks are currently in use *\/$/;"	m	struct:pool_head
used	include/types/hdr_idx.h	/^	short used;                 \/* # of elements really used (1..size) *\/$/;"	m	struct:hdr_idx
used_listener_id	include/types/proxy.h	/^		struct eb_root used_listener_id;\/* list of listener IDs in use *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::eb_root
used_proxy_id	src/proxy.c	/^struct eb_root used_proxy_id = EB_ROOT;	\/* list of proxy IDs in use *\/$/;"	v	typeref:struct:eb_root
used_server_id	include/types/proxy.h	/^		struct eb_root used_server_id;	\/* list of server IDs in use *\/$/;"	m	struct:proxy::__anon19	typeref:struct:proxy::__anon19::eb_root
user	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users
user	include/types/proto_http.h	/^	char *user, *pass;                    \/* extracted username & password *\/$/;"	m	struct:http_auth_data
userlist	include/common/uri_auth.h	/^	struct userlist *userlist;	\/* private userlist to emulate legacy "stats auth user:password" *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::userlist
userlist	include/types/auth.h	/^struct userlist {$/;"	s
userlist	src/auth.c	/^struct userlist *userlist = NULL;    \/* list of all existing userlists *\/$/;"	v	typeref:struct:userlist
userlist_free	src/auth.c	/^userlist_free(struct userlist *ul)$/;"	f
userlist_postinit	src/auth.c	/^int userlist_postinit()$/;"	f
users	include/common/memory.h	/^	unsigned int users;	\/* number of pools sharing this zone *\/$/;"	m	struct:pool_head
users	include/common/mini-clist.h	/^	struct list users;$/;"	m	struct:bref	typeref:struct:bref::list
users	include/types/auth.h	/^	struct auth_users *users;$/;"	m	struct:userlist	typeref:struct:userlist::auth_users
usr	include/types/arg.h	/^	struct userlist *usr;$/;"	m	union:arg_data	typeref:struct:arg_data::userlist
utoa_pad	src/standard.c	/^char *utoa_pad(unsigned int n, char *dst, size_t size)$/;"	f
uuid	include/types/proxy.h	/^	int uuid;				\/* universally unique proxy ID, used for SNMP *\/$/;"	m	struct:proxy
uweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
ux	include/types/global.h	/^		} ux;$/;"	m	struct:global::__anon96	typeref:struct:global::__anon96::__anon97
ux	include/types/listener.h	/^	} ux;$/;"	m	struct:bind_conf	typeref:struct:bind_conf::__anon51
uxst_add_listener	src/proto_uxst.c	/^void uxst_add_listener(struct listener *listener)$/;"	f
uxst_bind_listener	src/proto_uxst.c	/^static int uxst_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f	file:
uxst_bind_listeners	src/proto_uxst.c	/^static int uxst_bind_listeners(struct protocol *proto, char *errmsg, int errlen)$/;"	f	file:
uxst_connect_server	src/proto_uxst.c	/^int uxst_connect_server(struct connection *conn, int data, int delack)$/;"	f
uxst_get_dst	src/proto_uxst.c	/^int uxst_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
uxst_get_src	src/proto_uxst.c	/^int uxst_get_src(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
uxst_unbind_listener	src/proto_uxst.c	/^static int uxst_unbind_listener(struct listener *listener)$/;"	f	file:
uxst_unbind_listeners	src/proto_uxst.c	/^static int uxst_unbind_listeners(struct protocol *proto)$/;"	f	file:
v	include/import/ip_tproxy.h	/^	} v;$/;"	m	struct:in_tproxy	typeref:union:in_tproxy::_in_args
v	include/types/hdr_idx.h	/^	struct hdr_idx_elem *v;     \/* the array itself *\/$/;"	m	struct:hdr_idx	typeref:struct:hdr_idx::hdr_idx_elem
v	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon64::__anon65
v4tov6	src/standard.c	/^void v4tov6(struct in6_addr *sin6_addr, struct in_addr *sin_addr)$/;"	f
v6tov4	src/standard.c	/^int v6tov4(struct in_addr *sin_addr, struct in6_addr *sin6_addr)$/;"	f
v_l	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon64::__anon65
v_l	include/types/proto_http.h	/^			int v_l;               \/* VERSION length (version starts at buf->p) *\/$/;"	m	struct:http_msg::__anon64::__anon66
val	contrib/halog/halog.c	/^		struct eb64_node val;$/;"	m	union:url_stat::__anon108	typeref:struct:url_stat::__anon108::eb64_node	file:
val	include/types/acl.h	/^	unsigned int val;           \/* or'ed bit mask of all acl_expr's SMP_VAL_* *\/$/;"	m	struct:acl
val	include/types/acl.h	/^	unsigned int val;           \/* or'ed bit mask of all suites's SMP_VAL_* *\/$/;"	m	struct:acl_cond
val	include/types/pattern.h	/^	} val;                                  \/* direct value *\/$/;"	m	struct:pattern	typeref:union:pattern::__anon10
val	include/types/proto_http.h	/^	int  val;  \/* relative to line, may skip some leading white spaces *\/$/;"	m	struct:hdr_ctx
val	include/types/sample.h	/^	unsigned int val;                         \/* fetch validity (SMP_VAL_*) *\/$/;"	m	struct:sample_fetch
val	src/cfgparse.c	/^	unsigned int val;$/;"	m	struct:cfg_opt	file:
val_args	include/types/sample.h	/^	int (*val_args)(struct arg *arg_p,$/;"	m	struct:sample_conv
val_args	include/types/sample.h	/^	int (*val_args)(struct arg *arg_p,$/;"	m	struct:sample_fetch
val_hdr	src/proto_http.c	/^static int val_hdr(struct arg *arg, char **err_msg)$/;"	f	file:
val_payload_lv	src/payload.c	/^static int val_payload_lv(struct arg *arg, char **err_msg)$/;"	f	file:
value	include/types/connection.h	/^	uint8_t value[0];$/;"	m	struct:tlv
value	include/types/proto_http.h	/^			struct list value;     \/* pattern to retrieve MAP value *\/$/;"	m	struct:http_req_rule::__anon67::__anon70	typeref:struct:http_req_rule::__anon67::__anon70::list
value	include/types/proto_http.h	/^			struct list value;     \/* pattern to retrieve MAP value *\/$/;"	m	struct:http_res_rule::__anon71::__anon73	typeref:struct:http_res_rule::__anon71::__anon73::list
value	include/types/stream_interface.h	/^			long long value;	\/* value to compare against *\/$/;"	m	struct:appctx::__anon43::__anon47
var_args_list	src/log.c	/^struct logformat_var_args var_args_list[] = {$/;"	v	typeref:struct:logformat_var_args
ver_cmd	include/types/connection.h	/^	uint8_t ver_cmd;   \/* protocol version and command *\/$/;"	m	struct:proxy_hdr_v2
verify	include/types/connection.h	/^	uint32_t verify;$/;"	m	struct:tlv_ssl
verify	include/types/listener.h	/^	int verify;                \/* verify method (set of SSL_VERIFY_* flags) *\/$/;"	m	struct:bind_conf
verify	include/types/server.h	/^		int verify;			\/* verify method (set of SSL_VERIFY_* flags) *\/$/;"	m	struct:server::__anon99
verify_host	include/types/server.h	/^		char *verify_host;              \/* hostname of certificate must match this host *\/$/;"	m	struct:server::__anon99
version	include/import/ip_tproxy.h	/^		u_int32_t		version;$/;"	m	union:in_tproxy::_in_args
version	src/shctx.c	/^	unsigned char version;$/;"	m	struct:shsess_packet	file:
vlen	include/types/proto_http.h	/^	int  vlen; \/* relative to line+val, stops before trailing white spaces *\/$/;"	m	struct:hdr_ctx
vsyscall	src/i386-linux-vsys.c	/^static void *vsyscall = &int80;  \/* initialize vsyscall to use int80 by default *\/$/;"	v	file:
w	tests/filltab25.c	/^	int w; \/* weight *\/$/;"	m	struct:srv	file:
wait_queue	include/types/listener.h	/^	struct list wait_queue;		\/* link element to make the listener wait for something (LI_LIMITED)  *\/$/;"	m	struct:listener	typeref:struct:listener::list
wake	include/types/connection.h	/^	int  (*wake)(struct connection *conn);  \/* data-layer callback to report activity *\/$/;"	m	struct:data_cb
wake_expired_tasks	src/task.c	/^void wake_expired_tasks(int *next)$/;"	f
wake_srv_chk	src/checks.c	/^static int wake_srv_chk(struct connection *conn)$/;"	f	file:
warmup	include/types/server.h	/^	struct task *warmup;                    \/* the task dedicated to the warmup when slowstart is set *\/$/;"	m	struct:server	typeref:struct:server::task
warned	src/haproxy.c	/^unsigned int warned = 0;$/;"	v
warnif_cond_conflicts	src/cfgparse.c	/^static int warnif_cond_conflicts(const struct acl_cond *cond, unsigned int where, const char *file, int line)$/;"	f	file:
warnif_misplaced_block	src/cfgparse.c	/^int warnif_misplaced_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_http_req	src/cfgparse.c	/^int warnif_misplaced_http_req(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_redirect	src/cfgparse.c	/^int warnif_misplaced_redirect(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_reqadd	src/cfgparse.c	/^int warnif_misplaced_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_reqxxx	src/cfgparse.c	/^int warnif_misplaced_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_block	src/cfgparse.c	/^int warnif_rule_after_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_http_req	src/cfgparse.c	/^int warnif_rule_after_http_req(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_redirect	src/cfgparse.c	/^int warnif_rule_after_redirect(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_reqadd	src/cfgparse.c	/^int warnif_rule_after_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_reqxxx	src/cfgparse.c	/^int warnif_rule_after_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_use_backend	src/cfgparse.c	/^int warnif_rule_after_use_backend(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_use_server	src/cfgparse.c	/^int warnif_rule_after_use_server(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnifnotcap	include/common/cfgparse.h	/^static inline int warnifnotcap(struct proxy *proxy, int cap, const char *file, int line, const char *arg, const char *hint)$/;"	f
wdiv	include/types/backend.h	/^	int wdiv;			\/* ratio between effective weight and user weight *\/$/;"	m	struct:lbprm
wex	include/types/channel.h	/^	int wex;                        \/* expiration date for a write or connect, in ticks *\/$/;"	m	struct:channel
when	include/types/proxy.h	/^	struct timeval when;		\/* date of this event, (tv_sec == 0) means "never" *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::timeval
while_dlist_item	include/common/mini-clist.h	109;"	d
wmult	include/types/backend.h	/^	int wmult;			\/* ratio between user weight and effective weight *\/$/;"	m	struct:lbprm
word_match	src/standard.c	/^int word_match(const char *sample, int slen, const char *word, int wlen)$/;"	f
wordlist	include/common/mini-clist.h	/^struct wordlist {$/;"	s
wq	include/types/task.h	/^	struct eb32_node wq;		\/* ebtree node used to hold the task in the wait queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node
wrapper_argc	src/haproxy-systemd-wrapper.c	/^static int wrapper_argc;$/;"	v	file:
wrapper_argv	src/haproxy-systemd-wrapper.c	/^static char **wrapper_argv;$/;"	v	file:
wscore	include/types/server.h	/^	unsigned wscore;			\/* weight score, used during srv map computation *\/$/;"	m	struct:server
wt_hash	tests/test_hashes.c	/^unsigned wt_hash ( void *key, int len )$/;"	f
wto	include/types/channel.h	/^	int wto;                        \/* write timeout, in ticks *\/$/;"	m	struct:channel
xchg	src/shctx.c	/^static inline unsigned int xchg(unsigned int *ptr, unsigned int x)$/;"	f	file:
xfer_large	include/types/channel.h	/^	unsigned char xfer_large;       \/* number of consecutive large xfers *\/$/;"	m	struct:channel
xfer_small	include/types/channel.h	/^	unsigned char xfer_small;       \/* number of consecutive small xfers *\/$/;"	m	struct:channel
xprt	include/types/connection.h	/^	const struct xprt_ops *xprt;  \/* operations at the transport layer *\/$/;"	m	struct:connection	typeref:struct:connection::xprt_ops
xprt	include/types/listener.h	/^	struct xprt_ops *xprt;          \/* transport-layer operations for this socket *\/$/;"	m	struct:listener	typeref:struct:listener::xprt_ops
xprt	include/types/peers.h	/^	struct xprt_ops *xprt;         \/* peer socket operations at transport layer *\/$/;"	m	struct:peer	typeref:struct:peer::xprt_ops
xprt	include/types/server.h	/^		struct xprt_ops *xprt;          \/* transport layer operations for health checks *\/$/;"	m	struct:server::__anon98	typeref:struct:server::__anon98::xprt_ops
xprt	include/types/server.h	/^	struct xprt_ops *xprt;                  \/* transport-layer operations *\/$/;"	m	struct:server	typeref:struct:server::xprt_ops
xprt_ctx	include/types/connection.h	/^	void *xprt_ctx;               \/* general purpose pointer, initialized to NULL *\/$/;"	m	struct:connection
xprt_ops	include/types/connection.h	/^struct xprt_ops {$/;"	s
xprt_st	include/types/connection.h	/^	int xprt_st;                  \/* transport layer state, initialized to zero *\/$/;"	m	struct:connection
zero	src/haproxy.c	/^const int zero = 0;$/;"	v
zlib_deflate_state	include/types/compression.h	/^	void *zlib_deflate_state;$/;"	m	struct:comp_ctx
zlib_head	include/types/compression.h	/^	void *zlib_head;$/;"	m	struct:comp_ctx
zlib_pending_buf	include/types/compression.h	/^	void *zlib_pending_buf;$/;"	m	struct:comp_ctx
zlib_pool_deflate_state	src/compression.c	/^static struct pool_head *zlib_pool_deflate_state = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_head	src/compression.c	/^static struct pool_head *zlib_pool_head = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_pending_buf	src/compression.c	/^static struct pool_head *zlib_pool_pending_buf = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_prev	src/compression.c	/^static struct pool_head *zlib_pool_prev = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_window	src/compression.c	/^static struct pool_head *zlib_pool_window = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_prev	include/types/compression.h	/^	void *zlib_prev;$/;"	m	struct:comp_ctx
zlib_used_memory	src/compression.c	/^long zlib_used_memory = 0;$/;"	v
zlib_window	include/types/compression.h	/^	void *zlib_window;$/;"	m	struct:comp_ctx
zlibmemlevel	include/types/global.h	/^		int zlibmemlevel;    \/* zlib memlevel *\/$/;"	m	struct:global::__anon95
zlibwindowsize	include/types/global.h	/^		int zlibwindowsize;  \/* zlib window size *\/$/;"	m	struct:global::__anon95
